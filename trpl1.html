<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="crowbook">
    <meta name="viewport" content="width=device-width">
    <meta name="author" content="The Rust Project Developpers">
    
    <title>The Rust Programming Language</title>
    <style type = "text/css">
      body {
    font-family: "Linux Libertine", "Georgia", serif;
    text-align: justify;
    font-size: 100%;
}

p {
    text-indent: 1.25em;
    margin:0;
    hyphens: auto;
}

blockquote {
    margin: 1em;
    font-style: italic;
}
code {
    font-size: 80%;
    font-family: "Linux Libertine Mono", monospace;
    background-color: #F0F0F0;
}
pre {
    font-family: "Linux Libertine Mono", monospace;
    margin: 1em;
    padding-top: 0;
    background-color: #F0F0F0;
    white-space: pre-wrap;
    word-wrap: break-word;
}
/* Try to disable hyphenation in titles */
h1, h2, h3, h4, h5, h5 {
    adobe-hyphenate: none;
    -ms-hyphens: none; /* Trident (Windows) */
    -moz-hyphens: none; /* Gecko (Firefox) */
    -webkit-hyphens: none; /* Webkit */
    -epub-hyphens: none; /* EPUB 3 */
    hyphens: none; /* Futur standard */
}

h1, h2, h3, h4, h5, h6 {
    text-align: left;
    font-family: Linux Biolinum, sans-serif;
    font-variant: small-caps;
}

/* Title of a part */
h1.part {
    font-size: 250%;
    text-align: center;
}

/* The `Part X` section of a part */
h2.part {
    font-size: 175%;
    text-align: center;
}

/* The "Chapter X" section of a chapter */
span.chapter-header {
    font-size: 75%;
}

/* Title of the book */
h1.title {
    text-align: center;
    font-size: 300%;
}
/* Author */
h2.author {
    text-align: right;
    font-size:  200%;
}

/* Subtitle */
h2.subtitle {
    text-align: center;
    font-size: 200%;
}

/* When toc is displayed inlined */
#toc ol, #toc ul {
    padding: 0;
    margin-left: 1em;
}
#toc li {
    list-style-type: none;
    margin: 0; padding: 0;
}

#toc li:before {
    content: none;
}

#cover img {
    width: 100%;
    max-height: 100%;
}

.image {
    margin: auto;
    width: 80%;
}

.image img {
    width: 100%;
    max-height: 100%;
}

.rule {
    text-align: center !important;
    margin-top: 1em;
    margin-bottom: 1em;
    font-weight: bold;
    page-break-inside: avoid;
    break-inside: avoid;
    page-break-after: avoid;
    break-after: avoid;
}

/* The number of the note in an expanded footnote (e.g. [3]) */
.note-number {
    font-weight: bold;
    margin-right: 1em;
}

td.note-number {
    vertical-align: top;
}

/* When footnotes (try to) be diplayed as margin notes */
.sidenote {
    display: block;
    float: right;
    width: 30%;
    border: 1px solid black;
    margin: 1em;
    padding: .5em;
    margin-right: -1.5em;
}

.sidenote .note-number {
    float: left;
}

/* The div class displaying notes at the end of a chapter */
div.notes {
    text-align: justify;
    border-top: thin dashed black;
    margin-top: 1em;
}

table.notes {
    border-collapse: collapse;
    border-style: hidden;
}

table.notes tr td {
    margin-left: 1em;
    margin-right: 1em;
}

table.notes tr td p {
    text-indent: 0;
}
                 
/* Every markdown table is included in a <div class = "table"> */
.table {
    margin: 1em;
}

.table table {
    width: 80%;
    margin: 0 auto;
    border-style: solid;
    border-width: thin;
    border-color: black;
    border-collapse: collapse;
}

.table table th, .table table td {
    border-style: solid;
    border-width: 1px;
    text-align: center;
}

.table table th {
    font-weight: bold;
    font-variant: small-caps;
}


span.initial { 
    float: left;
    font-size: 285%;
    font-weight: bold;
    margin-right: 0.05em;
    line-height: 0.8em;
}

p.first-para {
    text-indent: 0;
}

/* Use this for escape narrow space so it is non-breaking */
.nnbsp {
    /* white-space: nowrap;*/
    word-spacing: -0.13em;
    /* Following necessary for Kobo EPUB3 reader??? */
    margin: 0;
    padding: 0;
}

/* Default  HTML CSS file includes default EPUB CSS file */

/* Colours for the navigation menu (toc) */
nav {
    background: #CBBFCC;
    color: black;
    border-right-color: black;
}

#nav a:link {
    color: black;
}

#nav a:visited {
    color: black;
}

/* Colours for top and footer */
#top {
    background-color: #444343;
    color: white;
}

footer {
    background-color: #444343;
    color: white;
}

footer a, #top a {
    color: #fc71ff;
}

footer a:hover, #top a:hover {
    color: #b743fe;
}

/* Additional elements, only use for proofreading */
/* Grammar error */
.grammar-error {
    color: red;
    text-decoration-line: underline;
    text-decoration-style: double;
/*    background: #d966ff;*/
}


p.first-para:first-letter {
    font-size: 300%;
    float: left;
    font-weight: bold;
    margin-right: 0.05em;
    line-height: 1em;
}

/* The nav element corresponding to the navigation menu */
nav {
    z-index: 2;
    position: fixed;
    left: 0;
    top: 0;
    bottom: 0;
    width: 20%;
    overflow-y: auto;
    font-size: 80%;
    margin-left: 0;
    border-right-width: 2px;
    border-right-style: dashed;
}

#nav code {
    background-color: transparent;
}

#nav a:link {
    text-decoration: none;
}

#nav a:visited {
    text-decoration: none;
}

#nav {
    text-align: left;
}

#nav h2 {
    text-align: center;
}

#nav li {
    list-style-type: none;
    text-indent: -1em;
}

#nav li:before {
    content: none;
}

#nav ul {
    padding-right: 1em;
    padding-left: 1.5em;
}

/* The menu containing the button to display the navigation bar */
#menu {
    position: fixed;
    z-index: 2;
    top: 0em;
    left: 1em;
    transition: left 1s;
}

#menu img {
    opacity: 0.5;
}

#menu img:hover {
    opacity: 1.0;
    cursor: pointer;
}

#menu-button {
    height: 1.5em;
    padding: 0.5em;
}

#book-button {
    height: 1.5em;
    padding: 0.5em;
    float: left;
}

/* Hide navigation bar */
#nav {
    left: -21%;
    transition: left 1s;
}

/* The main content of the book */
#content {
    overflow-y: auto;
    margin-left: 0;
    margin-right: 0;
    margin-top: 0;
    margin-bottom: 0;
    transition: margin-left 1s;
}

/* Used for multifiles HTML */
.prev_chapter {
    text-align: left;
    text-indent: 0;
    margin-bottom: 1em;
    font-size: 120%;
    font-variant: small-caps;
    font-weight: bold;
}

.next_chapter {
    text-align: right;
    margin-top: 1em;
    margin-bottom: 1em;
    font-size: 120%;
    font-variant: small-caps;
    font-weight: bold;
}

/* Improving readability for the HTML format only */
p, blockquote, li, .image  {
    margin-right: auto;
    max-width: 33em;
}

blockquote {
    padding: 1em;
}

#content {
    text-align: center;
}

#page {
    display: inline-block;
    text-align: justify;
    max-width: 33em;
}

#nav-container {
    top: 0;
    width: 100%;
}

#nav-title {
    top: 0;
}

#toolbar {
    top: 0;
    float: left;
}

#toolbar img {
    cursor: pointer;
}

footer {
    margin-top: 2em;
    margin-bottom: 0;
}

#top {
    margin-top: 0;
    margin-bottom: 1em;
}

#top p {
    font-family: "Linux Biolinum";
    font-weight: bold;
    font-variant: small-caps;
}

footer, #top {
    padding-top: .25em;
    padding-bottom: .25em;
    margin-left: 0;
    margin-right: 0;
    text-align: center;
    transition: margin-left 1s;
}

footer a, #top a {
    text-decoration: none;
}

footer p, #top p {
    text-indent: 0;
    margin-left: auto;
    margin-right: auto;
    margin-bottom: 0.5em;
    margin-top: 0.5em;
    max-width: 33em;
}


    </style>
    <style type = "text/css" media = "print">
      #page {
    display: block;
}

.chapter {
    page-break-before: always;
}

#menu {
    display: none;
}

#nav {
    display: none;
}
    </style>
   <script>
function on(name) {
    var elements = document.getElementsByClassName(name);
    for (var i = 0; i < elements.length; i++) {
        var elem = elements[i];
        elem.style.backgroundColor = "pink";
    }
}
function off(name) {
    var elements = document.getElementsByClassName(name);
    for (var i = 0; i < elements.length; i++) {
        var elem = elements[i];
        elem.style.backgroundColor = "white";
    }
}

var display_menu = false;
function toggle() {
    if (display_menu == true) {
        display_menu = false;
        document.getElementById("nav").style.left = "-21%";
        document.getElementById("content").style.marginLeft = "0%";
        document.getElementById("menu").style.left = "1em";
/*        if(document.getElementById("top")) {
            document.getElementById("top").style.left = "0";
        }
        if(document.getElementById("footer")) {
            document.getElementById("footer").style.marginLeft = "0%";
        }*/
    } else {
        display_menu = true;
        document.getElementById("nav").style.left = "0";
        document.getElementById("content").style.marginLeft = "20%";
        document.getElementById("menu").style.left = "20%";
/*        if(document.getElementById("top")) {
            document.getElementById("top").style.left = "20%";
        }
        if(document.getElementById("footer")) {
            document.getElementById("footer").style.marginLeft = "20%";
        }*/
    }
}



   </script>


  </head>
  <body>
    
<script type = 'application/ld+json'>
{
    "@context": "http://schema.org/",
    "@type": "Book",
    "author": "The Rust Project Developpers",
    "name": "The Rust Programming Language",
    
    
    
    
    
    "inLanguage": "en"




}
</script>
    <nav id = "nav">
      <div id = "nav-title">
        <h2><a href = "#link-0">The Rust Programming Language</a></h2>
      </div>
      <ul>
<li><a href="#link-1">I. Introduction</a>
<ul><li><a href="#link-2">1. The Rust Programming Language</a></li>

</ul>
</li>
<li><a href="#link-4">II. Getting Started</a>
<ul><li><a href="#link-5">1. Getting Started</a></li>
<li><a href="#link-6">2. Installing Rust</a></li>
<li><a href="#link-10">3. Hello, world!</a></li>
<li><a href="#link-15">4. Hello, Cargo!</a></li>
<li><a href="#link-23">5. Closing Thoughts</a></li>

</ul>
</li>
<li><a href="#link-24">III. Tutorial: Guessing Games</a>
<ul><li><a href="#link-25">1. Guessing Game</a></li>
<li><a href="#link-26">2. Set up</a></li>
<li><a href="#link-27">3. Processing a Guess</a></li>
<li><a href="#link-28">4. Generating a secret number</a></li>
<li><a href="#link-29">5. Comparing guesses</a></li>
<li><a href="#link-30">6. Looping</a></li>
<li><a href="#link-31">7. Complete!</a></li>

</ul>
</li>
<li><a href="#link-32">IV. Syntax and Semantics</a>
<ul><li><a href="#link-33">1. Syntax and Semantics</a></li>

</ul>
</li>
<li><a href="#link-227">V. Effective Rust</a>
<ul><li><a href="#link-228">1. Effective Rust</a></li>

</ul>
</li>
<li><a href="#link-368">VI. Appendix</a>
<ul><li><a href="#link-369">1. Glossary</a></li>
<li><a href="#link-378">2. Syntax Index</a></li>
<li><a href="#link-382">3. Bibliography</a></li>

</ul>
</li>

</ul>

    </nav>

    <div id = "content">
      
      <div id = "page">
        <header>

          <div id = "menu">
            <img id = "menu-button" onclick="toggle();"
                 src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMjAwbW0iCiAgIGhlaWdodD0iMjAwbW0iCiAgIHZpZXdCb3g9IjAgMCA3MDguNjYxNDIgNzA4LjY2MTQxIgogICBpZD0ic3ZnMiIKICAgdmVyc2lvbj0iMS4xIgogICBpbmtzY2FwZTp2ZXJzaW9uPSIwLjkxIHIxMzcyNSIKICAgc29kaXBvZGk6ZG9jbmFtZT0ibWVudS5zdmciPgogIDxkZWZzCiAgICAgaWQ9ImRlZnM0IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjQ5NDk3NDc1IgogICAgIGlua3NjYXBlOmN4PSIxMDUuNjEyNzUiCiAgICAgaW5rc2NhcGU6Y3k9IjQwNy4wNjM5MSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC11bml0cz0icHgiCiAgICAgaW5rc2NhcGU6Y3VycmVudC1sYXllcj0ibGF5ZXIxIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEzNjYiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iNzA0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNyIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIiAvPgogIDxtZXRhZGF0YQogICAgIGlkPSJtZXRhZGF0YTciPgogICAgPHJkZjpSREY+CiAgICAgIDxjYzpXb3JrCiAgICAgICAgIHJkZjphYm91dD0iIj4KICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3N2Zyt4bWw8L2RjOmZvcm1hdD4KICAgICAgICA8ZGM6dHlwZQogICAgICAgICAgIHJkZjpyZXNvdXJjZT0iaHR0cDovL3B1cmwub3JnL2RjL2RjbWl0eXBlL1N0aWxsSW1hZ2UiIC8+CiAgICAgICAgPGRjOnRpdGxlPjwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxnCiAgICAgaW5rc2NhcGU6bGFiZWw9IkxheWVyIDEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpZD0ibGF5ZXIxIgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsLTM0My43MDA3OSkiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTA0LjMzMDcxLDQ2OS41MDUxIDUwMCwwIgogICAgICAgaWQ9InBhdGg0MTM2IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZTojMDAwMDAwO3N0cm9rZS13aWR0aDoxMDA7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBkPSJtIDEwNC4zMzA3MSw3MDQuNTA1MSA1MDAsMCIKICAgICAgIGlkPSJwYXRoNDEzNi01IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlua3NjYXBlOnRyYW5zZm9ybS1jZW50ZXIteD0iNzEuNDI4NTcyIgogICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci15PSItMjQyLjg1NzE2IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1ydWxlOmV2ZW5vZGQ7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjEwMDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gMTA0LjMzMDcxLDkzOS41MDUwNiA1MDAsMCIKICAgICAgIGlkPSJwYXRoNDEzNi01LTMiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaW5rc2NhcGU6dHJhbnNmb3JtLWNlbnRlci14PSI3MS40Mjg1NzIiCiAgICAgICBpbmtzY2FwZTp0cmFuc2Zvcm0tY2VudGVyLXk9Ii0yNDIuODU3MTYiIC8+CiAgPC9nPgo8L3N2Zz4K"
                 alt = "Table of contents" title = "Table of contents" />
          </div>
	  <h2 class="author">The Rust Project Developpers</h2>
          <h1 id = "link-0" class="title" >The Rust Programming Language</h1>
	  
        </header>

        <div id = "toc">
  <h1>Table of contents</h1>
  <ul>
<li><a href="#link-1">I. Introduction</a>
<ul><li><a href="#link-2">1. The Rust Programming Language</a></li>

</ul>
</li>
<li><a href="#link-4">II. Getting Started</a>
<ul><li><a href="#link-5">1. Getting Started</a></li>
<li><a href="#link-6">2. Installing Rust</a></li>
<li><a href="#link-10">3. Hello, world!</a></li>
<li><a href="#link-15">4. Hello, Cargo!</a></li>
<li><a href="#link-23">5. Closing Thoughts</a></li>

</ul>
</li>
<li><a href="#link-24">III. Tutorial: Guessing Games</a>
<ul><li><a href="#link-25">1. Guessing Game</a></li>
<li><a href="#link-26">2. Set up</a></li>
<li><a href="#link-27">3. Processing a Guess</a></li>
<li><a href="#link-28">4. Generating a secret number</a></li>
<li><a href="#link-29">5. Comparing guesses</a></li>
<li><a href="#link-30">6. Looping</a></li>
<li><a href="#link-31">7. Complete!</a></li>

</ul>
</li>
<li><a href="#link-32">IV. Syntax and Semantics</a>
<ul><li><a href="#link-33">1. Syntax and Semantics</a></li>

</ul>
</li>
<li><a href="#link-227">V. Effective Rust</a>
<ul><li><a href="#link-228">1. Effective Rust</a></li>

</ul>
</li>
<li><a href="#link-368">VI. Appendix</a>
<ul><li><a href="#link-369">1. Glossary</a></li>
<li><a href="#link-378">2. Syntax Index</a></li>
<li><a href="#link-382">3. Bibliography</a></li>

</ul>
</li>

</ul>

</div>
<div id = "chapter-0" class = "chapter">
  <h2 class = 'part'>Part I</h2> <h1 id = 'link-1' class = 'part'>Introduction</h1>
</div><div id = "chapter-1" class = "chapter">
  <h1 id = 'link-2'><span class = 'chapter-header'>Chapter 1</span><br />The Rust Programming Language</h1><p id = "para-1">Welcome! This book will teach you about the <a href = "https://www.rust-lang.org">Rust Programming Language</a>. Rust is a systems programming language focused on three goals: safety, speed, and concurrency. It maintains these goals without having a garbage collector, making it a useful language for a number of use cases other languages aren’t good at: embedding in other languages, programs with specific space and time requirements, and writing low-level code, like device drivers and operating systems. It improves on current languages targeting this space by having a number of compile-time safety checks that produce no runtime overhead, while eliminating all data races. Rust also aims to achieve ‘zero-cost abstractions’ even though some of these abstractions feel like those of a high-level language. Even then, Rust still allows precise control like a low-level language would.</p>
<p id = "para-2">“The Rust Programming Language” is split into chapters. This introduction is the first. After this:</p>
<ul>
<li><a href = "#chapter-3">Getting started</a> - Set up your computer for Rust development.</li>
<li><a href = "#chapter-5">Tutorial: Guessing Game</a> - Learn some Rust with a small project.</li>
<li><a href = "#chapter-7">Syntax and Semantics</a> - Each bit of Rust, broken down into small chunks.</li>
<li><a href = "#chapter-45">Effective Rust</a> - Higher-level concepts for writing excellent Rust code.</li>
<li><a href = "#chapter-60">Glossary</a> - A reference of terms used in the book.</li>
<li><a href = "#chapter-62">Bibliography</a> - Background on Rust’s influences, papers about Rust.</li>
</ul>
<h2 id = "link-3">Source Code</h2>
<p id = "para-3">The source files from which this book is generated can be found on <a href = "https://github.com/rust-lang/book/tree/master/first-edition/src">GitHub</a>.</p>

</div><div id = "chapter-2" class = "chapter">
  <h2 class = 'part'>Part II</h2> <h1 id = 'link-4' class = 'part'>Getting Started</h1>
</div><div id = "chapter-3" class = "chapter">
  <h1 id = 'link-5'><span class = 'chapter-header'>Chapter 1</span><br />Getting Started</h1><p id = "para-4">This first chapter of the book will get us going with Rust and its tooling. First, we’ll install Rust. Then, the classic ‘Hello World’ program. Finally, we’ll talk about Cargo, Rust’s build system and package manager.</p>
<p id = "para-5">We’ll be showing off a number of commands using a terminal, and those lines all start with <code>$</code>. You don’t need to type in the <code>$</code>s, they are there to indicate the start of each command. We’ll see many tutorials and examples around the web that follow this convention: <code>$</code> for commands run as our regular user, and <code>#</code> for commands we should be running as an administrator.</p>
<h1 id = 'link-6'><span class = 'chapter-header'>Chapter 2</span><br />Installing Rust</h1><p id = "para-6">The first step to using Rust is to install it. Generally speaking, you’ll need an Internet connection to run the commands in this section, as we’ll be downloading Rust from the Internet.</p>
<p id = "para-7">The Rust compiler runs on, and compiles to, a great number of platforms, but is best supported on Linux, Mac, and Windows, on the x86 and x86-64 CPU architecture. There are official builds of the Rust compiler and standard library for these platforms and more. <a href = "https://forge.rust-lang.org/platform-support.html">For full details on Rust platform support see the website</a>.</p>
<h2 id = "link-7">Installing Rust</h2>
<p id = "para-8">All you need to do on Unix systems like Linux and macOS is open a terminal and type this:</p>
<pre><span style="color:#323232;">$ curl https://sh.rustup.rs -sSf </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#323232;">sh
</span></pre><p id = "para-9">It will download a script, and start the installation. If everything goes well, you’ll see this appear:</p>
<pre><span style="color:#323232;">Rust is installed now. Great! 
</span></pre><p id = "para-10">Installing on Windows is nearly as easy: download and run <a href = "https://win.rustup.rs">rustup-init.exe</a>. It will start the installation in a console and present the above message on success.</p>
<p id = "para-11">For other installation options and information, visit the <a href = "https://www.rust-lang.org/install.html">install</a> page of the Rust website.</p>
<h2 id = "link-8">Uninstalling</h2>
<p id = "para-12">Uninstalling Rust is as easy as installing it:</p>
<pre><span style="color:#323232;">$ rustup self uninstall
</span></pre><h2 id = "link-9">Troubleshooting</h2>
<p id = "para-13">If we’ve got Rust installed, we can open up a shell, and type this:</p>
<pre><span style="color:#323232;">$ rustc --version
</span></pre><p id = "para-14">You should see the version number, commit hash, and commit date.</p>
<p id = "para-15">If you do, Rust has been installed successfully! Congrats!</p>
<p id = "para-16">If you don’t, that probably means that the <code>PATH</code> environment variable doesn’t include Cargo’s binary directory, <code>~/.cargo/bin</code> on Unix, or <code>%USERPROFILE%\.cargo\bin</code> on Windows. This is the directory where Rust development tools live, and most Rust developers keep it in their <code>PATH</code> environment variable, which makes it possible to run <code>rustc</code> on the command line. Due to differences in operating systems, command shells, and bugs in installation, you may need to restart your shell, log out of the system, or configure <code>PATH</code> manually as appropriate for your operating environment.</p>
<p id = "para-17">Rust does not do its own linking, and so you’ll need to have a linker installed. Doing so will depend on your specific system. For Linux-based systems, Rust will attempt to call <code>cc</code> for linking. On <code>windows-msvc</code> (Rust built on Windows with Microsoft Visual Studio), this depends on having <a href = "http://landinghub.visualstudio.com/visual-cpp-build-tools">Microsoft Visual C++ Build Tools</a> installed. These do not need to be in <code>%PATH%</code> as <code>rustc</code> will find them automatically. In general, if you have your linker in a non-traditional location you can call <code>rustc linker=/path/to/cc</code>, where <code>/path/to/cc</code> should point to your linker path.</p>
<p id = "para-18">If you are still stuck, there are a number of places where we can get help. The easiest is <a href = "irc://irc.mozilla.org/#rust-beginners">the #rust-beginners IRC channel on irc.mozilla.org</a> and for general discussion <a href = "irc://irc.mozilla.org/#rust">the #rust IRC channel on irc.mozilla.org</a>, which we can access through <a href = "http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust-beginners,%23rust">Mibbit</a>. Then we’ll be chatting with other Rustaceans (a silly nickname we call ourselves) who can help us out. Other great resources include <a href = "https://users.rust-lang.org/">the user’s forum</a> and <a href = "http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<p id = "para-19">This installer also installs a copy of the documentation locally, so we can read it offline. It’s only a <code>rustup doc</code> away!</p>
<h1 id = 'link-10'><span class = 'chapter-header'>Chapter 3</span><br />Hello, world!</h1><p id = "para-20">Now that you have Rust installed, we’ll help you write your first Rust program. It’s traditional when learning a new language to write a little program to print the text “Hello, world!” to the screen, and in this section, we’ll follow that tradition.</p>
<p id = "para-21">The nice thing about starting with such a simple program is that you can quickly verify that your compiler is installed, and that it’s working properly. Printing information to the screen is also a pretty common thing to do, so practicing it early on is good.</p>
<blockquote><p id = "para-22">Note: This book assumes basic familiarity with the command line. Rust itself makes no specific demands about your editing, tooling, or where your code lives, so if you prefer an IDE to the command line, that’s an option. You may want to check out <a href = "https://github.com/oakes/SolidOak">SolidOak</a>, which was built specifically with Rust in mind. There are a number of extensions in development by the community, and the Rust team ships plugins for <a href = "https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">various editors</a>. Configuring your editor or IDE is out of the scope of this tutorial, so check the documentation for your specific setup.</p>
</blockquote>
<h2 id = "link-11">Creating a Project File</h2>
<p id = "para-23">First, make a file to put your Rust code in. Rust doesn’t care where your code lives, but for this book, I suggest making a <em>projects</em> directory in your home directory, and keeping all your projects there. Open a terminal and enter the following commands to make a directory for this particular project:</p>
<pre><span style="color:#323232;">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</span></pre><blockquote><p id = "para-24">Note: If you’re on Windows and not using PowerShell, the <code>~</code> may not work. Consult the documentation for your shell for more details.</p>
</blockquote>
<h2 id = "link-12">Writing and Running a Rust Program</h2>
<p id = "para-25">We need to create a source file for our Rust program. Rust files always end in a <em>.rs</em> extension. If you are using more than one word in your filename, use an underscore to separate them; for example, you would use <em>my_program.rs</em> rather than <em>myprogram.rs</em>.</p>
<p id = "para-26">Now, make a new file and call it <em>main.rs</em>. Open the file and type the following code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello, world!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-27">Save the file, and go back to your terminal window. On Linux or macOS, enter the following commands:</p>
<pre><span style="color:#323232;">$ rustc main.rs
$ ./main
Hello, world!
</span></pre><p id = "para-28">In Windows, replace <code>main</code> with <code>main.exe</code>. Regardless of your operating system, you should see the string <code>Hello, world!</code> print to the terminal. If you did, then congratulations! You’ve officially written a Rust program. That makes you a Rust programmer! Welcome.</p>
<h2 id = "link-13">Anatomy of a Rust Program</h2>
<p id = "para-29">Now, let’s go over what just happened in your “Hello, world!” program in detail. Here’s the first piece of the puzzle:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {

}
</span></pre><p id = "para-30">These lines define a <em>function</em> in Rust. The <code>main</code> function is special: it’s the beginning of every Rust program. The first line says, “I’m declaring a function named <code>main</code> that takes no arguments and returns nothing.” If there were arguments, they would go inside the parentheses (<code>(</code> and <code>)</code>), and because we aren’t returning anything from this function, we can omit the return type entirely.</p>
<p id = "para-31">Also note that the function body is wrapped in curly braces (<code>{</code> and <code>}</code>). Rust requires these around all function bodies. It’s considered good style to put the opening curly brace on the same line as the function declaration, with one space in between.</p>
<p id = "para-32">Inside the <code>main()</code> function:</p>
<pre><span style="color:#323232;">    println!(</span><span style="color:#183691;">&quot;Hello, world!&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-33">This line does all of the work in this little program: it prints text to the screen. There are a number of details that are important here. The first is that it’s indented with four spaces, not tabs.</p>
<p id = "para-34">The second important part is the <code>println!()</code> line. This is calling a Rust <em><a href = "#chapter-41">macro</a></em>, which is how metaprogramming is done in Rust. If it were calling a function instead, it would look like this: <code>println()</code> (without the !). We’ll discuss Rust macros in more detail later, but for now you only need to know that when you see a <code>!</code> that means that you’re calling a macro instead of a normal function.</p>
<p id = "para-35">Next is <code>“Hello, world!”</code> which is a <em>string</em>. Strings are a surprisingly complicated topic in a systems programming language, and this is a <em><a href = "#chapter-46">statically allocated</a></em> string. We pass this string as an argument to <code>println!</code>, which prints the string to the screen. Easy enough!</p>
<p id = "para-36">The line ends with a semicolon (<code>;</code>). Rust is an <em><a href = "#chapter-60">expression-oriented language</a></em>, which means that most things are expressions, rather than statements. The <code>;</code> indicates that this expression is over, and the next one is ready to begin. Most lines of Rust code end with a <code>;</code>.</p>
<h2 id = "link-14">Compiling and Running Are Separate Steps</h2>
<p id = "para-37">In “Writing and Running a Rust Program”, we showed you how to run a newly created program. We’ll break that process down and examine each step now.</p>
<p id = "para-38">Before running a Rust program, you have to compile it. You can use the Rust compiler by entering the <code>rustc</code> command and passing it the name of your source file, like this:</p>
<pre><span style="color:#323232;">$ rustc main.rs
</span></pre><p id = "para-39">If you come from a C or C++ background, you’ll notice that this is similar to <code>gcc</code> or <code>clang</code>. After compiling successfully, Rust should output a binary executable, which you can see on Linux or macOS by entering the <code>ls</code> command in your shell as follows:</p>
<pre><span style="color:#323232;">$ ls
main  main.rs
</span></pre><p id = "para-40">On Windows, you’d enter:</p>
<pre><span style="color:#323232;">$ dir
main.exe
main.rs
</span></pre><p id = "para-41">This shows we have two files: the source code, with an <code>.rs</code> extension, and the executable (<code>main.exe</code> on Windows, <code>main</code> everywhere else). All that’s left to do from here is run the <code>main</code> or <code>main.exe</code> file, like this:</p>
<pre><span style="color:#323232;">$ ./main  </span><span style="font-style:italic;color:#969896;"># or .\main.exe on Windows
</span></pre><p id = "para-42">If <em>main.rs</em> were your “Hello, world!” program, this would print <code>Hello, world!</code> to your terminal.</p>
<p id = "para-43">If you come from a dynamic language like Ruby, Python, or JavaScript, you may not be used to compiling and running a program being separate steps. Rust is an <em>ahead-of-time compiled</em> language, which means that you can compile a program, give it to someone else, and they can run it even without Rust installed. If you give someone a <code>.rb</code> or <code>.py</code> or <code>.js</code> file, on the other hand, they need to have a Ruby, Python, or JavaScript implementation installed (respectively), but you only need one command to both compile and run your program. Everything is a tradeoff in language design.</p>
<p id = "para-44">Just compiling with <code>rustc</code> is fine for simple programs, but as your project grows, you’ll want to be able to manage all of the options your project has, and make it easy to share your code with other people and projects. Next, I’ll introduce you to a tool called Cargo, which will help you write real-world Rust programs.</p>
<h1 id = 'link-15'><span class = 'chapter-header'>Chapter 4</span><br />Hello, Cargo!</h1><p id = "para-45">Cargo is Rust’s build system and package manager, and Rustaceans use Cargo to manage their Rust projects. Cargo manages three things: building your code, downloading the libraries your code depends on, and building those libraries. We call libraries your code needs ‘dependencies’ since your code depends on them.</p>
<p id = "para-46">The simplest Rust programs don’t have any dependencies, so right now, you’d only use the first part of its functionality. As you write more complex Rust programs, you’ll want to add dependencies, and if you start off using Cargo, that will be a lot easier to do.</p>
<p id = "para-47">As the vast, vast majority of Rust projects use Cargo, we will assume that you’re using it for the rest of the book. Cargo comes installed with Rust itself, if you used the official installers. If you installed Rust through some other means, you can check if you have Cargo installed by typing:</p>
<pre><span style="color:#323232;">$ cargo --version
</span></pre><p id = "para-48">Into a terminal. If you see a version number, great! If you see an error like ‘<code>command not found</code>’, then you should look at the documentation for the system in which you installed Rust, to determine if Cargo is separate.</p>
<h2 id = "link-16">Converting to Cargo</h2>
<p id = "para-49">Let’s convert the Hello World program to Cargo. To Cargo-fy a project, you need to do three things:</p>
<ol>
<li>Put your source file in the right directory.</li>
<li>Get rid of the old executable (<code>main.exe</code> on Windows, <code>main</code> everywhere else).</li>
<li>Make a Cargo configuration file.</li>
</ol>
<p id = "para-50">Let’s get started!</p>
<h3 id = "link-17">Creating a Source Directory and Removing the Old Executable</h3>
<p id = "para-51">First, go back to your terminal, move to your <em>hello_world</em> directory, and enter the following commands:</p>
<pre><span style="color:#323232;">$ mkdir src
$ mv main.rs src/main.rs </span><span style="font-style:italic;color:#969896;"># or &#39;move main.rs src/main.rs&#39; on Windows
</span><span style="color:#323232;">$ rm main  </span><span style="font-style:italic;color:#969896;"># or &#39;del main.exe&#39; on Windows
</span></pre><p id = "para-52">Cargo expects your source files to live inside a <em>src</em> directory, so do that first. This leaves the top-level project directory (in this case, <em>hello_world</em>) for READMEs, license information, and anything else not related to your code. In this way, using Cargo helps you keep your projects nice and tidy. There’s a place for everything, and everything is in its place.</p>
<p id = "para-53">Now, move <em>main.rs</em> into the <em>src</em> directory, and delete the compiled file you created with <code>rustc</code>. As usual, replace <code>main</code> with <code>main.exe</code> if you’re on Windows.</p>
<p id = "para-54">This example retains <code>main.rs</code> as the source filename because it’s creating an executable. If you wanted to make a library instead, you’d name the file <code>lib.rs</code>. This convention is used by Cargo to successfully compile your projects, but it can be overridden if you wish.</p>
<h3 id = "link-18">Creating a Configuration File</h3>
<p id = "para-55">Next, create a new file inside your <em>hello_world</em> directory, and call it <code>Cargo.toml</code>.</p>
<p id = "para-56">Make sure to capitalize the <code>C</code> in <code>Cargo.toml</code>, or Cargo won’t know what to do with the configuration file.</p>
<p id = "para-57">This file is in the <em><a href = "https://github.com/toml-lang/toml">TOML</a></em> (Tom’s Obvious, Minimal Language) format. TOML is similar to INI, but has some extra goodies, and is used as Cargo’s configuration format.</p>
<p id = "para-58">Inside this file, type the following information:</p>
<pre><span style="color:#323232;">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</span></pre><p id = "para-59">The first line, <code>[package]</code>, indicates that the following statements are configuring a package. As we add more information to this file, we’ll add other sections, but for now, we only have the package configuration.</p>
<p id = "para-60">The other three lines set the three bits of configuration that Cargo needs to know to compile your program: its name, what version it is, and who wrote it.</p>
<p id = "para-61">Once you’ve added this information to the <em>Cargo.toml</em> file, save it to finish creating the configuration file.</p>
<h2 id = "link-19">Building and Running a Cargo Project</h2>
<p id = "para-62">With your <em>Cargo.toml</em> file in place in your project’s root directory, you should be ready to build and run your Hello World program! To do so, enter the following commands:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Hello, world!
</span></pre><p id = "para-63">Bam! If all goes well, <code>Hello, world!</code> should print to the terminal once more.</p>
<p id = "para-64">You just built a project with <code>cargo build</code> and ran it with <code>./target/debug/hello_world</code>, but you can actually do both in one step with <code>cargo run</code> as follows:</p>
<pre><span style="color:#323232;">$ cargo run
     Running `target/debug/hello_world`
Hello, world!
</span></pre><p id = "para-65">The <code>run</code> command comes in handy when you need to rapidly iterate on a project.</p>
<p id = "para-66">Notice that this example didn’t re-build the project. Cargo figured out that the file hasn’t changed, and so it just ran the binary. If you’d modified your source code, Cargo would have rebuilt the project before running it, and you would have seen something like this:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</span></pre><p id = "para-67">Cargo checks to see if any of your project’s files have been modified, and only rebuilds your project if they’ve changed since the last time you built it.</p>
<p id = "para-68">With simple projects, Cargo doesn’t bring a whole lot over just using <code>rustc</code>, but it will become useful in the future. This is especially true when you start using crates; these are synonymous with a ‘library’ or ‘package’ in other programming languages. For complex projects composed of multiple crates, it’s much easier to let Cargo coordinate the build. Using Cargo, you can run <code>cargo build</code>, and it should work the right way.</p>
<h3 id = "link-20">Building for Release</h3>
<p id = "para-69">When your project is ready for release, you can use <code>cargo build --release</code> to compile your project with optimizations. These optimizations make your Rust code run faster, but turning them on makes your program take longer to compile. This is why there are two different profiles, one for development, and one for building the final program you’ll give to a user.</p>
<h3 id = "link-21">What Is That <code>Cargo.lock</code>?</h3>
<p id = "para-70">Running <code>cargo build</code> also causes Cargo to create a new file called <em>Cargo.lock</em>, which looks like this:</p>
<pre><span style="color:#323232;">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</span></pre><p id = "para-71">Cargo uses the <em>Cargo.lock</em> file to keep track of dependencies in your application. This is the Hello World project’s <em>Cargo.lock</em> file. This project doesn’t have dependencies, so the file is a bit sparse. Realistically, you won’t ever need to touch this file yourself; just let Cargo handle it.</p>
<p id = "para-72">That’s it! If you’ve been following along, you should have successfully built <code>hello_world</code> with Cargo.</p>
<p id = "para-73">Even though the project is simple, it now uses much of the real tooling you’ll use for the rest of your Rust career. In fact, you can expect to start virtually all Rust projects with some variation on the following commands:</p>
<pre><span style="color:#323232;">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</span></pre><h2 id = "link-22">Making A New Cargo Project the Easy Way</h2>
<p id = "para-74">You don’t have to go through that previous process every time you want to start a new project! Cargo can quickly make a bare-bones project directory that you can start developing in right away.</p>
<p id = "para-75">To start a new project with Cargo, enter <code>cargo new</code> at the command line:</p>
<pre><span style="color:#323232;">$ cargo new hello_world --bin
</span></pre><p id = "para-76">This command passes <code>--bin</code> because the goal is to get straight to making an executable application, as opposed to a library. Executables are often called <em>binaries</em> (as in <code>/usr/bin</code>, if you’re on a Unix system).</p>
<p id = "para-77">Cargo has generated two files and one directory for us: a <code>Cargo.toml</code> and a <em>src</em> directory with a <em>main.rs</em> file inside. These should look familiar, they’re exactly what we created by hand, above.</p>
<p id = "para-78">This output is all you need to get started. First, open <code>Cargo.toml</code>. It should look something like this:</p>
<pre><span style="color:#323232;">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

[dependencies]
</span></pre><p id = "para-79">Do not worry about the <code>[dependencies]</code> line, we will come back to it later.</p>
<p id = "para-80">Cargo has populated <em>Cargo.toml</em> with reasonable defaults based on the arguments you gave it and your <code>git</code> global configuration. You may notice that Cargo has also initialized the <code>hello_world</code> directory as a <code>git</code> repository.</p>
<p id = "para-81">Here’s what should be in <code>src/main.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello, world!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-82">Cargo has generated a “Hello World!” for you, and you’re ready to start coding!</p>
<blockquote><p id = "para-83">Note: If you want to look at Cargo in more detail, check out the official <a href = "http://doc.crates.io/guide.html">Cargo guide</a>, which covers all of its features.</p>
</blockquote>
<h1 id = 'link-23'><span class = 'chapter-header'>Chapter 5</span><br />Closing Thoughts</h1><p id = "para-84">This chapter covered the basics that will serve you well through the rest of this book, and the rest of your time with Rust. Now that you’ve got the tools down, we’ll cover more about the Rust language itself.</p>
<p id = "para-85">You have two options: Dive into a project with ‘<a href = "#chapter-5">Tutorial: Guessing Game</a>’, or start from the bottom and work your way up with ‘<a href = "#chapter-7">Syntax and Semantics</a>’. More experienced systems programmers will probably prefer ‘Tutorial: Guessing Game’, while those from dynamic backgrounds may enjoy either. Different people learn differently! Choose whatever’s right for you.</p>

</div><div id = "chapter-4" class = "chapter">
  <h2 class = 'part'>Part III</h2> <h1 id = 'link-24' class = 'part'>Tutorial: Guessing Games</h1>
</div><div id = "chapter-5" class = "chapter">
  <h1 id = 'link-25'><span class = 'chapter-header'>Chapter 1</span><br />Guessing Game</h1><p id = "para-86">Let’s learn some Rust! For our first project, we’ll implement a classic beginner programming problem: the guessing game. Here’s how it works: Our program will generate a random integer between one and a hundred. It will then prompt us to enter a guess. Upon entering our guess, it will tell us if we’re too low or too high. Once we guess correctly, it will congratulate us. Sounds good?</p>
<p id = "para-87">Along the way, we’ll learn a little bit about Rust. The next chapter, ‘Syntax and Semantics’, will dive deeper into each part.</p>
<h1 id = 'link-26'><span class = 'chapter-header'>Chapter 2</span><br />Set up</h1><p id = "para-88">Let’s set up a new project. Go to your projects directory. Remember how we had to create our directory structure and a <code>Cargo.toml</code> for <code>hello_world</code>? Cargo has a command that does that for us. Let’s give it a shot:</p>
<pre><span style="color:#323232;">$ cd ~/projects
$ cargo new guessing_game --bin
     Created binary (application) `guessing_game` project
$ cd guessing_game
</span></pre><p id = "para-89">We pass the name of our project to <code>cargo new</code>, and then the <code>--bin</code> flag, since we’re making a binary, rather than a library.</p>
<p id = "para-90">Check out the generated <code>Cargo.toml</code>:</p>
<pre><span style="color:#323232;">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</span></pre><p id = "para-91">Cargo gets this information from your environment. If it’s not correct, go ahead and fix that.</p>
<p id = "para-92">Finally, Cargo generated a ‘Hello, world!’ for us. Check out <code>src/main.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello, world!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-93">Let’s try compiling what Cargo gave us:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug [unoptimized + debuginfo] target(s) in 0.53 secs
</span></pre><p id = "para-94">Excellent! Open up your <code>src/main.rs</code> again. We’ll be writing all of our code in this file.</p>
<p id = "para-95">Remember the <code>run</code> command from last chapter? Try it out again here:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.0 secs
     Running `target/debug/guessing_game`
Hello, world!
</span></pre><p id = "para-96">Great! Our game is just the kind of project <code>run</code> is good for: we need to quickly test each iteration before moving on to the next one.</p>
<h1 id = 'link-27'><span class = 'chapter-header'>Chapter 3</span><br />Processing a Guess</h1><p id = "para-97">Let’s get to it! The first thing we need to do for our guessing game is allow our player to input a guess. Put this in your <code>src/main.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);
}
</span></pre><p id = "para-98">There’s a lot here! Let’s go over it, bit by bit.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span></pre><p id = "para-99">We’ll need to take user input, and then print the result as output. As such, we need the <code>io</code> library from the standard library. Rust only imports a few things by default into every program, <a href = "src/../../std/prelude/index.html">the ‘prelude’</a>. If it’s not in the prelude, you’ll have to <code>use</code> it directly. There is also a second ‘prelude’, the <a href = "src/../../std/io/prelude/index.html"><code>io</code> prelude</a>, which serves a similar function: you import it, and it imports a number of useful, <code>io</code>-related things.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span></pre><p id = "para-100">As you’ve seen before, the <code>main()</code> function is the entry point into your program. The <code>fn</code> syntax declares a new function, the <code>()</code>s indicate that there are no arguments, and <code>{</code> starts the body of the function. Because we didn’t include a return type, it’s assumed to be <code>()</code>, an empty <a href = "#chapter-10">tuple</a>.</p>
<pre><span style="color:#323232;">    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-101">We previously learned that <code>println!()</code> is a <a href = "#chapter-41">macro</a> that prints a <a href = "#chapter-24">string</a> to the screen.</p>
<pre><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
</span></pre><p id = "para-102">Now we’re getting interesting! There’s a lot going on in this little line. The first thing to notice is that this is a <a href = "#chapter-8">let statement</a>, which is used to create ‘variable bindings’. They take this form:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> foo </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> bar;
</span></pre><p id = "para-103">This will create a new binding named <code>foo</code>, and bind it to the value <code>bar</code>. In many languages, this is called a ‘variable’, but Rust’s variable bindings have a few tricks up their sleeves.</p>
<p id = "para-104">For example, they’re <a href = "#chapter-18">immutable</a> by default. That’s why our example uses <code>mut</code>: it makes a binding mutable, rather than immutable. <code>let</code> doesn’t take a name on the left hand side of the assignment, it actually accepts a ‘<a href = "#chapter-22">pattern</a>’. We’ll use patterns later. It’s easy enough to use for now:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> foo </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `foo` is immutable.
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> bar </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `bar` is mutable.
</span></pre><p id = "para-105">Oh, and <code>//</code> will start a comment, until the end of the line. Rust ignores everything in <a href = "#chapter-11">comments</a>.</p>
<p id = "para-106">So now we know that <code>let mut guess</code> will introduce a mutable binding named <code>guess</code>, but we have to look at the other side of the <code>=</code> for what it’s bound to: <code>String::new()</code>.</p>
<p id = "para-107"><code>String</code> is a string type, provided by the standard library. A <a href = "src/../../std/string/struct.String.html"><code>String</code></a> is a growable, UTF-8 encoded bit of text.</p>
<p id = "para-108">The <code>::new()</code> syntax uses <code>::</code> because this is an ‘associated function’ of a particular type. That is to say, it’s associated with <code>String</code> itself, rather than a particular instance of a <code>String</code>. Some languages call this a ‘static method’.</p>
<p id = "para-109">This function is named <code>new()</code>, because it creates a new, empty <code>String</code>. You’ll find a <code>new()</code> function on many types, as it’s a common name for making a new value of some kind.</p>
<p id = "para-110">Let’s move forward:</p>
<pre><span style="color:#323232;">    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-111">That’s a lot more! Let’s go bit-by-bit. The first line has two parts. Here’s the first:</p>
<pre><span style="color:#323232;">io::stdin()
</span></pre><p id = "para-112">Remember how we <code>use</code>d <code>std::io</code> on the first line of the program? We’re now calling an associated function on it. If we didn’t <code>use std::io</code>, we could have written this line as <code>std::io::stdin()</code>.</p>
<p id = "para-113">This particular function returns a handle to the standard input for your terminal. More specifically, a <a href = "src/../../std/io/struct.Stdin.html">std::io::Stdin</a>.</p>
<p id = "para-114">The next part will use this handle to get input from the user:</p>
<pre><span style="color:#323232;">.</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
</span></pre><p id = "para-115">Here, we call the <a href = "src/../../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a> method on our handle. <a href = "#chapter-23">Methods</a> are like associated functions, but are only available on a particular instance of a type, rather than the type itself. We’re also passing one argument to <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
<p id = "para-116">Remember how we bound <code>guess</code> above? We said it was mutable. However, <code>read_line</code> doesn’t take a <code>String</code> as an argument: it takes a <code>&amp;mut String</code>. Rust has a feature called ‘<a href = "#chapter-16">references</a>’, which allows you to have multiple references to one piece of data, which can reduce copying. References are a complex feature, as one of Rust’s major selling points is how safe and easy it is to use references. We don’t need to know a lot of those details to finish our program right now, though. For now, all we need to know is that like <code>let</code> bindings, references are immutable by default. Hence, we need to write <code>&amp;mut guess</code>, rather than <code>&amp;guess</code>.</p>
<p id = "para-117">Why does <code>read_line()</code> take a mutable reference to a string? Its job is to take what the user types into standard input, and place that into a string. So it takes that string as an argument, and in order to add the input, it needs to be mutable.</p>
<p id = "para-118">But we’re not quite done with this line of code, though. While it’s a single line of text, it’s only the first part of the single logical line of code:</p>
<pre><span style="color:#323232;">        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-119">When you call a method with the <code>.foo()</code> syntax, you may introduce a newline and other whitespace. This helps you split up long lines. We <em>could</em> have done:</p>
<pre><span style="color:#323232;">    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess).</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-120">But that gets hard to read. So we’ve split it up, two lines for two method calls. We already talked about <code>read_line()</code>, but what about <code>expect()</code>? Well, we already mentioned that <code>read_line()</code> puts what the user types into the <code>&amp;mut String</code> we pass it. But it also returns a value: in this case, an <a href = "src/../../std/io/type.Result.html"><code>io::Result</code></a>. Rust has a number of types named <code>Result</code> in its standard library: a generic <a href = "src/../../std/result/enum.Result.html"><code>Result</code></a>, and then specific versions for sub-libraries, like <code>io::Result</code>.</p>
<p id = "para-121">The purpose of these <code>Result</code> types is to encode error handling information. Values of the <code>Result</code> type, like any type, have methods defined on them. In this case, <code>io::Result</code> has an <a href = "src/../../std/result/enum.Result.html#method.expect"><code>expect()</code> method</a> that takes a value it’s called on, and if it isn’t a successful one, <a href = "#chapter-52"><code>panic!</code></a>s with a message you passed it. A <code>panic!</code> like this will cause our program to crash, displaying the message.</p>
<p id = "para-122">If we do not call <code>expect()</code>, our program will compile, but we’ll get a warning:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
warning: unused result which must be used, </span><span style="font-style:italic;color:#969896;">#[warn(unused_must_use)] on by default
  </span><span style="color:#323232;">--</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> src/main.rs:10:5
   </span><span style="font-weight:bold;color:#a71d5d;">|
</span><span style="color:#323232;">10 </span><span style="font-weight:bold;color:#a71d5d;">|     </span><span style="font-weight:bold;color:#795da3;">io::stdin</span><span style="color:#323232;">().read_line(&amp;mut guess);
   |     ^

    Finished debug [unoptimized + debuginfo] target(s) in 0.42 secs
</span></pre><p id = "para-123">Rust warns us that we haven’t used the <code>Result</code> value. This warning comes from a special annotation that <code>io::Result</code> has. Rust is trying to tell you that you haven’t handled a possible error. The right way to suppress the error is to actually write error handling. Luckily, if we want to crash if there’s a problem, we can use <code>expect()</code>. If we can recover from the error somehow, we’d do something else, but we’ll save that for a future project.</p>
<p id = "para-124">There’s only one line of this first example left:</p>
<pre><span style="color:#323232;">    println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);
}
</span></pre><p id = "para-125">This prints out the string we saved our input in. The <code>{}</code>s are a placeholder, and so we pass it <code>guess</code> as an argument. If we had multiple <code>{}</code>s, we would pass multiple arguments:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;

println!(</span><span style="color:#183691;">&quot;x and y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> and </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y);
</span></pre><p id = "para-126">Easy.</p>
<p id = "para-127">Anyway, that’s the tour. We can run what we have with <code>cargo run</code>:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.44 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</span></pre><p id = "para-128">All right! Our first part is done: we can get input from the keyboard, and then print it back out.</p>
<h1 id = 'link-28'><span class = 'chapter-header'>Chapter 4</span><br />Generating a secret number</h1><p id = "para-129">Next, we need to generate a secret number. Rust does not yet include random number functionality in its standard library. The Rust team does, however, provide a <a href = "https://crates.io/crates/rand"><code>rand</code> crate</a>. A ‘crate’ is a package of Rust code. We’ve been building a ‘binary crate’, which is an executable. <code>rand</code> is a ‘library crate’, which contains code that’s intended to be used with other programs.</p>
<p id = "para-130">Using external crates is where Cargo really shines. Before we can write the code using <code>rand</code>, we need to modify our <code>Cargo.toml</code>. Open it up, and add these few lines at the bottom:</p>
<pre><span style="color:#323232;">[dependencies]

rand = &quot;0.3.0&quot;
</span></pre><p id = "para-131">The <code>[dependencies]</code> section of <code>Cargo.toml</code> is like the <code>[package]</code> section: everything that follows it is part of it, until the next section starts. Cargo uses the dependencies section to know what dependencies on external crates you have, and what versions you require. In this case, we’ve specified version <code>0.3.0</code>, which Cargo understands to be any release that’s compatible with this specific version. Cargo understands <a href = "http://semver.org">Semantic Versioning</a>, which is a standard for writing version numbers. A bare number like above is actually shorthand for <code>^0.3.0</code>, meaning “anything compatible with 0.3.0”. If we wanted to use only <code>0.3.0</code> exactly, we could say <code>rand = “=0.3.0”</code> (note the two equal signs). We could also use a range of versions. <a href = "http://doc.crates.io/specifying-dependencies.html">Cargo’s documentation</a> contains more details.</p>
<p id = "para-132">Now, without changing any of our code, let’s build our project:</p>
<pre><span style="color:#323232;">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.17
   Compiling libc v0.2.17
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 5.88 secs
</span></pre><p id = "para-133">(You may see different versions, of course.)</p>
<p id = "para-134">Lots of new output! Now that we have an external dependency, Cargo fetches the latest versions of everything from the registry, which is a copy of data from <a href = "https://crates.io">Crates.io</a>. Crates.io is where people in the Rust ecosystem post their open source Rust projects for others to use.</p>
<p id = "para-135">After updating the registry, Cargo checks our <code>[dependencies]</code> and downloads any we don’t have yet. In this case, while we only said we wanted to depend on <code>rand</code>, we’ve also grabbed a copy of <code>libc</code>. This is because <code>rand</code> depends on <code>libc</code> to work. After downloading them, it compiles them, and then compiles our project.</p>
<p id = "para-136">If we run <code>cargo build</code> again, we’ll get different output:</p>
<pre><span style="color:#323232;">$ cargo build
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.0 secs
</span></pre><p id = "para-137">That’s right, nothing was done! Cargo knows that our project has been built, and that all of its dependencies are built, and so there’s no reason to do all that stuff. With nothing to do, it simply exits. If we open up <code>src/main.rs</code> again, make a trivial change, and then save it again, we’ll only see two lines:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.45 secs
</span></pre><p id = "para-138">So, we told Cargo we wanted any <code>0.3.x</code> version of <code>rand</code>, and so it fetched the latest version at the time this was written, <code>v0.3.14</code>. But what happens when next week, version <code>v0.3.15</code> comes out, with an important bugfix? While getting bugfixes is important, what if <code>0.3.15</code> contains a regression that breaks our code?</p>
<p id = "para-139">The answer to this problem is the <code>Cargo.lock</code> file you’ll now find in your project directory. When you build your project for the first time, Cargo figures out all of the versions that fit your criteria, and then writes them to the <code>Cargo.lock</code> file. When you build your project in the future, Cargo will see that the <code>Cargo.lock</code> file exists, and then use that specific version rather than do all the work of figuring out versions again. This lets you have a repeatable build automatically. In other words, we’ll stay at <code>0.3.14</code> until we explicitly upgrade, and so will anyone who we share our code with, thanks to the lock file.</p>
<p id = "para-140">What about when we <em>do</em> want to use <code>v0.3.15</code>? Cargo has another command, <code>update</code>, which says ‘ignore the lock, figure out all the latest versions that fit what we’ve specified. If that works, write those versions out to the lock file’. But, by default, Cargo will only look for versions larger than <code>0.3.0</code> and smaller than <code>0.4.0</code>. If we want to move to <code>0.4.x</code>, we’d have to update the <code>Cargo.toml</code> directly. When we do, the next time we <code>cargo build</code>, Cargo will update the index and re-evaluate our <code>rand</code> requirements.</p>
<p id = "para-141">There’s a lot more to say about <a href = "http://doc.crates.io">Cargo</a> and <a href = "http://doc.crates.io/crates-io.html">its ecosystem</a>, but for now, that’s all we need to know. Cargo makes it really easy to re-use libraries, and so Rustaceans tend to write smaller projects which are assembled out of a number of sub-packages.</p>
<p id = "para-142">Let’s get on to actually <em>using</em> <code>rand</code>. Here’s our next step:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);
}
</span></pre><p id = "para-143">The first thing we’ve done is change the first line. It now says <code>extern crate rand</code>. Because we declared <code>rand</code> in our <code>[dependencies]</code>, we can use <code>extern crate</code> to let Rust know we’ll be making use of it. This also does the equivalent of a <code>use rand;</code> as well, so we can make use of anything in the <code>rand</code> crate by prefixing it with <code>rand::</code>.</p>
<p id = "para-144">Next, we added another <code>use</code> line: <code>use rand::Rng</code>. We’re going to use a method in a moment, and it requires that <code>Rng</code> be in scope to work. The basic idea is this: methods are defined on something called ‘traits’, and for the method to work, it needs the trait to be in scope. For more about the details, read the <a href = "#chapter-26">traits</a> section.</p>
<p id = "para-145">There are two other lines we added, in the middle:</p>
<pre><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);
</span></pre><p id = "para-146">We use the <code>rand::thread_rng()</code> function to get a copy of the random number generator, which is local to the particular <a href = "#chapter-51">thread</a> of execution we’re in. Because we <code>use rand::Rng</code>’d above, it has a <code>gen_range()</code> method available. This method takes two arguments, and generates a number between them. It’s inclusive on the lower bound, but exclusive on the upper bound, so we need <code>1</code> and <code>101</code> to get a number ranging from one to a hundred.</p>
<p id = "para-147">The second line prints out the secret number. This is useful while we’re developing our program, so we can easily test it out. But we’ll be deleting it for the final version. It’s not much of a game if it prints out the answer when you start it up!</p>
<p id = "para-148">Try running our new program a few times:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.55 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.0 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</span></pre><p id = "para-149">Great! Next up: comparing our guess to the secret number.</p>
<h1 id = 'link-29'><span class = 'chapter-header'>Chapter 5</span><br />Comparing guesses</h1><p id = "para-150">Now that we’ve got user input, let’s compare our guess to the secret number. Here’s our next step, though it doesn’t quite compile yet:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
        Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
        Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
        Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">),
    }
}
</span></pre><p id = "para-151">A few new bits here. The first is another <code>use</code>. We bring a type called <code>std::cmp::Ordering</code> into scope. Then, five new lines at the bottom that use it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
    Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
    Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
    Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-152">The <code>cmp()</code> method can be called on anything that can be compared, and it takes a reference to the thing you want to compare it to. It returns the <code>Ordering</code> type we <code>use</code>d earlier. We use a <a href = "#chapter-21"><code>match</code></a> statement to determine exactly what kind of <code>Ordering</code> it is. <code>Ordering</code> is an <a href = "#chapter-20"><code>enum</code></a>, short for ‘enumeration’, which looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Foo {
    Bar,
    Baz,
}
</span></pre><p id = "para-153">With this definition, anything of type <code>Foo</code> can be either a <code>Foo::Bar</code> or a <code>Foo::Baz</code>. We use the <code>::</code> to indicate the namespace for a particular <code>enum</code> variant.</p>
<p id = "para-154">The <a href = "src/../../std/cmp/enum.Ordering.html"><code>Ordering</code></a> <code>enum</code> has three possible variants: <code>Less</code>, <code>Equal</code>, and <code>Greater</code>. The <code>match</code> statement takes a value of a type, and lets you create an ‘arm’ for each possible value. Since we have three types of <code>Ordering</code>, we have three arms:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
    Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
    Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
    Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-155">If it’s <code>Less</code>, we print <code>Too small!</code>, if it’s <code>Greater</code>, <code>Too big!</code>, and if <code>Equal</code>, <code>You win!</code>. <code>match</code> is really useful, and is used often in Rust.</p>
<p id = "para-156">I did mention that this won’t quite compile yet, though. Let’s try it:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
error[E0308]: mismatched types
  --</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> src/main.rs:23:21
   </span><span style="font-weight:bold;color:#a71d5d;">|
</span><span style="color:#323232;">23 </span><span style="font-weight:bold;color:#a71d5d;">|     </span><span style="color:#323232;">match guess.cmp(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
   </span><span style="font-weight:bold;color:#a71d5d;">|                     </span><span style="color:#323232;">^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   </span><span style="font-weight:bold;color:#a71d5d;">|
   = </span><span style="color:#323232;">note: expected type `</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">std::string::String`
   </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">note:    found type `</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">{integer}`

error: aborting due to previous error

error: Could not compile `guessing_game`.

To learn more, run the command again with --verbose.
</span></pre><p id = "para-157">Whew! This is a big error. The core of it is that we have ‘mismatched types’. Rust has a strong, static type system. However, it also has type inference. When we wrote <code>let guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be a <code>String</code>, and so it doesn’t make us write out the type. And with our <code>secret_number</code>, there are a number of types which can have a value between one and a hundred: <code>i32</code>, a thirty-two-bit number, or <code>u32</code>, an unsigned thirty-two-bit number, or <code>i64</code>, a sixty-four-bit number or others. So far, that hasn’t mattered, and so Rust defaults to an <code>i32</code>. However, here, Rust doesn’t know how to compare the <code>guess</code> and the <code>secret_number</code>. They need to be the same type. Ultimately, we want to convert the <code>String</code> we read as input into a real number type, for comparison. We can do that with two more lines. Here’s our new program:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

    io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 =</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">()
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Please type a number!&quot;</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
        Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
        Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
        Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">),
    }
}
</span></pre><p id = "para-158">The new two lines:</p>
<pre><span style="color:#323232;">    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 =</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">()
        .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Please type a number!&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-159">Wait a minute, I thought we already had a <code>guess</code>? We do, but Rust allows us to ‘shadow’ the previous <code>guess</code> with a new one. This is often used in this exact situation, where <code>guess</code> starts as a <code>String</code>, but we want to convert it to an <code>u32</code>. Shadowing lets us re-use the <code>guess</code> name, rather than forcing us to come up with two unique names like <code>guess_str</code> and <code>guess</code>, or something else.</p>
<p id = "para-160">We bind <code>guess</code> to an expression that looks like something we wrote earlier:</p>
<pre><span style="color:#323232;">guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">()
</span></pre><p id = "para-161">Here, <code>guess</code> refers to the old <code>guess</code>, the one that was a <code>String</code> with our input in it. The <code>trim()</code> method on <code>String</code>s will eliminate any white space at the beginning and end of our string. This is important, as we had to press the ‘return’ key to satisfy <code>read_line()</code>. This means that if we type <code>5</code> and hit return, <code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents ‘newline’, the enter key. <code>trim()</code> gets rid of this, leaving our string with only the <code>5</code>. The <a href = "src/../../std/primitive.str.html#method.parse"><code>parse()</code> method on strings</a> parses a string into some kind of number. Since it can parse a variety of numbers, we need to give Rust a hint as to the exact type of number we want. Hence, <code>let guess: u32</code>. The colon (<code>:</code>) after <code>guess</code> tells Rust we’re going to annotate its type. <code>u32</code> is an unsigned, thirty-two bit integer. Rust has <a href = "#chapter-10">a number of built-in number types</a>, but we’ve chosen <code>u32</code>. It’s a good default choice for a small positive number.</p>
<p id = "para-162">Just like <code>read_line()</code>, our call to <code>parse()</code> could cause an error. What if our string contained <code>A👍%</code>? There’d be no way to convert that to a number. As such, we’ll do the same thing we did with <code>read_line()</code>: use the <code>expect()</code> method to crash if there’s an error.</p>
<p id = "para-163">Let’s try our program out!</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.57 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</span></pre><p id = "para-164">Nice! You can see I even added spaces before my guess, and it still figured out that I guessed 76. Run the program a few times, and verify that guessing the number works, as well as guessing a number too small.</p>
<p id = "para-165">Now we’ve got most of the game working, but we can only make one guess. Let’s change that by adding loops!</p>
<h1 id = 'link-30'><span class = 'chapter-header'>Chapter 6</span><br />Looping</h1><p id = "para-166">The <code>loop</code> keyword gives us an infinite loop. Let’s add that in:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

        io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 =</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">()
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Please type a number!&quot;</span><span style="color:#323232;">);

        println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
            Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
            Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
            Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">),
        }
    }
}
</span></pre><p id = "para-167">And try it out. But wait, didn’t we just add an infinite loop? Yup. Remember our discussion about <code>parse()</code>? If we give a non-number answer, we’ll <code>panic!</code> and quit. Observe:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.58 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread </span><span style="color:#183691;">&#39;main&#39;</span><span style="color:#323232;"> panicked at </span><span style="color:#183691;">&#39;Please type a number!&#39;
</span></pre><p id = "para-168">Ha! <code>quit</code> actually quits. As does any other non-number input. Well, this is suboptimal to say the least. First, let’s actually quit when you win the game:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

        io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 =</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">()
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Please type a number!&quot;</span><span style="color:#323232;">);

        println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
            Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
            Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
            Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
                println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">);
                </span><span style="font-weight:bold;color:#a71d5d;">break</span><span style="color:#323232;">;
            }
        }
    }
}
</span></pre><p id = "para-169">By adding the <code>break</code> line after the <code>You win!</code>, we’ll exit the loop when we win. Exiting the loop also means exiting the program, since it’s the last thing in <code>main()</code>. We have only one more tweak to make: when someone inputs a non-number, we don’t want to quit, we want to ignore it. We can do that like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    println!(</span><span style="color:#183691;">&quot;The secret number is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, secret_number);

    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

        io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 = match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">() {
            </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(num) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> num,
            </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; continue</span><span style="color:#323232;">,
        };

        println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
            Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
            Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
            Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
                println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">);
                </span><span style="font-weight:bold;color:#a71d5d;">break</span><span style="color:#323232;">;
            }
        }
    }
}
</span></pre><p id = "para-170">These are the lines that changed:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 = match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">() {
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(num) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> num,
    </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; continue</span><span style="color:#323232;">,
};
</span></pre><p id = "para-171">This is how you generally move from ‘crash on error’ to ‘actually handle the error’, by switching from <code>expect()</code> to a <code>match</code> statement. A <code>Result</code> is returned by <code>parse()</code>, this is an <code>enum</code> like <code>Ordering</code>, but in this case, each variant has some data associated with it: <code>Ok</code> is a success, and <code>Err</code> is a failure. Each contains more information: the successfully parsed integer, or an error type. In this case, we <code>match</code> on <code>Ok(num)</code>, which sets the name <code>num</code> to the unwrapped <code>Ok</code> value (the integer), and then we return it on the right-hand side. In the <code>Err</code> case, we don’t care what kind of error it is, so we just use the catch all <code>_</code> instead of a name. This catches everything that isn’t <code>Ok</code>, and <code>continue</code> lets us move to the next iteration of the loop; in effect, this enables us to ignore all errors and continue with our program.</p>
<p id = "para-172">Now we should be good! Let’s try:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.57 secs
     Running `target/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</span></pre><p id = "para-173">Awesome! With one tiny last tweak, we have finished the guessing game. Can you think of what it is? That’s right, we don’t want to print out the secret number. It was good for testing, but it kind of ruins the game. Here’s our final source:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rand;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cmp::Ordering;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">rand::Rng;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Guess the number!&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> secret_number </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">rand::thread_rng().</span><span style="color:#62a35c;">gen_range</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">101</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Please input your guess.&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> guess </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

        io::stdin().</span><span style="color:#62a35c;">read_line</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> guess)
            .</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Failed to read line&quot;</span><span style="color:#323232;">);

        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guess: </span><span style="font-weight:bold;color:#a71d5d;">u32 = match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">() {
            </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(num) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> num,
            </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; continue</span><span style="color:#323232;">,
        };

        println!(</span><span style="color:#183691;">&quot;You guessed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, guess);

        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> guess.</span><span style="color:#62a35c;">cmp</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">secret_number) {
            Ordering::Less    </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too small!&quot;</span><span style="color:#323232;">),
            Ordering::Greater </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Too big!&quot;</span><span style="color:#323232;">),
            Ordering::Equal   </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
                println!(</span><span style="color:#183691;">&quot;You win!&quot;</span><span style="color:#323232;">);
                </span><span style="font-weight:bold;color:#a71d5d;">break</span><span style="color:#323232;">;
            }
        }
    }
}
</span></pre><h1 id = 'link-31'><span class = 'chapter-header'>Chapter 7</span><br />Complete!</h1><p id = "para-174">This project showed you a lot: <code>let</code>, <code>match</code>, methods, associated functions, using external crates, and more.</p>
<p id = "para-175">At this point, you have successfully built the Guessing Game! Congratulations!</p>

</div><div id = "chapter-6" class = "chapter">
  <h2 class = 'part'>Part IV</h2> <h1 id = 'link-32' class = 'part'>Syntax and Semantics</h1>
</div><div id = "chapter-7" class = "chapter">
  <h1 id = 'link-33'><span class = 'chapter-header'>Chapter 1</span><br />Syntax and Semantics</h1><p id = "para-176">This chapter breaks Rust down into small chunks, one for each concept.</p>
<p id = "para-177">If you’d like to learn Rust from the bottom up, reading this in order is a great way to do that.</p>
<p id = "para-178">These sections also form a reference for each concept, so if you’re reading another tutorial and find something confusing, you can find it explained somewhere in here.</p>

</div><div id = "chapter-8" class = "chapter">
  <h2 id = "link-34">Variable Bindings</h2>
<p id = "para-179">Virtually every non-’Hello World’ Rust program uses <em>variable bindings</em>. They bind some value to a name, so it can be used later. <code>let</code> is used to introduce a binding, like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
}
</span></pre><p id = "para-180">Putting <code>fn main() {</code> in each example is a bit tedious, so we’ll leave that out in the future. If you’re following along, make sure to edit your <code>main()</code> function, rather than leaving it off. Otherwise, you’ll get an error.</p>
<h2 id = "link-35">Patterns</h2>
<p id = "para-181">In many languages, a variable binding would be called a <em>variable</em>, but Rust’s variable bindings have a few tricks up their sleeves. For example the left-hand side of a <code>let</code> statement is a ‘<a href = "#chapter-22">pattern</a>’, not a variable name. This means we can do things like:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(x, y) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">);
</span></pre><p id = "para-182">After this statement is evaluated, <code>x</code> will be one, and <code>y</code> will be two. Patterns are really powerful, and have <a href = "#chapter-22">their own section</a> in the book. We don’t need those features for now, so we’ll keep this in the back of our minds as we go forward.</p>
<h2 id = "link-36">Type annotations</h2>
<p id = "para-183">Rust is a statically typed language, which means that we specify our types up front, and they’re checked at compile time. So why does our first example compile? Well, Rust has this thing called ‘type inference’. If it can figure out what the type of something is, Rust doesn’t require you to explicitly type it out.</p>
<p id = "para-184">We can add the type if we want to, though. Types come after a colon (<code>:</code>):</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span></pre><p id = "para-185">If I asked you to read this out loud to the rest of the class, you’d say “<code>x</code> is a binding with the type <code>i32</code> and the value <code>5</code>.”</p>
<p id = "para-186">In this case we chose to represent <code>x</code> as a 32-bit signed integer. Rust has many different primitive integer types. They begin with <code>i</code> for signed integers and <code>u</code> for unsigned integers. The possible integer sizes are 8, 16, 32, and 64 bits.</p>
<p id = "para-187">In future examples, we may annotate the type in a comment. The examples will look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// x: i32
</span><span style="color:#323232;">}
</span></pre><p id = "para-188">Note the similarities between this annotation and the syntax you use with <code>let</code>. Including these kinds of comments is not idiomatic Rust, but we’ll occasionally include them to help you understand what the types that Rust infers are.</p>
<h2 id = "link-37">Mutability</h2>
<p id = "para-189">By default, bindings are <em>immutable</em>. This code will not compile:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;
</span></pre><p id = "para-190">It will give you this error:</p>
<pre><span style="color:#323232;">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</span></pre><p id = "para-191">If you want a binding to be mutable, you can use <code>mut</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// mut x: i32
</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;
</span></pre><p id = "para-192">There is no single reason that bindings are immutable by default, but we can think about it through one of Rust’s primary focuses: safety. If you forget to say <code>mut</code>, the compiler will catch it, and let you know that you have mutated something you may not have intended to mutate. If bindings were mutable by default, the compiler would not be able to tell you this. If you <em>did</em> intend mutation, then the solution is quite easy: add <code>mut</code>.</p>
<p id = "para-193">There are other good reasons to avoid mutable state when possible, but they’re out of the scope of this guide. In general, you can often avoid explicit mutation, and so it is preferable in Rust. That said, sometimes, mutation is what you need, so it’s not forbidden.</p>
<h2 id = "link-38">Initializing bindings</h2>
<p id = "para-194">Rust variable bindings have one more aspect that differs from other languages: bindings are required to be initialized with a value before you’re allowed to use them.</p>
<p id = "para-195">Let’s try it out. Change your <code>src/main.rs</code> file to look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;Hello world!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-196">You can use <code>cargo build</code> on the command line to build it. You’ll get a warning, but it will still print “Hello, world!”:</p>
<pre><span style="color:#323232;">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variables)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</span></pre><p id = "para-197">Rust warns us that we never use the variable binding, but since we never use it, no harm, no foul. Things change if we try to actually use this <code>x</code>, however. Let’s do that. Change your program to look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;The value of x is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-198">And try to build it. You’ll get an error:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;The value of x is: {}&quot;</span><span style="color:#323232;">, x)</span><span style="font-weight:bold;color:#a71d5d;">;
                                                    </span><span style="color:#323232;">^
note: in expansion of format_args!
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:2:23: 2:77 note: expansion site
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</span></pre><p id = "para-199">Rust will not let us use a value that has not been initialized.</p>
<p id = "para-200">Let us take a minute to talk about this stuff we’ve added to <code>println!</code>.</p>
<p id = "para-201">If you include two curly braces (<code>{}</code>, some call them moustaches...) in your string to print, Rust will interpret this as a request to interpolate some sort of value. <em>String interpolation</em> is a computer science term that means “stick in the middle of a string.” We add a comma, and then <code>x</code>, to indicate that we want <code>x</code> to be the value we’re interpolating. The comma is used to separate arguments we pass to functions and macros, if you’re passing more than one.</p>
<p id = "para-202">When you use the curly braces, Rust will attempt to display the value in a meaningful way by checking out its type. If you want to specify the format in a more detailed manner, there are a <a href = "src/../../std/fmt/index.html">wide number of options available</a>. For now, we’ll stick to the default: integers aren’t very complicated to print.</p>
<h2 id = "link-39">Scope and shadowing</h2>
<p id = "para-203">Let’s get back to bindings. Variable bindings have a scope - they are constrained to live in the block they were defined in. A block is a collection of statements enclosed by <code>{</code> and <code>}</code>. Function definitions are also blocks! In the following example we define two variable bindings, <code>x</code> and <code>y</code>, which live in different blocks. <code>x</code> can be accessed from inside the <code>fn main() {}</code> block, while <code>y</code> can be accessed only from inside the inner block:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">17</span><span style="color:#323232;">;
    {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;
        println!(</span><span style="color:#183691;">&quot;The value of x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> and value of y is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y);
    }
    println!(</span><span style="color:#183691;">&quot;The value of x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> and value of y is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y); </span><span style="font-style:italic;color:#969896;">// This won&#39;t work.
</span><span style="color:#323232;">}
</span></pre><p id = "para-204">The first <code>println!</code> would print “The value of x is 17 and the value of y is 3”, but this example cannot be compiled successfully, because the second <code>println!</code> cannot access the value of <code>y</code>, since it is not in scope anymore. Instead we get this error:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:7:62: 7:63 error: unresolved name `y`. Did you mean `x`</span><span style="font-weight:bold;color:#a71d5d;">? [</span><span style="color:#323232;">E0425</span><span style="font-weight:bold;color:#a71d5d;">]
</span><span style="color:#323232;">main.rs:7     println</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;The value of x is {} and value of y is {}&quot;</span><span style="color:#323232;">, x, y)</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">// This won</span><span style="color:#183691;">&#39;t work.
                                                                       ^
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:56 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
main.rs:7:5: 7:65 note: expansion site
main.rs:7:62: 7:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
</span></pre><p id = "para-205">Additionally, variable bindings can be shadowed. This means that a later variable binding with the same name as another binding that is currently in scope will override the previous binding.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">8</span><span style="color:#323232;">;
{
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// Prints &quot;8&quot;.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">12</span><span style="color:#323232;">;
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// Prints &quot;12&quot;.
</span><span style="color:#323232;">}
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// Prints &quot;8&quot;.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=  </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// Prints &quot;42&quot;.
</span></pre><p id = "para-206">Shadowing and mutable bindings may appear as two sides of the same coin, but they are two distinct concepts that can’t always be used interchangeably. For one, shadowing enables us to rebind a name to a value of a different type. It is also possible to change the mutability of a binding. Note that shadowing a name does not alter or destroy the value it was bound to, and the value will continue to exist until it goes out of scope, even if it is no longer accessible by any means.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">7</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x; </span><span style="font-style:italic;color:#969896;">// `x` is now immutable and is bound to `7`.

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">4</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;I can also be bound to text!&quot;</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `y` is now of a different type.
</span></pre>
</div><div id = "chapter-9" class = "chapter">
  <h2 id = "link-40">Functions</h2>
<p id = "para-207">Every Rust program has at least one function, the <code>main</code> function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
}
</span></pre><p id = "para-208">This is the simplest possible function declaration. As we mentioned before, <code>fn</code> says ‘this is a function’, followed by the name, some parentheses because this function takes no arguments, and then some curly braces to indicate the body. Here’s a function named <code>foo</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {
}
</span></pre><p id = "para-209">So, what about taking arguments? Here’s a function that prints a number:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_number</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;x is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-210">Here’s a complete program that uses <code>print_number</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="color:#62a35c;">print_number</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_number</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;x is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-211">As you can see, function arguments work very similar to <code>let</code> declarations: you add a type to the argument name, after a colon.</p>
<p id = "para-212">Here’s a complete program that adds two numbers together and prints them:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="color:#62a35c;">print_sum</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_sum</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;sum is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
}
</span></pre><p id = "para-213">You separate arguments with a comma, both when you call the function, as well as when you declare it.</p>
<p id = "para-214">Unlike <code>let</code>, you <em>must</em> declare the types of function arguments. This does not work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_sum</span><span style="color:#323232;">(x, y) {
    println!(</span><span style="color:#183691;">&quot;sum is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
}
</span></pre><p id = "para-215">You get this error:</p>
<pre><span style="color:#323232;">expected one of `!`, `:`, or `@`, found `)`
fn print_sum(x, y) {
</span></pre><p id = "para-216">This is a deliberate design decision. While full-program inference is possible, languages which have it, like Haskell, often suggest that documenting your types explicitly is a best-practice. We agree that forcing functions to declare types while allowing for inference inside of function bodies is a wonderful sweet spot between full inference and no inference.</p>
<p id = "para-217">What about returning a value? Here’s a function that adds one to an integer:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add_one</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}
</span></pre><p id = "para-218">Rust functions return exactly one value, and you declare the type after an ‘arrow’, which is a dash (<code>-</code>) followed by a greater-than sign (<code>&gt;</code>). The last line of a function determines what it returns. You’ll note the lack of a semicolon here. If we added it in:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add_one</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
}
</span></pre><p id = "para-219">We would get an error:</p>
<pre><span style="color:#323232;">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</span></pre><p id = "para-220">This reveals two interesting things about Rust: it is an expression-based language, and semicolons are different from semicolons in other ‘curly brace and semicolon’-based languages. These two things are related.</p>
<h3 id = "link-41">Expressions vs. Statements</h3>
<p id = "para-221">Rust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.</p>
<p id = "para-222">So what’s the difference? Expressions return a value, and statements do not. That’s why we end up with ‘not all control paths return a value’ here: the statement <code>x + 1;</code> doesn’t return a value. There are two kinds of statements in Rust: ‘declaration statements’ and ‘expression statements’. Everything else is an expression. Let’s talk about declaration statements first.</p>
<p id = "para-223">In some languages, variable bindings can be written as expressions, not statements. Like Ruby:</p>
<pre><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5
</span></pre><p id = "para-224">In Rust, however, using <code>let</code> to introduce a binding is <em>not</em> an expression. The following will produce a compile-time error:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// Expected identifier, found keyword `let`.
</span></pre><p id = "para-225">The compiler is telling us here that it was expecting to see the beginning of an expression, and a <code>let</code> can only begin a statement, not an expression.</p>
<p id = "para-226">Note that assigning to an already-bound variable (e.g. <code>y = 5</code>) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. <code>5</code> in the previous example), in Rust the value of an assignment is an empty tuple <code>()</code> because the assigned value can have <a href = "#chapter-15">only one owner</a>, and any other returned value would be too surprising:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">);  </span><span style="font-style:italic;color:#969896;">// `x` has the value `()`, not `6`.
</span></pre><p id = "para-227">The second kind of statement in Rust is the <em>expression statement</em>. Its purpose is to turn any expression into a statement. In practical terms, Rust’s grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.</p>
<p id = "para-228">What is this exception that makes us say “almost”? You saw it already, in this code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add_one</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}
</span></pre><p id = "para-229">Our function claims to return an <code>i32</code>, but with a semicolon, it would return <code>()</code> instead. Rust realizes this probably isn’t what we want, and suggests removing the semicolon in the error we saw before.</p>
<h3 id = "link-42">Early returns</h3>
<p id = "para-230">But what about early returns? Rust does have a keyword for that, <code>return</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;"> x;

    </span><span style="font-style:italic;color:#969896;">// We never run this code!
</span><span style="color:#323232;">    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}
</span></pre><p id = "para-231">Using a <code>return</code> as the last line of a function works, but is considered poor style:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
}
</span></pre><p id = "para-232">The previous definition without <code>return</code> may look a bit strange if you haven’t worked in an expression-based language before, but it becomes intuitive over time.</p>
<h3 id = "link-43">Diverging functions</h3>
<p id = "para-233">Rust has some special syntax for ‘diverging functions’, which are functions that do not return:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">diverges</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">! </span><span style="color:#323232;">{
    panic!(</span><span style="color:#183691;">&quot;This function never returns!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-234"><code>panic!</code> is a macro, similar to <code>println!()</code> that we’ve already seen. Unlike <code>println!()</code>, <code>panic!()</code> causes the current thread of execution to crash with the given message. Because this function will cause a crash, it will never return, and so it has the type ‘<code>!</code>’, which is read ‘diverges’.</p>
<p id = "para-235">If you add a main function that calls <code>diverges()</code> and run it, you’ll get some output that looks like this:</p>
<pre><span style="color:#323232;">thread ‘main’ panicked at ‘This function never returns!’, hello.rs:2
</span></pre><p id = "para-236">If you want more information, you can get a backtrace by setting the <code>RUST_BACKTRACE</code> environment variable:</p>
<pre><span style="color:#323232;">$ RUST_BACKTRACE=1 ./diverges
thread &#39;main&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
stack backtrace:
  hello::diverges
        at ./hello.rs:2
  hello::main
        at ./hello.rs:6
</span></pre><p id = "para-237">If you want the complete backtrace and filenames:</p>
<pre><span style="color:#323232;">$ RUST_BACKTRACE=full ./diverges
thread &#39;main&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</span></pre><p id = "para-238">If you need to override an already set <code>RUST_BACKTRACE</code>, in cases when you cannot just unset the variable, then set it to <code>0</code> to avoid getting a backtrace. Any other value (even no value at all) turns on backtrace.</p>
<pre><span style="color:#323232;">$ export RUST_BACKTRACE=1
...
$ RUST_BACKTRACE=0 ./diverges 
thread &#39;main&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</span></pre><p id = "para-239"><code>RUST_BACKTRACE</code> also works with Cargo’s <code>run</code> command:</p>
<pre><span style="color:#323232;">$ RUST_BACKTRACE=full cargo run
     Running `target/debug/diverges`
thread &#39;main&#39; panicked at &#39;This function never returns!&#39;, hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</span></pre><p id = "para-240">A diverging function can be used as any type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">diverges</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">! </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#    </span><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;This function never returns!&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#62a35c;">diverges</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">diverges</span><span style="color:#323232;">();
</span></pre><h3 id = "link-44">Function pointers</h3>
<p id = "para-241">We can also create variable bindings which point to functions:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f: </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;
</span></pre><p id = "para-242"><code>f</code> is a variable binding which points to a function that takes an <code>i32</code> as an argument and returns an <code>i32</code>. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">plus_one</span><span style="color:#323232;">(i: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    i </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// Without type inference:
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f: </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> plus_one;

</span><span style="font-style:italic;color:#969896;">// With type inference:
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> plus_one;
</span></pre><p id = "para-243">We can then use <code>f</code> to call the function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">plus_one</span><span style="color:#323232;">(i: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ i </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> plus_one;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> six </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span></pre>
</div><div id = "chapter-10" class = "chapter">
  <h2 id = "link-45">Primitive Types</h2>
<p id = "para-244">The Rust language has a number of types that are considered ‘primitive’. This means that they’re built-in to the language. Rust is structured in such a way that the standard library also provides a number of useful types built on top of these ones, as well, but these are the most primitive.</p>
<h2 id = "link-46">Booleans</h2>
<p id = "para-245">Rust has a built-in boolean type, named <code>bool</code>. It has two values, <code>true</code> and <code>false</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">true</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: </span><span style="font-weight:bold;color:#a71d5d;">bool = </span><span style="color:#0086b3;">false</span><span style="color:#323232;">;
</span></pre><p id = "para-246">A common use of booleans is in <a href = "#chapter-12"><code>if</code> conditionals</a>.</p>
<p id = "para-247">You can find more documentation for <code>bool</code>s <a href = "src/../../std/primitive.bool.html">in the standard library documentation</a>.</p>
<h2 id = "link-47"><code>char</code></h2>
<p id = "para-248">The <code>char</code> type represents a single Unicode scalar value. You can create <code>char</code>s with a single tick: (<code>'</code>)</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;x&#39;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> two_hearts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;💕&#39;</span><span style="color:#323232;">;
</span></pre><p id = "para-249">Unlike some other languages, this means that Rust’s <code>char</code> is not a single byte, but four.</p>
<p id = "para-250">You can find more documentation for <code>char</code>s <a href = "src/../../std/primitive.char.html">in the standard library documentation</a>.</p>
<h2 id = "link-48">Numeric types</h2>
<p id = "para-251">Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.</p>
<p id = "para-252">These types consist of two parts: the category, and the size. For example, <code>u16</code> is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.</p>
<p id = "para-253">If a number literal has nothing to cause its type to be inferred, it defaults:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `x` has type `i32`.

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1.0</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `y` has type `f64`.
</span></pre><p id = "para-254">Here’s a list of the different numeric types, with links to their documentation in the standard library:</p>
<ul>
<li><a href = "src/../../std/primitive.i8.html">i8</a></li>
<li><a href = "src/../../std/primitive.i16.html">i16</a></li>
<li><a href = "src/../../std/primitive.i32.html">i32</a></li>
<li><a href = "src/../../std/primitive.i64.html">i64</a></li>
<li><a href = "src/../../std/primitive.u8.html">u8</a></li>
<li><a href = "src/../../std/primitive.u16.html">u16</a></li>
<li><a href = "src/../../std/primitive.u32.html">u32</a></li>
<li><a href = "src/../../std/primitive.u64.html">u64</a></li>
<li><a href = "src/../../std/primitive.isize.html">isize</a></li>
<li><a href = "src/../../std/primitive.usize.html">usize</a></li>
<li><a href = "src/../../std/primitive.f32.html">f32</a></li>
<li><a href = "src/../../std/primitive.f64.html">f64</a></li>
</ul>
<p id = "para-255">Let’s go over them by category:</p>
<h3 id = "link-49">Signed and Unsigned</h3>
<p id = "para-256">Integer types come in two varieties: signed and unsigned. To understand the difference, let’s consider a number with four bits of size. A signed, four-bit number would let you store numbers from <code>-8</code> to <code>+7</code>. Signed numbers use “two’s complement representation”. An unsigned four bit number, since it does not need to store negatives, can store values from <code>0</code> to <code>+15</code>.</p>
<p id = "para-257">Unsigned types use a <code>u</code> for their category, and signed types use <code>i</code>. The <code>i</code> is for ‘integer’. So <code>u8</code> is an eight-bit unsigned number, and <code>i8</code> is an eight-bit signed number.</p>
<h3 id = "link-50">Fixed-size types</h3>
<p id = "para-258">Fixed-size types have a specific number of bits in their representation. Valid bit sizes are <code>8</code>, <code>16</code>, <code>32</code>, and <code>64</code>. So, <code>u32</code> is an unsigned, 32-bit integer, and <code>i64</code> is a signed, 64-bit integer.</p>
<h3 id = "link-51">Variable-size types</h3>
<p id = "para-259">Rust also provides types whose particular size depends on the underlying machine architecture. Their range is sufficient to express the size of any collection, so these types have ‘size’ as the category. They come in signed and unsigned varieties which account for two types: <code>isize</code> and <code>usize</code>.</p>
<h3 id = "link-52">Floating-point types</h3>
<p id = "para-260">Rust also has two floating point types: <code>f32</code> and <code>f64</code>. These correspond to IEEE-754 single and double precision numbers.</p>
<h2 id = "link-53">Arrays</h2>
<p id = "para-261">Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the <em>array</em>, a fixed-size list of elements of the same type. By default, arrays are immutable.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// a: [i32; 3]
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> m </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// m: [i32; 3]
</span></pre><p id = "para-262">Arrays have type <code>[T; N]</code>. We’ll talk about this <code>T</code> notation <a href = "#chapter-25">in the generics section</a>. The <code>N</code> is a compile-time constant, for the length of the array.</p>
<p id = "para-263">There’s a shorthand for initializing each element of an array to the same value. In this example, each element of <code>a</code> will be initialized to <code>0</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">; </span><span style="color:#0086b3;">20</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// a: [i32; 20]
</span></pre><p id = "para-264">You can get the number of elements in an array <code>a</code> with <code>a.len()</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

println!(</span><span style="color:#183691;">&quot;a has </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> elements&quot;</span><span style="color:#323232;">, a.</span><span style="color:#62a35c;">len</span><span style="color:#323232;">());
</span></pre><p id = "para-265">You can access a particular element of an array with <em>subscript notation</em>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> names </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#183691;">&quot;Graydon&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Brian&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Niko&quot;</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// names: [&amp;str; 3]

</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;The second name is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, names[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">]);
</span></pre><p id = "para-266">Subscripts start at zero, like in most programming languages, so the first name is <code>names[0]</code> and the second name is <code>names[1]</code>. The above example prints <code>The second name is: Brian</code>. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.</p>
<p id = "para-267">You can find more documentation for <code>array</code>s <a href = "src/../../std/primitive.array.html">in the standard library documentation</a>.</p>
<h2 id = "link-54">Slices</h2>
<p id = "para-268">A ‘slice’ is a reference to (or “view” into) another data structure. They are useful for allowing safe, efficient access to a portion of an array without copying. For example, you might want to reference only one line of a file read into memory. By nature, a slice is not created directly, but from an existing variable binding. Slices have a defined length, and can be mutable or immutable.</p>
<p id = "para-269">Internally, slices are represented as a pointer to the beginning of the data and a length.</p>
<h3 id = "link-55">Slicing syntax</h3>
<p id = "para-270">You can use a combo of <code>&amp;</code> and <code>[]</code> to create a slice from various things. The <code>&amp;</code> indicates that slices are similar to <a href = "#chapter-16">references</a>, which we will cover in detail later in this section. The <code>[]</code>s, with a range, let you define the length of the slice:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> complete </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">a[</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// A slice containing all of the elements in `a`.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> middle </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">a[</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">4</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// A slice of `a`: only the elements `1`, `2`, and `3`.
</span></pre><p id = "para-271">Slices have type <code>&amp;[T]</code>. We’ll talk about that <code>T</code> when we cover <a href = "#chapter-25">generics</a>.</p>
<p id = "para-272">You can find more documentation for slices <a href = "src/../../std/primitive.slice.html">in the standard library documentation</a>.</p>
<h2 id = "link-56"><code>str</code></h2>
<p id = "para-273">Rust’s <code>str</code> type is the most primitive string type. As an <a href = "#chapter-38">unsized type</a>, it’s not very useful by itself, but becomes useful when placed behind a reference, like <code>&amp;str</code>. We’ll elaborate further when we cover <a href = "#chapter-24">Strings</a> and <a href = "#chapter-16">references</a>.</p>
<p id = "para-274">You can find more documentation for <code>str</code> <a href = "src/../../std/primitive.str.html">in the standard library documentation</a>.</p>
<h2 id = "link-57">Tuples</h2>
<p id = "para-275">A tuple is an ordered list of fixed size. Like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;hello&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-276">The parentheses and commas form this two-length tuple. Here’s the same code, but with the type annotated:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: (</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;hello&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-277">As you can see, the type of a tuple looks like the tuple, but with each position having a type name rather than the value. Careful readers will also note that tuples are heterogeneous: we have an <code>i32</code> and a <code>&amp;str</code> in this tuple. In systems programming languages, strings are a bit more complex than in other languages. For now, read <code>&amp;str</code> as a <em>string slice</em>, and we’ll learn more soon.</p>
<p id = "para-278">You can assign one tuple into another, if they have the same contained types and <a href = "#chapter-60">arity</a>. Tuples have the same arity when they have the same length.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// x: (i32, i32)
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// y: (i32, i32)
</span><span style="color:#323232;">
x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> y;
</span></pre><p id = "para-279">You can access the fields in a tuple through a <em>destructuring let</em>. Here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(x, y, z) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);

println!(</span><span style="color:#183691;">&quot;x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
</span></pre><p id = "para-280">Remember <a href = "#chapter-8">before</a> when I said the left-hand side of a <code>let</code> statement was more powerful than assigning a binding? Here we are. We can put a pattern on the left-hand side of the <code>let</code>, and if it matches up to the right-hand side, we can assign multiple bindings at once. In this case, <code>let</code> “destructures” or “breaks up” the tuple, and assigns the bits to three bindings.</p>
<p id = "para-281">This pattern is very powerful, and we’ll see it repeated more later.</p>
<p id = "para-282">You can disambiguate a single-element tuple from a value in parentheses with a comma:</p>
<pre><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">,); </span><span style="font-style:italic;color:#969896;">// A single-element tuple.
</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// A zero in parentheses.
</span></pre><h3 id = "link-58">Tuple Indexing</h3>
<p id = "para-283">You can also access fields of a tuple with indexing syntax:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> tuple </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tuple.</span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tuple.</span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tuple.</span><span style="color:#0086b3;">2</span><span style="color:#323232;">;

println!(</span><span style="color:#183691;">&quot;x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
</span></pre><p id = "para-284">Like array indexing, it starts at zero, but unlike array indexing, it uses a <code>.</code>, rather than <code>[]</code>s.</p>
<p id = "para-285">You can find more documentation for tuples <a href = "src/../../std/primitive.tuple.html">in the standard library documentation</a>.</p>
<h2 id = "link-59">Functions</h2>
<p id = "para-286">Functions also have a type! They look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ x }

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> foo;
</span></pre><p id = "para-287">In this case, <code>x</code> is a ‘function pointer’ to a function that takes an <code>i32</code> and returns an <code>i32</code>.</p>

</div><div id = "chapter-11" class = "chapter">
  <h2 id = "link-60">Comments</h2>
<p id = "para-288">Now that we have some functions, it’s a good idea to learn about comments. Comments are notes that you leave to other programmers to help explain things about your code. The compiler mostly ignores them.</p>
<p id = "para-289">Rust has two kinds of comments that you should care about: <em>line comments</em> and <em>doc comments</em>.</p>
<pre><span style="font-style:italic;color:#969896;">// Line comments are anything after ‘//’ and extend to the end of the line.

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// This is also a line comment.

// If you have a long explanation for something, you can put line comments next
// to each other. Put a space between the // and your comment so that it’s
// more readable.
</span></pre><p id = "para-290">The other kind of comment is a doc comment. Doc comments use <code>///</code> instead of <code>//</code>, and support Markdown notation inside:</p>
<pre><span style="font-style:italic;color:#969896;">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// # fn add_one(x: i32) -&gt; i32 {
/// #     x + 1
/// # }
/// ```
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add_one</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}
</span></pre><p id = "para-291">There is another style of doc comment, <code>//!</code>, to comment containing items (e.g. crates, modules or functions), instead of the items following it. Commonly used inside crates root (lib.rs) or modules root (mod.rs):</p>
<pre><span style="color:#323232;">//! # The Rust Standard Library
//!
//! The Rust Standard Library provides the essential runtime
//! functionality for building portable Rust software.
</span></pre><p id = "para-292">When writing doc comments, providing some examples of usage is very, very helpful. You’ll notice we’ve used a new macro here: <code>assert_eq!</code>. This compares two values, and <code>panic!</code>s if they’re not equal to each other. It’s very helpful in documentation. There’s another macro, <code>assert!</code>, which <code>panic!</code>s if the value passed to it is <code>false</code>.</p>
<p id = "para-293">You can use the <a href = "#chapter-49"><code>rustdoc</code></a> tool to generate HTML documentation from these doc comments, and also to run the code examples as tests!</p>

</div><div id = "chapter-12" class = "chapter">
  <h2 id = "link-61">if</h2>
<p id = "para-294">Rust’s take on <code>if</code> is not particularly complex, but it’s much more like the <code>if</code> you’ll find in a dynamically typed language than in a more traditional systems language. So let’s talk about it, to make sure you grasp the nuances.</p>
<p id = "para-295"><code>if</code> is a specific form of a more general concept, the ‘branch’, whose name comes from a branch in a tree: a decision point, where depending on a choice, multiple paths can be taken.</p>
<p id = "para-296">In the case of <code>if</code>, there is one choice that leads down two paths:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is five!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-297">If we changed the value of <code>x</code> to something else, this line would not print. More specifically, if the expression after the <code>if</code> evaluates to <code>true</code>, then the block is executed. If it’s <code>false</code>, then it is not.</p>
<p id = "para-298">If you want something to happen in the <code>false</code> case, use an <code>else</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is five!&quot;</span><span style="color:#323232;">);
} </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is not five :(&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-299">If there is more than one case, use an <code>else if</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is five!&quot;</span><span style="color:#323232;">);
} </span><span style="font-weight:bold;color:#a71d5d;">else if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">6 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is six!&quot;</span><span style="color:#323232;">);
} </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;x is not five or six :(&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-300">This is all pretty standard. However, you can also do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">{
    </span><span style="color:#0086b3;">10
</span><span style="color:#323232;">} </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
    </span><span style="color:#0086b3;">15
</span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">// y: i32
</span></pre><p id = "para-301">Which we can (and probably should) write like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">{ </span><span style="color:#0086b3;">10 </span><span style="color:#323232;">} </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{ </span><span style="color:#0086b3;">15 </span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">// y: i32
</span></pre><p id = "para-302">This works because <code>if</code> is an expression. The value of the expression is the value of the last expression in whichever branch was chosen. An <code>if</code> without an <code>else</code> always results in <code>()</code> as the value.</p>

</div><div id = "chapter-13" class = "chapter">
  <h2 id = "link-62">Loops</h2>
<p id = "para-303">Rust currently provides three approaches to performing some kind of iterative activity. They are: <code>loop</code>, <code>while</code> and <code>for</code>. Each approach has its own set of uses.</p>
<h3 id = "link-63">loop</h3>
<p id = "para-304">The infinite <code>loop</code> is the simplest form of loop available in Rust. Using the keyword <code>loop</code>, Rust provides a way to loop indefinitely until some terminating statement is reached. Rust’s infinite <code>loop</code>s look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;Loop forever!&quot;</span><span style="color:#323232;">);
}
</span></pre><h3 id = "link-64">while</h3>
<p id = "para-305">Rust also has a <code>while</code> loop. It looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// mut x: i32
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> done </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">false</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// mut done: bool

</span><span style="font-weight:bold;color:#a71d5d;">while !</span><span style="color:#323232;">done {
    x </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);

    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{
        done </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">true</span><span style="color:#323232;">;
    }
}
</span></pre><p id = "para-306"><code>while</code> loops are the correct choice when you’re not sure how many times you need to loop.</p>
<p id = "para-307">If you need an infinite loop, you may be tempted to write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">while </span><span style="color:#0086b3;">true </span><span style="color:#323232;">{
</span></pre><p id = "para-308">However, <code>loop</code> is far better suited to handle this case:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
</span></pre><p id = "para-309">Rust’s control-flow analysis treats this construct differently than a <code>while true</code>, since we know that it will always loop. In general, the more information we can give to the compiler, the better it can do with safety and code generation, so you should always prefer <code>loop</code> when you plan to loop infinitely.</p>
<h3 id = "link-65">for</h3>
<p id = "para-310">The <code>for</code> loop is used to loop a particular number of times. Rust’s <code>for</code> loops work a bit differently than in other systems languages, however. Rust’s <code>for</code> loop doesn’t look like this “C-style” <code>for</code> loop:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">; x </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">10</span><span style="color:#323232;">; x</span><span style="font-weight:bold;color:#a71d5d;">++</span><span style="color:#323232;">) {
    </span><span style="color:#62a35c;">printf</span><span style="color:#323232;">( </span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">%d\n</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x );
}
</span></pre><p id = "para-311">Instead, it looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// x: i32
</span><span style="color:#323232;">}
</span></pre><p id = "para-312">In slightly more abstract terms,</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> var </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> expression {
    code
}
</span></pre><p id = "para-313">The expression is an item that can be converted into an <a href = "#chapter-50">iterator</a> using <a href = "src/../../std/iter/trait.IntoIterator.html"><code>IntoIterator</code></a>. The iterator gives back a series of elements, one element per iteration of the loop. That value is then bound to the name <code>var</code>, which is valid for the loop body. Once the body is over, the next value is fetched from the iterator, and we loop another time. When there are no more values, the <code>for</code> loop is over.</p>
<p id = "para-314">In our example, <code>0..10</code> is an expression that takes a start and an end position, and gives an iterator over those values. The upper bound is exclusive, though, so our loop will print <code>0</code> through <code>9</code>, not <code>10</code>.</p>
<p id = "para-315">Rust does not have the “C-style” <code>for</code> loop on purpose. Manually controlling each element of the loop is complicated and error prone, even for experienced C developers.</p>
<h4 id = "link-66">Enumerate</h4>
<p id = "para-316">When you need to keep track of how many times you have already looped, you can use the <code>.enumerate()</code> function.</p>
<h5 id = "link-67">On ranges:</h5>
<pre><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(index, value) </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10</span><span style="color:#323232;">).</span><span style="color:#62a35c;">enumerate</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;index = </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> and value = </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, index, value);
}
</span></pre><p id = "para-317">Outputs:</p>
<pre><span style="color:#323232;">index = 0 and value = 5
index = 1 and value = 6
index = 2 and value = 7
index = 3 and value = 8
index = 4 and value = 9
</span></pre><p id = "para-318">Don’t forget to add the parentheses around the range.</p>
<h5 id = "link-68">On iterators:</h5>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> lines </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;hello</span><span style="color:#0086b3;">\n</span><span style="color:#183691;">world&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">lines</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(linenumber, line) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> lines.</span><span style="color:#62a35c;">enumerate</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, linenumber, line);
}
</span></pre><p id = "para-319">Outputs:</p>
<pre><span style="color:#323232;">0: hello
1: world
</span></pre><h3 id = "link-69">Ending iteration early</h3>
<p id = "para-320">Let’s take a look at that <code>while</code> loop we had earlier:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> done </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">false</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">while !</span><span style="color:#323232;">done {
    x </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);

    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{
        done </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">true</span><span style="color:#323232;">;
    }
}
</span></pre><p id = "para-321">We had to keep a dedicated <code>mut</code> boolean variable binding, <code>done</code>, to know when we should exit out of the loop. Rust has two keywords to help us with modifying iteration: <code>break</code> and <code>continue</code>.</p>
<p id = "para-322">In this case, we can write the loop in a better way with <code>break</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">- </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);

    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">break</span><span style="color:#323232;">; }
}
</span></pre><p id = "para-323">We now loop forever with <code>loop</code> and use <code>break</code> to break out early. Issuing an explicit <code>return</code> statement will also serve to terminate the loop early.</p>
<p id = "para-324"><code>continue</code> is similar, but instead of ending the loop, it goes to the next iteration. This will only print the odd numbers:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">continue</span><span style="color:#323232;">; }

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><h3 id = "link-70">Loop labels</h3>
<p id = "para-325">You may also encounter situations where you have nested loops and need to specify which one your <code>break</code> or <code>continue</code> statement is for. Like most other languages, Rust’s <code>break</code> or <code>continue</code> apply to the innermost loop. In a situation where you would like to <code>break</code> or <code>continue</code> for one of the outer loops, you can use labels to specify which loop the <code>break</code> or <code>continue</code> statement applies to.</p>
<p id = "para-326">In the example below, we <code>continue</code> to the next iteration of <code>outer</code> loop when <code>x</code> is even, while we <code>continue</code> to the next iteration of <code>inner</code> loop when y is even. So it will execute the <code>println!</code> when both <code>x</code> and <code>y</code> are odd.</p>
<pre><span style="color:#323232;">&#39;outer: </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
    &#39;inner: </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">continue &#39;outer</span><span style="color:#323232;">; } </span><span style="font-style:italic;color:#969896;">// Continues the loop over `x`.
        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">continue &#39;inner</span><span style="color:#323232;">; } </span><span style="font-style:italic;color:#969896;">// Continues the loop over `y`.
        </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y);
    }
}
</span></pre>
</div><div id = "chapter-14" class = "chapter">
  <h2 id = "link-71">Vectors</h2>
<p id = "para-327">A ‘vector’ is a dynamic or ‘growable’ array, implemented as the standard library type <a href = "src/../../std/vec/index.html"><code>Vec&lt;T&gt;</code></a>. The <code>T</code> means that we can have vectors of any type (see the chapter on <a href = "#chapter-25">generics</a> for more). Vectors always allocate their data on the heap. You can create them with the <code>vec!</code> macro:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// v: Vec&lt;i32&gt;
</span></pre><p id = "para-328">(Notice that unlike the <code>println!</code> macro we’ve used in the past, we use square brackets <code>[]</code> with <code>vec!</code> macro. Rust allows you to use either in either situation, this is just convention.)</p>
<p id = "para-329">There’s an alternate form of <code>vec!</code> for repeating an initial value:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">0</span><span style="color:#323232;">; </span><span style="color:#0086b3;">10</span><span style="color:#323232;">]; </span><span style="font-style:italic;color:#969896;">// A vector of ten zeroes.
</span></pre><p id = "para-330">Vectors store their contents as contiguous arrays of <code>T</code> on the heap. This means that they must be able to know the size of <code>T</code> at compile time (that is, how many bytes are needed to store a <code>T</code>?). The size of some things can’t be known at compile time. For these you’ll have to store a pointer to that thing: thankfully, the <a href = "src/../../std/boxed/index.html"><code>Box</code></a> type works perfectly for this.</p>
<h3 id = "link-72">Accessing elements</h3>
<p id = "para-331">To get the value at a particular index in the vector, we use <code>[]</code>s:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];

println!(</span><span style="color:#183691;">&quot;The third element of v is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v[</span><span style="color:#0086b3;">2</span><span style="color:#323232;">]);
</span></pre><p id = "para-332">The indices count from <code>0</code>, so the third element is <code>v[2]</code>.</p>
<p id = "para-333">It’s also important to note that you must index with the <code>usize</code> type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> i: </span><span style="font-weight:bold;color:#a71d5d;">usize = </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> j: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;

</span><span style="font-style:italic;color:#969896;">// Works:
</span><span style="color:#323232;">v[i];

</span><span style="font-style:italic;color:#969896;">// Doesn’t:
</span><span style="color:#323232;">v[j];
</span></pre><p id = "para-334">Indexing with a non-<code>usize</code> type gives an error that looks like this:</p>
<pre><span style="color:#323232;">error: the trait bound `collections::vec::Vec&lt;_&gt; : core::ops::Index&lt;i32&gt;`
is not satisfied [E0277]
v[j];
^~~~
note: the type `collections::vec::Vec&lt;_&gt;` cannot be indexed by `i32`
error: aborting due to previous error
</span></pre><p id = "para-335">There’s a lot of punctuation in that message, but the core of it makes sense: you cannot index with an <code>i32</code>.</p>
<h3 id = "link-73">Out-of-bounds Access</h3>
<p id = "para-336">If you try to access an index that doesn’t exist:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
println!(</span><span style="color:#183691;">&quot;Item 7 is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v[</span><span style="color:#0086b3;">7</span><span style="color:#323232;">]);
</span></pre><p id = "para-337">then the current thread will <a href = "#chapter-51">panic</a> with a message like this:</p>
<pre><span style="color:#323232;">thread &#39;main&#39; panicked at &#39;index out of bounds: the len is 3 but the index is 7&#39;
</span></pre><p id = "para-338">If you want to handle out-of-bounds errors without panicking, you can use methods like <a href = "src/../../std/vec/struct.Vec.html#method.get"><code>get</code></a> or <a href = "src/../../std/vec/struct.Vec.html#method.get_mut"><code>get_mut</code></a> that return <code>None</code> when given an invalid index:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> v.</span><span style="color:#62a35c;">get</span><span style="color:#323232;">(</span><span style="color:#0086b3;">7</span><span style="color:#323232;">) {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Item 7 is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x),
    </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Sorry, this vector is too short.&quot;</span><span style="color:#323232;">)
}
</span></pre><h3 id = "link-74">Iterating</h3>
<p id = "para-339">Once you have a vector, you can iterate through its elements with <code>for</code>. There are three versions:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">v {
    println!(</span><span style="color:#183691;">&quot;A reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;mut</span><span style="color:#323232;"> v {
    println!(</span><span style="color:#183691;">&quot;A mutable reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> v {
    println!(</span><span style="color:#183691;">&quot;Take ownership of the vector and its element </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-340">Note: You cannot use the vector again once you have iterated by taking ownership of the vector. You can iterate the vector multiple times by taking a reference to the vector whilst iterating. For example, the following code does not compile.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> v {
    println!(</span><span style="color:#183691;">&quot;Take ownership of the vector and its element </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> v {
    println!(</span><span style="color:#183691;">&quot;Take ownership of the vector and its element </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-341">Whereas the following works perfectly,</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">v {
    println!(</span><span style="color:#183691;">&quot;This is a reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">v {
    println!(</span><span style="color:#183691;">&quot;This is a reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-342">Vectors have many more useful methods, which you can read about in <a href = "src/../../std/vec/index.html">their API documentation</a>.</p>

</div><div id = "chapter-15" class = "chapter">
  <h2 id = "link-75">Ownership</h2>
<p id = "para-343">This is the first of three sections presenting Rust’s ownership system. This is one of Rust’s most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
<ul>
<li>ownership, which you’re reading now</li>
<li><a href = "#chapter-16">borrowing</a>, and their associated feature ‘references’</li>
<li><a href = "#chapter-17">lifetimes</a>, an advanced concept of borrowing</li>
</ul>
<p id = "para-344">These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
<h2 id = "link-76">Meta</h2>
<p id = "para-345">Before we get to the details, two important notes about the ownership system.</p>
<p id = "para-346">Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
<p id = "para-347">However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
<p id = "para-348">With that in mind, let’s learn about ownership.</p>
<h2 id = "link-77">Ownership</h2>
<p id = "para-349"><a href = "#chapter-8">Variable bindings</a> have a property in Rust: they ‘have ownership’ of what they’re bound to. This means that when a binding goes out of scope, Rust will free the bound resources. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
}
</span></pre><p id = "para-350">When <code>v</code> comes into scope, a new <a href = "#chapter-14">vector</a> is created on <a href = "#chapter-46">the stack</a>, and it allocates space on <a href = "#chapter-46">the heap</a> for its elements. When <code>v</code> goes out of scope at the end of <code>foo()</code>, Rust will clean up everything related to the vector, even the heap-allocated memory. This happens deterministically, at the end of the scope.</p>
<p id = "para-351">We covered <a href = "#chapter-14">vectors</a> in the previous chapter; we use them here as an example of a type that allocates space on the heap at runtime. They behave like <a href = "#chapter-10">arrays</a>, except their size may change by <code>push()</code>ing more elements onto them.</p>
<p id = "para-352">Vectors have a <a href = "#chapter-25">generic type</a> <code>Vec&lt;T&gt;</code>, so in this example <code>v</code> will have type <code>Vec&lt;i32&gt;</code>. We’ll cover <a href = "#chapter-25">generics</a> in detail in a later chapter.</p>
<h2 id = "link-78">Move semantics</h2>
<p id = "para-353">There’s some more subtlety here, though: Rust ensures that there is <em>exactly one</em> binding to any given resource. For example, if we have a vector, we can assign it to another binding:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v;
</span></pre><p id = "para-354">But, if we try to use <code>v</code> afterwards, we get an error:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v;

println!(</span><span style="color:#183691;">&quot;v[0] is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">]);
</span></pre><p id = "para-355">It looks like this:</p>
<pre><span style="color:#323232;">error: use of moved value: `v`
println!(&quot;v[0] is: {}&quot;, v[0]);
                        ^
</span></pre><p id = "para-356">A similar thing happens if we define a function which takes ownership, and try to use something after we’ve passed it as an argument:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">take</span><span style="color:#323232;">(v: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) {
    </span><span style="font-style:italic;color:#969896;">// What happens here isn’t important.
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="color:#62a35c;">take</span><span style="color:#323232;">(v);

println!(</span><span style="color:#183691;">&quot;v[0] is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">]);
</span></pre><p id = "para-357">Same error: ‘use of moved value’. When we transfer ownership to something else, we say that we’ve ‘moved’ the thing we refer to. You don’t need some sort of special annotation here, it’s the default thing that Rust does.</p>
<h3 id = "link-79">The details</h3>
<p id = "para-358">The reason that we cannot use a binding after we’ve moved it is subtle, but important.</p>
<p id = "para-359">When we write code like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;
</span></pre><p id = "para-360">Rust allocates memory for an integer <a href = "#chapter-10">i32</a> on the <a href = "#chapter-46">stack</a>, copies the bit pattern representing the value of 10 to the allocated memory and binds the variable name x to this memory region for future reference.</p>
<p id = "para-361">Now consider the following code fragment:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v;
</span></pre><p id = "para-362">The first line allocates memory for the vector object <code>v</code> on the stack like it does for <code>x</code> above. But in addition to that it also allocates some memory on the <a href = "#chapter-46">heap</a> for the actual data (<code>[1, 2, 3]</code>). Rust copies the address of this heap allocation to an internal pointer, which is part of the vector object placed on the stack (let’s call it the data pointer).</p>
<p id = "para-363">It is worth pointing out (even at the risk of stating the obvious) that the vector object and its data live in separate memory regions instead of being a single contiguous memory allocation (due to reasons we will not go into at this point of time). These two parts of the vector (the one on the stack and one on the heap) must agree with each other at all times with regards to things like the length, capacity, etc.</p>
<p id = "para-364">When we move <code>v</code> to <code>v2</code>, Rust actually does a bitwise copy of the vector object <code>v</code> into the stack allocation represented by <code>v2</code>. This shallow copy does not create a copy of the heap allocation containing the actual data. Which means that there would be two pointers to the contents of the vector both pointing to the same memory allocation on the heap. It would violate Rust’s safety guarantees by introducing a data race if one could access both <code>v</code> and <code>v2</code> at the same time.</p>
<p id = "para-365">For example if we truncated the vector to just two elements through <code>v2</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;"># let mut</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v;
v2.</span><span style="color:#62a35c;">truncate</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">);
</span></pre><p id = "para-366">and <code>v</code> were still accessible we’d end up with an invalid vector since <code>v</code> would not know that the heap data has been truncated. Now, the part of the vector <code>v</code> on the stack does not agree with the corresponding part on the heap. <code>v</code> still thinks there are three elements in the vector and will happily let us access the non existent element <code>v[2]</code> but as you might already know this is a recipe for disaster. Especially because it might lead to a segmentation fault or worse allow an unauthorized user to read from memory to which they don’t have access.</p>
<p id = "para-367">This is why Rust forbids using <code>v</code> after we’ve done the move.</p>
<p id = "para-368">It’s also important to note that optimizations may remove the actual copy of the bytes on the stack, depending on circumstances. So it may not be as inefficient as it initially seems.</p>
<h3 id = "link-80"><code>Copy</code> types</h3>
<p id = "para-369">We’ve established that when ownership is transferred to another binding, you cannot use the original binding. However, there’s a <a href = "#chapter-26">trait</a> that changes this behavior, and it’s called <code>Copy</code>. We haven’t discussed traits yet, but for now, you can think of them as an annotation to a particular type that adds extra behavior. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v;

println!(</span><span style="color:#183691;">&quot;v is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-370">In this case, <code>v</code> is an <code>i32</code>, which implements the <code>Copy</code> trait. This means that, just like a move, when we assign <code>v</code> to <code>v2</code>, a copy of the data is made. But, unlike a move, we can still use <code>v</code> afterward. This is because an <code>i32</code> has no pointers to data somewhere else, copying it is a full copy.</p>
<p id = "para-371">All primitive types implement the <code>Copy</code> trait and their ownership is therefore not moved like one would assume, following the ‘ownership rules’. To give an example, the two following snippets of code only compile because the <code>i32</code> and <code>bool</code> types implement the <code>Copy</code> trait.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> _y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">double</span><span style="color:#323232;">(a);
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}
</span></pre><pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">true</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> _y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">change_truth</span><span style="color:#323232;">(a);
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">change_truth</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">x
}
</span></pre><p id = "para-372">If we had used types that do not implement the <code>Copy</code> trait, we would have gotten a compile error because we tried to use a moved value.</p>
<pre><span style="color:#323232;">error: use of moved value: `a`
println!(&quot;{}&quot;, a);
               ^
</span></pre><p id = "para-373">We will discuss how to make your own types <code>Copy</code> in the <a href = "#chapter-26">traits</a> section.</p>
<h2 id = "link-81">More than ownership</h2>
<p id = "para-374">Of course, if we had to hand ownership back with every function we wrote:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; {
    </span><span style="font-style:italic;color:#969896;">// Do stuff with `v`.

    // Hand back ownership.
</span><span style="color:#323232;">    v
}
</span></pre><p id = "para-375">This would get very tedious. It gets worse the more things we want to take ownership of:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v1: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, v2: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; (Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-style:italic;color:#969896;">// Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    </span><span style="color:#323232;">(v1, v2, </span><span style="color:#0086b3;">42</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v1 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(v1, v2, answer) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(v1, v2);
</span></pre><p id = "para-376">Ugh! The return type, return line, and calling the function gets way more complicated.</p>
<p id = "para-377">Luckily, Rust offers a feature which helps us solve this problem. It’s called borrowing and is the topic of the next section!</p>

</div><div id = "chapter-16" class = "chapter">
  <h2 id = "link-82">References and Borrowing</h2>
<p id = "para-378">This is the second of three sections presenting Rust’s ownership system. This is one of Rust’s most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
<ul>
<li><a href = "#chapter-15">ownership</a>, the key concept</li>
<li>borrowing, which you’re reading now</li>
<li><a href = "#chapter-17">lifetimes</a>, an advanced concept of borrowing</li>
</ul>
<p id = "para-379">These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
<h2 id = "link-83">Meta</h2>
<p id = "para-380">Before we get to the details, two important notes about the ownership system.</p>
<p id = "para-381">Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
<p id = "para-382">However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
<p id = "para-383">With that in mind, let’s learn about borrowing.</p>
<h2 id = "link-84">Borrowing</h2>
<p id = "para-384">At the end of the <a href = "#chapter-15">ownership</a> section, we had a nasty function that looked like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v1: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, v2: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; (Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-style:italic;color:#969896;">// Do stuff with `v1` and `v2`.

    // Hand back ownership, and the result of our function.
    </span><span style="color:#323232;">(v1, v2, </span><span style="color:#0086b3;">42</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v1 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(v1, v2, answer) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(v1, v2);
</span></pre><p id = "para-385">This is not idiomatic Rust, however, as it doesn’t take advantage of borrowing. Here’s the first step:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v1: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, v2: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="font-style:italic;color:#969896;">// Do stuff with `v1` and `v2`.

    // Return the answer.
    </span><span style="color:#0086b3;">42
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v1 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">v1, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">v2);

</span><span style="font-style:italic;color:#969896;">// We can use `v1` and `v2` here!
</span></pre><p id = "para-386">A more concrete example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-style:italic;color:#969896;">// Don&#39;t worry if you don&#39;t understand how `fold` works, the point here is that an immutable reference is borrowed.
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">sum_vec</span><span style="color:#323232;">(v: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
        v.</span><span style="color:#62a35c;">iter</span><span style="color:#323232;">().</span><span style="color:#62a35c;">fold</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, |a, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">b| a </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> b)
    }
    </span><span style="font-style:italic;color:#969896;">// Borrow two vectors and sum them.
    // This kind of borrowing does not allow mutation through the borrowed reference.
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v1: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;, v2: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Do stuff with `v1` and `v2`.
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s1 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">sum_vec</span><span style="color:#323232;">(v1);
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">sum_vec</span><span style="color:#323232;">(v2);
        </span><span style="font-style:italic;color:#969896;">// Return the answer.
</span><span style="color:#323232;">        s1 </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> s2
    }

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v1 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">v1, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">v2);
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, answer);
}
</span></pre><p id = "para-387">Instead of taking <code>Vec&lt;i32&gt;</code>s as our arguments, we take a reference: <code>&amp;Vec&lt;i32&gt;</code>. And instead of passing <code>v1</code> and <code>v2</code> directly, we pass <code>&amp;v1</code> and <code>&amp;v2</code>. We call the <code>&amp;T</code> type a ‘reference’, and rather than owning the resource, it borrows ownership. A binding that borrows something does not deallocate the resource when it goes out of scope. This means that after the call to <code>foo()</code>, we can use our original bindings again.</p>
<p id = "para-388">References are immutable, like bindings. This means that inside of <code>foo()</code>, the vectors can’t be changed at all:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(v: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;) {
     v.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];

</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">v);
</span></pre><p id = "para-389">will give us this error:</p>
<pre><span style="color:#323232;">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</span></pre><p id = "para-390">Pushing a value mutates the vector, and so we aren’t allowed to do it.</p>
<h2 id = "link-85">&amp;mut references</h2>
<p id = "para-391">There’s a second kind of reference: <code>&amp;mut T</code>. A ‘mutable reference’ allows you to mutate the resource you’re borrowing. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;
    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">y </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
}
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
</span></pre><p id = "para-392">This will print <code>6</code>. We make <code>y</code> a mutable reference to <code>x</code>, then add one to the thing <code>y</code> points at. You’ll notice that <code>x</code> had to be marked <code>mut</code> as well. If it wasn’t, we couldn’t take a mutable borrow to an immutable value.</p>
<p id = "para-393">You’ll also notice we added an asterisk (<code>*</code>) in front of <code>y</code>, making it <code>*y</code>, this is because <code>y</code> is a <code>&amp;mut</code> reference. You’ll need to use asterisks to access the contents of a reference as well.</p>
<p id = "para-394">Otherwise, <code>&amp;mut</code> references are like references. There <em>is</em> a large difference between the two, and how they interact, though. You can tell something is fishy in the above example, because we need that extra scope, with the <code>{</code> and <code>}</code>. If we remove them, we get an error:</p>
<pre><span style="color:#323232;">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</span></pre><p id = "para-395">As it turns out, there are rules.</p>
<h2 id = "link-86">The Rules</h2>
<p id = "para-396">Here are the rules for borrowing in Rust:</p>
<p id = "para-397">First, any borrow must last for a scope no greater than that of the owner. Second, you may have one or the other of these two kinds of borrows, but not both at the same time:</p>
<ul>
<li>one or more references (<code>&amp;T</code>) to a resource,</li>
<li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
</ul>
<p id = "para-398">You may notice that this is very similar to, though not exactly the same as, the definition of a data race:</p>
<blockquote><p id = "para-399">There is a ‘data race’ when two or more pointers access the same memory location at the same time, where at least one of them is writing, and the operations are not synchronized.</p>
</blockquote>
<p id = "para-400">With references, you may have as many as you’d like, since none of them are writing. However, as we can only have one <code>&amp;mut</code> at a time, it is impossible to have a data race. This is how Rust prevents data races at compile time: we’ll get errors if we break the rules.</p>
<p id = "para-401">With this in mind, let’s consider our example again.</p>
<h3 id = "link-87">Thinking in scopes</h3>
<p id = "para-402">Here’s the code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;

    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">y </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-403">This code gives us this error:</p>
<pre><span style="color:#323232;">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</span></pre><p id = "para-404">This is because we’ve violated the rules: we have a <code>&amp;mut T</code> pointing to <code>x</code>, and so we aren’t allowed to create any <code>&amp;T</code>s. It’s one or the other. The note hints at how to think about this problem:</p>
<pre><span style="color:#323232;">note: previous borrow ends here
fn main() {

}
^
</span></pre><p id = "para-405">In other words, the mutable borrow is held through the rest of our example. What we want is for the mutable borrow by <code>y</code> to end so that the resource can be returned to the owner, <code>x</code>. <code>x</code> can then provide an immutable borrow to <code>println!</code>. In Rust, borrowing is tied to the scope that the borrow is valid for. And our scopes look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;    </span><span style="font-style:italic;color:#969896;">// -+ &amp;mut borrow of `x` starts here.
                       //  |
    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">y </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;           </span><span style="font-style:italic;color:#969896;">//  |
                       //  |
    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x); </span><span style="font-style:italic;color:#969896;">// -+ - Try to borrow `x` here.
</span><span style="color:#323232;">}                      </span><span style="font-style:italic;color:#969896;">// -+ &amp;mut borrow of `x` ends here.
                       
</span></pre><p id = "para-406">The scopes conflict: we can’t make an <code>&amp;x</code> while <code>y</code> is in scope.</p>
<p id = "para-407">So when we add the curly braces:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x; </span><span style="font-style:italic;color:#969896;">// -+ &amp;mut borrow starts here.
    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">y </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;        </span><span style="font-style:italic;color:#969896;">//  |
</span><span style="color:#323232;">}                   </span><span style="font-style:italic;color:#969896;">// -+ ... and ends here.

</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);  </span><span style="font-style:italic;color:#969896;">// &lt;- Try to borrow `x` here.
</span></pre><p id = "para-408">There’s no problem. Our mutable borrow goes out of scope before we create an immutable one. So scope is the key to seeing how long a borrow lasts for.</p>
<h3 id = "link-88">Issues borrowing prevents</h3>
<p id = "para-409">Why have these restrictive rules? Well, as we noted, these rules prevent data races. What kinds of issues do data races cause? Here are a few.</p>
<h4 id = "link-89">Iterator invalidation</h4>
<p id = "para-410">One example is ‘iterator invalidation’, which happens when you try to mutate a collection that you’re iterating over. Rust’s borrow checker prevents this from happening:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">v {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-411">This prints out one through three. As we iterate through the vector, we’re only given references to the elements. And <code>v</code> is itself borrowed as immutable, which means we can’t change it while we’re iterating:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">v {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
    v.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">34</span><span style="color:#323232;">);
}
</span></pre><p id = "para-412">Here’s the error:</p>
<pre><span style="color:#323232;">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</span></pre><p id = "para-413">We can’t modify <code>v</code> because it’s borrowed by the loop.</p>
<h4 id = "link-90">Use after free</h4>
<p id = "para-414">References must not live longer than the resource they refer to. Rust will check the scopes of your references to ensure that this is true.</p>
<p id = "para-415">If Rust didn’t check this property, we could accidentally use a reference which was invalid. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">;
{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x;
}

println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
</span></pre><p id = "para-416">We get this error:</p>
<pre><span style="color:#323232;">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</span></pre><p id = "para-417">In other words, <code>y</code> is only valid for the scope where <code>x</code> exists. As soon as <code>x</code> goes away, it becomes invalid to refer to it. As such, the error says that the borrow ‘doesn’t live long enough’ because it’s not valid for the right amount of time.</p>
<p id = "para-418">The same problem occurs when the reference is declared <em>before</em> the variable it refers to. This is because resources within the same scope are freed in the opposite order they were declared:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x;

println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
</span></pre><p id = "para-419">We get this error:</p>
<pre><span style="color:#323232;">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</span></pre><p id = "para-420">In the above example, <code>y</code> is declared before <code>x</code>, meaning that <code>y</code> lives longer than <code>x</code>, which is not allowed.</p>

</div><div id = "chapter-17" class = "chapter">
  <h2 id = "link-91">Lifetimes</h2>
<p id = "para-421">This is the last of three sections presenting Rust’s ownership system. This is one of Rust’s most distinct and compelling features, with which Rust developers should become quite acquainted. Ownership is how Rust achieves its largest goal, memory safety. There are a few distinct concepts, each with its own chapter:</p>
<ul>
<li><a href = "#chapter-15">ownership</a>, the key concept</li>
<li><a href = "#chapter-16">borrowing</a>, and their associated feature ‘references’</li>
<li>lifetimes, which you’re reading now</li>
</ul>
<p id = "para-422">These three chapters are related, and in order. You’ll need all three to fully understand the ownership system.</p>
<h2 id = "link-92">Meta</h2>
<p id = "para-423">Before we get to the details, two important notes about the ownership system.</p>
<p id = "para-424">Rust has a focus on safety and speed. It accomplishes these goals through many ‘zero-cost abstractions’, which means that in Rust, abstractions cost as little as possible in order to make them work. The ownership system is a prime example of a zero-cost abstraction. All of the analysis we’ll talk about in this guide is <em>done at compile time</em>. You do not pay any run-time cost for any of these features.</p>
<p id = "para-425">However, this system does have a certain cost: learning curve. Many new users to Rust experience something we like to call ‘fighting with the borrow checker’, where the Rust compiler refuses to compile a program that the author thinks is valid. This often happens because the programmer’s mental model of how ownership should work doesn’t match the actual rules that Rust implements. You probably will experience similar things at first. There is good news, however: more experienced Rust developers report that once they work with the rules of the ownership system for a period of time, they fight the borrow checker less and less.</p>
<p id = "para-426">With that in mind, let’s learn about lifetimes.</p>
<h2 id = "link-93">Lifetimes</h2>
<p id = "para-427">Lending out a reference to a resource that someone else owns can be complicated. For example, imagine this set of operations:</p>
<ol>
<li>I acquire a handle to some kind of resource.</li>
<li>I lend you a reference to the resource.</li>
<li>I decide I’m done with the resource, and deallocate it, while you still have your reference.</li>
<li>You decide to use the resource.</li>
</ol>
<p id = "para-428">Uh oh! Your reference is pointing to an invalid resource. This is called a dangling pointer or ‘use after free’, when the resource is memory. A small example of such a situation would be:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> r;              </span><span style="font-style:italic;color:#969896;">// Introduce reference: `r`.
</span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;      </span><span style="font-style:italic;color:#969896;">// Introduce scoped value: `i`.
</span><span style="color:#323232;">    r </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">i;         </span><span style="font-style:italic;color:#969896;">// Store reference of `i` in `r`.
</span><span style="color:#323232;">}                   </span><span style="font-style:italic;color:#969896;">// `i` goes out of scope and is dropped.

</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, r);  </span><span style="font-style:italic;color:#969896;">// `r` still refers to `i`.
</span></pre><p id = "para-429">To fix this, we have to make sure that step four never happens after step three. In the small example above the Rust compiler is able to report the issue as it can see the lifetimes of the various values in the function.</p>
<p id = "para-430">When we have a function that takes arguments by reference the situation becomes more complex. Consider the following example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">skip_prefix</span><span style="color:#323232;">(line: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, prefix: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;str </span><span style="color:#323232;">{
    </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">   line
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> line </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;lang:en=Hello World!&quot;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> lang </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;en&quot;</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v;
{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">format!(</span><span style="color:#183691;">&quot;lang:</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">=&quot;</span><span style="color:#323232;">, lang);  </span><span style="font-style:italic;color:#969896;">// -+ `p` comes into scope.
</span><span style="color:#323232;">    v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">skip_prefix</span><span style="color:#323232;">(line, p.</span><span style="color:#62a35c;">as_str</span><span style="color:#323232;">());  </span><span style="font-style:italic;color:#969896;">//  |
</span><span style="color:#323232;">}                                       </span><span style="font-style:italic;color:#969896;">// -+ `p` goes out of scope.
</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-431">Here we have a function <code>skip_prefix</code> which takes two <code>&amp;str</code> references as parameters and returns a single <code>&amp;str</code> reference. We call it by passing in references to <code>line</code> and <code>p</code>: Two variables with different lifetimes. Now the safety of the <code>println!</code>-line depends on whether the reference returned by <code>skip_prefix</code> function references the still living <code>line</code> or the already dropped <code>p</code> string.</p>
<p id = "para-432">Because of the above ambiguity, Rust will refuse to compile the example code. To get it to compile we need to tell the compiler more about the lifetimes of the references. This can be done by making the lifetimes explicit in the function declaration:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">skip_prefix</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&#39;b</span><span style="color:#323232;">&gt;(line: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">, prefix: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;b str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str </span><span style="color:#323232;">{
    </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">   line
}
</span></pre><p id = "para-433">Let’s examine the changes without going too deep into the syntax for now - we’ll get to that later. The first change was adding the <code>&lt;’a, ’b&gt;</code> after the method name. This introduces two lifetime parameters: <code>’a</code> and <code>’b</code>. Next, each reference in the function signature was associated with one of the lifetime parameters by adding the lifetime name after the <code>&amp;</code>. This tells the compiler how the lifetimes between different references are related.</p>
<p id = "para-434">As a result the compiler is now able to deduce that the return value of <code>skip_prefix</code> has the same lifetime as the <code>line</code> parameter, which makes the <code>v</code> reference safe to use even after the <code>p</code> goes out of scope in the original example.</p>
<p id = "para-435">In addition to the compiler being able to validate the usage of <code>skip_prefix</code> return value, it can also ensure that the implementation follows the contract established by the function declaration. This is useful especially when you are implementing traits that are introduced <a href = "#chapter-26">later in the book</a>.</p>
<p id = "para-436"><b>Note</b> It’s important to understand that lifetime annotations are <em>descriptive</em>, not <em>prescriptive</em>. This means that how long a reference is valid is determined by the code, not by the annotations. The annotations, however, give information about lifetimes to the compiler that uses them to check the validity of references. The compiler can do so without annotations in simple cases, but needs the programmer’s support in complex scenarios.</p>
<h2 id = "link-94">Syntax</h2>
<p id = "para-437">The <code>’a</code> reads ‘the lifetime a’. Technically, every reference has some lifetime associated with it, but the compiler lets you elide (i.e. omit, see <a href = "src/#lifetime-elision">“Lifetime Elision”</a> below) them in common cases. Before we get to that, though, let’s look at a short example with explicit lifetimes:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(...)
</span></pre><p id = "para-438">We previously talked a little about <a href = "#chapter-9">function syntax</a>, but we didn’t discuss the <code>&lt;&gt;</code>s after a function’s name. A function can have ‘generic parameters’ between the <code>&lt;&gt;</code>s, of which lifetimes are one kind. We’ll discuss other kinds of generics <a href = "#chapter-25">later in the book</a>, but for now, let’s focus on the lifetimes aspect.</p>
<p id = "para-439">We use <code>&lt;&gt;</code> to declare our lifetimes. This says that <code>bar</code> has one lifetime, <code>’a</code>. If we had two reference parameters with different lifetimes, it would look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&#39;b</span><span style="color:#323232;">&gt;(...)
</span></pre><p id = "para-440">Then in our parameter list, we use the lifetimes we’ve named:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">...</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">)
</span></pre><p id = "para-441">If we wanted a <code>&amp;mut</code> reference, we’d do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">...</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut i32</span><span style="color:#323232;">)
</span></pre><p id = "para-442">If you compare <code>&amp;mut i32</code> to <code>&amp;’a mut i32</code>, they’re the same, it’s that the lifetime <code>’a</code> has snuck in between the <code>&amp;</code> and the <code>mut i32</code>. We read <code>&amp;mut i32</code> as ‘a mutable reference to an <code>i32</code>’ and <code>&amp;’a mut i32</code> as ‘a mutable reference to an <code>i32</code> with the lifetime <code>’a</code>’.</p>
<h2 id = "link-95">In <code>struct</code>s</h2>
<p id = "para-443">You’ll also need explicit lifetimes when working with <a href = "#chapter-19"><code>struct</code></a>s that contain references:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// This is the same as `let _y = 5; let y = &amp;_y;`.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Foo { x: y };

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, f.x);
}
</span></pre><p id = "para-444">As you can see, <code>struct</code>s can also have lifetimes. In a similar way to functions,</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
# x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
# }
</span></pre><p id = "para-445">declares a lifetime, and</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
# }
</span></pre><p id = "para-446">uses it. So why do we need a lifetime here? We need to ensure that any reference to a <code>Foo</code> cannot outlive the reference to an <code>i32</code> it contains.</p>
<h3 id = "link-96"><code>impl</code> blocks</h3>
<p id = "para-447">Let’s implement a method on <code>Foo</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">x</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32 </span><span style="color:#323232;">{ self.x }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#0086b3;">5</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// This is the same as `let _y = 5; let y = &amp;_y;`.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Foo { x: y };

    println!(</span><span style="color:#183691;">&quot;x is: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, f.</span><span style="color:#62a35c;">x</span><span style="color:#323232;">());
}
</span></pre><p id = "para-448">As you can see, we need to declare a lifetime for <code>Foo</code> in the <code>impl</code> line. We repeat <code>’a</code> twice, like on functions: <code>impl&lt;’a&gt;</code> defines a lifetime <code>’a</code>, and <code>Foo&lt;’a&gt;</code> uses it.</p>
<h3 id = "link-97">Multiple lifetimes</h3>
<p id = "para-449">If you have multiple references, you can use the same lifetime multiple times:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">x_or_y</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">    x
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-450">This says that <code>x</code> and <code>y</code> both are alive for the same scope, and that the return value is also alive for that scope. If you wanted <code>x</code> and <code>y</code> to have different lifetimes, you can use multiple lifetime parameters:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">x_or_y</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&#39;b</span><span style="color:#323232;">&gt;(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;b str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">    x
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-451">In this example, <code>x</code> and <code>y</code> have different valid scopes, but the return value has the same lifetime as <code>x</code>.</p>
<h3 id = "link-98">Thinking in scopes</h3>
<p id = "para-452">A way to think about lifetimes is to visualize the scope that a reference is valid for. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#0086b3;">5</span><span style="color:#323232;">;     </span><span style="font-style:italic;color:#969896;">// -+ `y` comes into scope.
                    //  |
    // Stuff...     //  |
                    //  |
</span><span style="color:#323232;">}                   </span><span style="font-style:italic;color:#969896;">// -+ `y` goes out of scope.
</span></pre><p id = "para-453">Adding in our <code>Foo</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#0086b3;">5</span><span style="color:#323232;">;           </span><span style="font-style:italic;color:#969896;">// -+ `y` comes into scope.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Foo { x: y }; </span><span style="font-style:italic;color:#969896;">// -+ `f` comes into scope.
                          //  |
    // Stuff...           //  |
                          //  |
</span><span style="color:#323232;">}                         </span><span style="font-style:italic;color:#969896;">// -+ `f` and `y` go out of scope.
</span></pre><p id = "para-454">Our <code>f</code> lives within the scope of <code>y</code>, so everything works. What if it didn’t? This code won’t work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x;                    </span><span style="font-style:italic;color:#969896;">// -+ `x` comes into scope.
                              //  |
    </span><span style="color:#323232;">{                         </span><span style="font-style:italic;color:#969896;">//  |
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#0086b3;">5</span><span style="color:#323232;">;           </span><span style="font-style:italic;color:#969896;">// ---+ `y` comes into scope.
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Foo { x: y }; </span><span style="font-style:italic;color:#969896;">// ---+ `f` comes into scope.
</span><span style="color:#323232;">        x </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">f.x;             </span><span style="font-style:italic;color:#969896;">//  | | This causes an error.
    </span><span style="color:#323232;">}                         </span><span style="font-style:italic;color:#969896;">// ---+ `f` and y go out of scope.
                              //  |
    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);        </span><span style="font-style:italic;color:#969896;">//  |
</span><span style="color:#323232;">}                             </span><span style="font-style:italic;color:#969896;">// -+ `x` goes out of scope.
</span></pre><p id = "para-455">Whew! As you can see here, the scopes of <code>f</code> and <code>y</code> are smaller than the scope of <code>x</code>. But when we do <code>x = &amp;f.x</code>, we make <code>x</code> a reference to something that’s about to go out of scope.</p>
<p id = "para-456">Named lifetimes are a way of giving these scopes a name. Giving something a name is the first step towards being able to talk about it.</p>
<h3 id = "link-99">’static</h3>
<p id = "para-457">The lifetime named ‘static’ is a special lifetime. It signals that something has the lifetime of the entire program. Most Rust programmers first come across <code>’static</code> when dealing with strings:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str = </span><span style="color:#183691;">&quot;Hello, world.&quot;</span><span style="color:#323232;">;
</span></pre><p id = "para-458">String literals have the type <code>&amp;’static str</code> because the reference is always alive: they are baked into the data segment of the final binary. Another example are globals:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">static </span><span style="color:#0086b3;">FOO</span><span style="color:#323232;">: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static i32 = &amp;</span><span style="color:#0086b3;">FOO</span><span style="color:#323232;">;
</span></pre><p id = "para-459">This adds an <code>i32</code> to the data segment of the binary, and <code>x</code> is a reference to it.</p>
<h3 id = "link-100">Lifetime Elision</h3>
<p id = "para-460">Rust supports powerful local type inference in the bodies of functions, but it deliberately does not perform any reasoning about types for item signatures. However, for ergonomic reasons, a very restricted secondary inference algorithm called “lifetime elision” does apply when judging lifetimes. Lifetime elision is concerned solely with inferring lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision acts as a shorthand for writing an item signature, while not hiding away the actual types involved as full local inference would if applied to it.</p>
<p id = "para-461">When talking about lifetime elision, we use the terms <em>input lifetime</em> and <em>output lifetime</em>. An <em>input lifetime</em> is a lifetime associated with a parameter of a function, and an <em>output lifetime</em> is a lifetime associated with the return value of a function. For example, this function has an input lifetime:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(bar: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">)
</span></pre><p id = "para-462">This one has an output lifetime:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str
</span></pre><p id = "para-463">This one has a lifetime in both positions:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(bar: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str
</span></pre><p id = "para-464">Here are the three rules:</p>
<ul>
<li><p id = "para-465">Each elided lifetime in a function’s arguments becomes a distinct lifetime parameter.</p>
</li>
<li><p id = "para-466">If there is exactly one input lifetime, elided or not, that lifetime is assigned to all elided lifetimes in the return values of that function.</p>
</li>
<li><p id = "para-467">If there are multiple input lifetimes, but one of them is <code>&amp;self</code> or <code>&amp;mut self</code>, the lifetime of <code>self</code> is assigned to all elided output lifetimes.</p>
</li>
</ul>
<p id = "para-468">Otherwise, it is an error to elide an output lifetime.</p>
<h4 id = "link-101">Examples</h4>
<p id = "para-469">Here are some examples of functions with elided lifetimes. We’ve paired each example of an elided lifetime with its expanded form.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// expanded

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">debug</span><span style="color:#323232;">(lvl: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">, s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">debug</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(lvl: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">, s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// expanded
</span></pre><p id = "para-470">In the preceding example, <code>lvl</code> doesn’t need a lifetime because it’s not a reference (<code>&amp;</code>). Only things relating to references (such as a <code>struct</code> which contains a reference) need lifetimes.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">substr</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, until: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">substr</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">, until: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// expanded

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">get_str</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// ILLEGAL, no inputs

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">frob</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, t: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// ILLEGAL, two inputs
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">frob</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&#39;b</span><span style="color:#323232;">&gt;(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">, t: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;b str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// Expanded: Output lifetime is ambiguous

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">get_mut</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> T; </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">get_mut</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut </span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut</span><span style="color:#323232;"> T; </span><span style="font-style:italic;color:#969896;">// expanded

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">args</span><span style="color:#323232;">&lt;T: ToCStr&gt;(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self, args: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[T]) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> Command; </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">args</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&#39;b</span><span style="color:#323232;">, T: ToCStr&gt;(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut </span><span style="color:#323232;">self, args: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;b</span><span style="color:#323232;"> [T]) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut</span><span style="color:#323232;"> Command; </span><span style="font-style:italic;color:#969896;">// expanded

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">new</span><span style="color:#323232;">(buf: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> [</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">]) -&gt; BufWriter; </span><span style="font-style:italic;color:#969896;">// elided
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">new</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;(buf: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut</span><span style="color:#323232;"> [</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">]) -&gt; BufWriter&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt;; </span><span style="font-style:italic;color:#969896;">// expanded
</span></pre>
</div><div id = "chapter-18" class = "chapter">
  <h2 id = "link-102">Mutability</h2>
<p id = "para-471">Mutability, the ability to change something, works a bit differently in Rust than in other languages. The first aspect of mutability is its non-default status:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// Error!
</span></pre><p id = "para-472">We can introduce mutability with the <code>mut</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// No problem!
</span></pre><p id = "para-473">This is a mutable <a href = "#chapter-8">variable binding</a>. When a binding is mutable, it means you’re allowed to change what the binding points to. So in the above example, it’s not so much that the value at <code>x</code> is changing, but that the binding changed from one <code>i32</code> to another.</p>
<p id = "para-474">You can also create a <a href = "#chapter-16">reference</a> to it, using <code>&amp;x</code>, but if you want to use the reference to change it, you will need a mutable reference:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;
</span></pre><p id = "para-475"><code>y</code> is an immutable binding to a mutable reference, which means that you can’t bind ‘y’ to something else (<code>y = &amp;mut z</code>), but <code>y</code> can be used to bind <code>x</code> to something else (<code>*y = 5</code>). A subtle distinction.</p>
<p id = "para-476">Of course, if you need both:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;
</span></pre><p id = "para-477">Now <code>y</code> can be bound to another value, and the value it’s referencing can be changed.</p>
<p id = "para-478">It’s important to note that <code>mut</code> is part of a <a href = "#chapter-22">pattern</a>, so you can do things like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> x, y) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-479">Note that here, the <code>x</code> is mutable, but not the <code>y</code>.</p>
<h2 id = "link-103">Interior vs. Exterior Mutability</h2>
<p id = "para-480">However, when we say something is ‘immutable’ in Rust, that doesn’t mean that it’s not able to be changed: we are referring to its ‘exterior mutability’ that in this case is immutable. Consider, for example, <a href = "src/../../std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::Arc;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Arc::new(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
</span></pre><p id = "para-481">When we call <code>clone()</code>, the <code>Arc&lt;T&gt;</code> needs to update the reference count. Yet we’ve not used any <code>mut</code>s here, <code>x</code> is an immutable binding, and we didn’t take <code>&amp;mut 5</code> or anything. So what gives?</p>
<p id = "para-482">To understand this, we have to go back to the core of Rust’s guiding philosophy, memory safety, and the mechanism by which Rust guarantees it, the <a href = "#chapter-15">ownership</a> system, and more specifically, <a href = "#chapter-16">borrowing</a>:</p>
<blockquote><p id = "para-483">You may have one or the other of these two kinds of borrows, but not both at the same time:</p>
<ul>
<li>one or more references (<code>&amp;T</code>) to a resource,</li>
<li>exactly one mutable reference (<code>&amp;mut T</code>).</li>
</ul>
</blockquote>
<p id = "para-484">So, that’s the real definition of ‘immutability’: is this safe to have two pointers to? In <code>Arc&lt;T&gt;</code>’s case, yes: the mutation is entirely contained inside the structure itself. It’s not user facing. For this reason, it hands out <code>&amp;T</code> with <code>clone()</code>. If it handed out <code>&amp;mut T</code>s, though, that would be a problem.</p>
<p id = "para-485">Other types, like the ones in the <a href = "src/../../std/cell/index.html"><code>std::cell</code></a> module, have the opposite: interior mutability. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cell::RefCell;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">RefCell::new(</span><span style="color:#0086b3;">42</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x.</span><span style="color:#62a35c;">borrow_mut</span><span style="color:#323232;">();
</span></pre><p id = "para-486">RefCell hands out <code>&amp;mut</code> references to what’s inside of it with the <code>borrow_mut()</code> method. Isn’t that dangerous? What if we do:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cell::RefCell;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">RefCell::new(</span><span style="color:#0086b3;">42</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x.</span><span style="color:#62a35c;">borrow_mut</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x.</span><span style="color:#62a35c;">borrow_mut</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">(y, z);
</span></pre><p id = "para-487">This will in fact panic, at runtime. This is what <code>RefCell</code> does: it enforces Rust’s borrowing rules at runtime, and <code>panic!</code>s if they’re violated. This allows us to get around another aspect of Rust’s mutability rules. Let’s talk about it first.</p>
<h3 id = "link-104">Field-level mutability</h3>
<p id = "para-488">Mutability is a property of either a borrow (<code>&amp;mut</code>) or a binding (<code>let mut</code>). This means that, for example, you cannot have a <a href = "#chapter-19"><code>struct</code></a> with some fields mutable and some immutable:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    mut y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-style:italic;color:#969896;">// Nope.
</span><span style="color:#323232;">}
</span></pre><p id = "para-489">The mutability of a struct is in its binding:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">6 </span><span style="color:#323232;">};

a.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">6 </span><span style="color:#323232;">};

b.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// Error: cannot assign to immutable field `b.x`.
</span></pre><p id = "para-490">However, by using <a href = "src/../../std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>, you can emulate field-level mutability:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cell::Cell;

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: Cell&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, y: Cell::new(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">) };

point.y.</span><span style="color:#62a35c;">set</span><span style="color:#323232;">(</span><span style="color:#0086b3;">7</span><span style="color:#323232;">);

println!(</span><span style="color:#183691;">&quot;y: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, point.y);
</span></pre><p id = "para-491">This will print <code>y: Cell { value: 7 }</code>. We’ve successfully updated <code>y</code>.</p>

</div><div id = "chapter-19" class = "chapter">
  <h2 id = "link-105">Structs</h2>
<p id = "para-492"><code>struct</code>s are a way of creating more complex data types. For example, if we were doing calculations involving coordinates in 2D space, we would need both an <code>x</code> and a <code>y</code> value:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin_x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin_y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span></pre><p id = "para-493">A <code>struct</code> lets us combine these two into a single, unified datatype with <code>x</code> and <code>y</code> as field labels:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}; </span><span style="font-style:italic;color:#969896;">// origin: Point

    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;The origin is at (</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">)&quot;</span><span style="color:#323232;">, origin.x, origin.y);
}
</span></pre><p id = "para-494">There’s a lot going on here, so let’s break it down. We declare a <code>struct</code> with the <code>struct</code> keyword, and then with a name. By convention, <code>struct</code>s begin with a capital letter and are camel cased: <code>PointInSpace</code>, not <code>Point_In_Space</code>.</p>
<p id = "para-495">We can create an instance of our <code>struct</code> via <code>let</code>, as usual, but we use a <code>key: value</code> style syntax to set each field. The order doesn’t need to be the same as in the original declaration.</p>
<p id = "para-496">Finally, because fields have names, we can access them through dot notation: <code>origin.x</code>.</p>
<p id = "para-497">The values in <code>struct</code>s are immutable by default, like other bindings in Rust. Use <code>mut</code> to make them mutable:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};

    point.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;The point is at (</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">)&quot;</span><span style="color:#323232;">, point.x, point.y);
}
</span></pre><p id = "para-498">This will print <code>The point is at (5, 0)</code>.</p>
<p id = "para-499">Rust does not support field mutability at the language level, so you cannot write something like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    mut x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-style:italic;color:#969896;">// This causes an error.
    </span><span style="color:#323232;">y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}
</span></pre><p id = "para-500">Mutability is a property of the binding, not of the structure itself. If you’re used to field-level mutability, this may seem strange at first, but it significantly simplifies things. It even lets you make things mutable on a temporary basis:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};

    point.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> point; </span><span style="font-style:italic;color:#969896;">// `point` is now immutable.
</span><span style="color:#323232;">
    point.y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// This causes an error.
</span><span style="color:#323232;">}
</span></pre><p id = "para-501">Your structure can still contain <code>&amp;mut</code> references, which will let you do some kinds of mutation:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">PointRef&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a mut i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};

    {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> r </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> PointRef { x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> point.x, y: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> point.y };

        </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">r.x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
        </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">r.y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
    }

    assert_eq!(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, point.x);
    assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, point.y);
}
</span></pre><p id = "para-502">Initialization of a data structure (struct, enum, union) can be simplified when fields of the data structure are initialized with variables of the same names as the fields.</p>
<pre><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Person&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; {
    name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">,
    age: </span><span style="font-weight:bold;color:#a71d5d;">u8
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-style:italic;color:#969896;">// Create struct with field init shorthand
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Peter&quot;</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> age </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">27</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> peter </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Person { name, age };

    </span><span style="font-style:italic;color:#969896;">// Debug-print struct
    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, peter);
}
</span></pre><h2 id = "link-106">Update syntax</h2>
<p id = "para-503">A <code>struct</code> can include <code>..</code> to indicate that you want to use a copy of some other <code>struct</code> for some of the values. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point3d {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    z: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point3d { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, z: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};
point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point3d { y: </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;"> point };
</span></pre><p id = "para-504">This gives <code>point</code> a new <code>y</code>, but keeps the old <code>x</code> and <code>z</code> values. It doesn’t have to be the same <code>struct</code> either, you can use this syntax when making new ones, and it will copy the values you don’t specify:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Point3d {
#     x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
#     y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
#     z: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
# }
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point3d { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, z: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point3d { z: </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, x: </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;"> origin };
</span></pre><h2 id = "link-107">Tuple structs</h2>
<p id = "para-505">Rust has another data type that’s like a hybrid between a <a href = "#chapter-10">tuple</a> and a <code>struct</code>, called a ‘tuple struct’. Tuple structs have a name, but their fields don’t. They are declared with the <code>struct</code> keyword, and then with a name followed by a tuple:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Color(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> black </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Color(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">);
</span></pre><p id = "para-506">Here, <code>black</code> and <code>origin</code> are not the same type, even though they contain the same values.</p>
<p id = "para-507">The members of a tuple struct may be accessed by dot notation or destructuring <code>let</code>, just like regular tuples:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Color(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Point(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> black </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Color(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> black_r </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> black.</span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> Point(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">, origin_y, origin_z) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> origin;
</span></pre><p id = "para-508">Patterns like <code>Point(_, origin_y, origin_z)</code> are also used in <a href = "#chapter-21">match expressions</a>.</p>
<p id = "para-509">One case when a tuple struct is very useful is when it has only one element. We call this the ‘newtype’ pattern, because it allows you to create a new type that is distinct from its contained value and also expresses its own semantic meaning:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Inches(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> length </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Inches(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> Inches(integer_length) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> length;
println!(</span><span style="color:#183691;">&quot;length is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> inches&quot;</span><span style="color:#323232;">, integer_length);
</span></pre><p id = "para-510">As above, you can extract the inner integer type through a destructuring <code>let</code>. In this case, the <code>let Inches(integer_length)</code> assigns <code>10</code> to <code>integer_length</code>. We could have used dot notation to do the same thing:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Inches(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> length </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Inches(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> integer_length </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> length.</span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
</span></pre><p id = "para-511">It’s always possible to use a <code>struct</code> instead of a tuple struct, and can be clearer. We could write <code>Color</code> and <code>Point</code> like this instead:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Color {
    red: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    blue: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    green: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    z: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}
</span></pre><p id = "para-512">Good names are important, and while values in a tuple struct can be referenced with dot notation as well, a <code>struct</code> gives us actual names, rather than positions.</p>
<h2 id = "link-108">Unit-like structs</h2>
<p id = "para-513">You can define a <code>struct</code> with no members at all:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Electron {} </span><span style="font-style:italic;color:#969896;">// Use empty braces...
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Proton;     </span><span style="font-style:italic;color:#969896;">// ...or just a semicolon.

// Use the same notation when creating an instance.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Electron {};
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Proton;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Electron; </span><span style="font-style:italic;color:#969896;">// Error
</span></pre><p id = "para-514">Such a <code>struct</code> is called ‘unit-like’ because it resembles the empty tuple, <code>()</code>, sometimes called ‘unit’. Like a tuple struct, it defines a new type.</p>
<p id = "para-515">This is rarely useful on its own (although sometimes it can serve as a marker type), but in combination with other features, it can become useful. For instance, a library may ask you to create a structure that implements a certain <a href = "#chapter-26">trait</a> to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like <code>struct</code>.</p>

</div><div id = "chapter-20" class = "chapter">
  <h2 id = "link-109">Enums</h2>
<p id = "para-516">An <code>enum</code> in Rust is a type that represents data that is one of several possible variants. Each variant in the <code>enum</code> can optionally have data associated with it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Message {
    Quit,
    ChangeColor(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">),
    Move { x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">},
    Write(</span><span style="color:#0086b3;">String</span><span style="color:#323232;">),
}
</span></pre><p id = "para-517">The syntax for defining variants resembles the syntaxes used to define structs: you can have variants with no data (like unit-like structs), variants with named data, and variants with unnamed data (like tuple structs). Unlike separate struct definitions, however, an <code>enum</code> is a single type. A value of the enum can match any of the variants. For this reason, an enum is sometimes called a ‘sum type’: the set of possible values of the enum is the sum of the sets of possible values for each variant.</p>
<p id = "para-518">We use the <code>::</code> syntax to use the name of each variant: they’re scoped by the name of the <code>enum</code> itself. This allows both of these to work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">Message {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">     Move { x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">},
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Message </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Message::Move { x: </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">4 </span><span style="color:#323232;">};

</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">BoardGameTurn {
    Move { squares: </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">},
    Pass,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: BoardGameTurn </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">BoardGameTurn::Move { squares: </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">};
</span></pre><p id = "para-519">Both variants are named <code>Move</code>, but since they’re scoped to the name of the enum, they can both be used without conflict.</p>
<p id = "para-520">A value of an <code>enum</code> type contains information about which variant it is, in addition to any data associated with that variant. This is sometimes referred to as a ‘tagged union’, since the data includes a ‘tag’ indicating what type it is. The compiler uses this information to enforce that you’re accessing the data in the enum safely. For instance, you can’t simply try to destructure a value as if it were one of the possible variants:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">process_color_change</span><span style="color:#323232;">(msg: Message) {
    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">Message::ChangeColor(r, g, b) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> msg; </span><span style="font-style:italic;color:#969896;">// This causes a compile-time error.
</span><span style="color:#323232;">}
</span></pre><p id = "para-521">Not supporting these operations may seem rather limiting, but it’s a limitation which we can overcome. There are two ways: by implementing equality ourselves, or by pattern matching variants with <a href = "#chapter-21"><code>match</code></a> expressions, which you’ll learn in the next section. We don’t know enough about Rust to implement equality yet, but we’ll find out in the <a href = "#chapter-26"><code>traits</code></a> section.</p>
<h2 id = "link-110">Constructors as functions</h2>
<p id = "para-522">An <code>enum</code> constructor can also be used like a function. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">Message {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> Write(</span><span style="color:#0086b3;">String</span><span style="color:#323232;">),
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> m </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Message::Write(</span><span style="color:#183691;">&quot;Hello, world&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">());
</span></pre><p id = "para-523">is the same as</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">Message {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> Write(</span><span style="color:#0086b3;">String</span><span style="color:#323232;">),
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: String) -&gt; Message {
    Message::Write(x)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Hello, world&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">());
</span></pre><p id = "para-524">This is not immediately useful to us, but when we get to <a href = "#chapter-30"><code>closures</code></a>, we’ll talk about passing functions as arguments to other functions. For example, with <a href = "#chapter-50"><code>iterators</code></a>, we can do this to convert a vector of <code>String</code>s into a vector of <code>Message::Write</code>s:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">Message {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> Write(</span><span style="color:#0086b3;">String</span><span style="color:#323232;">),
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">(), </span><span style="color:#183691;">&quot;World&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v1: Vec&lt;Message&gt; </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v.</span><span style="color:#62a35c;">into_iter</span><span style="color:#323232;">().</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(Message::Write).</span><span style="color:#62a35c;">collect</span><span style="color:#323232;">();
</span></pre>
</div><div id = "chapter-21" class = "chapter">
  <h2 id = "link-111">Match</h2>
<p id = "para-525">Often, a simple <a href = "#chapter-12"><code>if</code></a>/<code>else</code> isn’t enough, because you have more than two possible options. Also, conditions can get quite complex. Rust has a keyword, <code>match</code>, that allows you to replace complicated <code>if</code>/<code>else</code> groupings with something more powerful. Check it out:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;one&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;two&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;three&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">4 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;four&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;five&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;something else&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-526"><code>match</code> takes an expression and then branches based on its value. Each ‘arm’ of the branch is of the form <code>val =&gt; expression</code>. When the value matches, that arm’s expression will be evaluated. It’s called <code>match</code> because of the term ‘pattern matching’, which <code>match</code> is an implementation of. There’s a <a href = "#chapter-22">separate section on patterns</a> that covers all the patterns that are possible here.</p>
<p id = "para-527">One of the many advantages of <code>match</code> is it enforces ‘exhaustiveness checking’. For example if we remove the last arm with the underscore <code>_</code>, the compiler will give us an error:</p>
<pre><span style="color:#323232;">error: non-exhaustive patterns: `_` not covered
</span></pre><p id = "para-528">Rust is telling us that we forgot some value. The compiler infers from <code>x</code> that it can have any 32bit integer value; for example -2,147,483,648 to 2,147,483,647. The <code>_</code> acts as a ‘catch-all’, and will catch all possible values that <em>aren’t</em> specified in an arm of <code>match</code>. As you can see in the previous example, we provide <code>match</code> arms for integers 1-5, if <code>x</code> is 6 or any other value, then it is caught by <code>_</code>.</p>
<p id = "para-529"><code>match</code> is also an expression, which means we can use it on the right-hand side of a <code>let</code> binding or directly where an expression is used:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> number </span><span style="font-weight:bold;color:#a71d5d;">= match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#183691;">&quot;one&quot;</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#183691;">&quot;two&quot;</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#183691;">&quot;three&quot;</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">4 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#183691;">&quot;four&quot;</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#183691;">&quot;five&quot;</span><span style="color:#323232;">,
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#183691;">&quot;something else&quot;</span><span style="color:#323232;">,
};
</span></pre><p id = "para-530">Sometimes it’s a nice way of converting something from one type to another; in this example the integers are converted to <code>String</code>.</p>
<h2 id = "link-112">Matching on enums</h2>
<p id = "para-531">Another important use of the <code>match</code> keyword is to process the possible variants of an enum:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Message {
    Quit,
    ChangeColor(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">),
    Move { x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">},
    Write(</span><span style="color:#0086b3;">String</span><span style="color:#323232;">),
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">quit</span><span style="color:#323232;">() { </span><span style="font-style:italic;color:#969896;">/* ... */ </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">change_color</span><span style="color:#323232;">(r: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, g: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, b: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { </span><span style="font-style:italic;color:#969896;">/* ... */ </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">move_cursor</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { </span><span style="font-style:italic;color:#969896;">/* ... */ </span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">process_message</span><span style="color:#323232;">(msg: Message) {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> msg {
        Message::Quit </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#62a35c;">quit</span><span style="color:#323232;">(),
        Message::ChangeColor(r, g, b) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#62a35c;">change_color</span><span style="color:#323232;">(r, g, b),
        Message::Move { x, y: new_name_for_y } </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#62a35c;">move_cursor</span><span style="color:#323232;">(x, new_name_for_y),
        Message::Write(s) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, s),
    };
}
</span></pre><p id = "para-532">Again, the Rust compiler checks exhaustiveness, so it demands that you have a match arm for every variant of the enum. If you leave one off, it will give you a compile-time error unless you use <code>_</code> or provide all possible arms.</p>
<p id = "para-533">Unlike the previous uses of <code>match</code>, you can’t use the normal <code>if</code> statement to do this. You can use the <a href = "#chapter-28"><code>if let</code></a> statement, which can be seen as an abbreviated form of <code>match</code>.</p>

</div><div id = "chapter-22" class = "chapter">
  <h2 id = "link-113">Patterns</h2>
<p id = "para-534">Patterns are quite common in Rust. We use them in <a href = "#chapter-8">variable bindings</a>, <a href = "#chapter-21">match expressions</a>, and other places, too. Let’s go on a whirlwind tour of all of the things patterns can do!</p>
<p id = "para-535">A quick refresher: you can match against literals directly, and <code>_</code> acts as an ‘any’ case:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;one&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;two&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;three&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-536">This prints <code>one</code>.</p>
<p id = "para-537">It’s possible to create a binding for the value in the any case:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    y </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y),
}
</span></pre><p id = "para-538">This prints:</p>
<pre><span style="color:#323232;">x: 1 y: 1
</span></pre><p id = "para-539">Note it is an error to have both a catch-all <code>_</code> and a catch-all binding in the same match block:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    y </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, y),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">), </span><span style="font-style:italic;color:#969896;">// this causes an error as it is unreachable
</span><span style="color:#323232;">}
</span></pre><p id = "para-540">There’s one pitfall with patterns: like anything that introduces a new binding, they introduce shadowing. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;c&#39;</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> c {
    x </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> c: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x, c),
}

println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x)
</span></pre><p id = "para-541">This prints:</p>
<pre><span style="color:#323232;">x: c c: c
x: 1
</span></pre><p id = "para-542">In other words, <code>x =&gt;</code> matches the pattern and introduces a new binding named <code>x</code>. This new binding is in scope for the match arm and takes on the value of <code>c</code>. Notice that the value of <code>x</code> outside the scope of the match has no bearing on the value of <code>x</code> within it. Because we already have a binding named <code>x</code>, this new <code>x</code> shadows it.</p>
<h2 id = "link-114">Multiple patterns</h2>
<p id = "para-543">You can match multiple patterns with <code>|</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;one or two&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;three&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-544">This prints <code>one or two</code>.</p>
<h2 id = "link-115">Destructuring</h2>
<p id = "para-545">If you have a compound data type, like a <a href = "#chapter-19"><code>struct</code></a>, you can destructure it inside of a pattern:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> origin {
    Point { x, y } </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;(</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">,</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">)&quot;</span><span style="color:#323232;">, x, y),
}
</span></pre><p id = "para-546">We can use <code>:</code> to give a value a different name.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> origin {
    Point { x: x1, y: y1 } </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;(</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">,</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">)&quot;</span><span style="color:#323232;">, x1, y1),
}
</span></pre><p id = "para-547">If we only care about some of the values, we don’t have to give them all names:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">3 </span><span style="color:#323232;">};

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> point {
    Point { x, </span><span style="font-weight:bold;color:#a71d5d;">.. </span><span style="color:#323232;">} </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x),
}
</span></pre><p id = "para-548">This prints <code>x is 2</code>.</p>
<p id = "para-549">You can do this kind of match on any member, not only the first:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> point </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">3 </span><span style="color:#323232;">};

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> point {
    Point { y, </span><span style="font-weight:bold;color:#a71d5d;">.. </span><span style="color:#323232;">} </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;y is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y),
}
</span></pre><p id = "para-550">This prints <code>y is 3</code>.</p>
<p id = "para-551">This ‘destructuring’ behavior works on any compound data type, like <a href = "#chapter-10">tuples</a> or <a href = "#chapter-20">enums</a>.</p>
<h2 id = "link-116">Ignoring bindings</h2>
<p id = "para-552">You can use <code>_</code> in a pattern to disregard the type and value. For example, here’s a <code>match</code> against a <code>Result&lt;T, E&gt;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> some_value: Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;There was an error&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> some_value {
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(value) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;got a value: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, value),
    </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;an error occurred&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-553">In the first arm, we bind the value inside the <code>Ok</code> variant to <code>value</code>. But in the <code>Err</code> arm, we use <code>_</code> to disregard the specific error, and print a general error message.</p>
<p id = "para-554"><code>_</code> is valid in any pattern that creates a binding. This can be useful to ignore parts of a larger structure:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">coordinate</span><span style="color:#323232;">() -&gt; (</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-style:italic;color:#969896;">// Generate and return some sort of triple tuple.
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(x, </span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">, z) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">coordinate</span><span style="color:#323232;">();
</span></pre><p id = "para-555">Here, we bind the first and last element of the tuple to <code>x</code> and <code>z</code>, but ignore the middle element.</p>
<p id = "para-556">It’s worth noting that using <code>_</code> never binds the value in the first place, which means that the value does not move:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> tuple: (</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">, </span><span style="color:#0086b3;">String</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;five&quot;</span><span style="color:#323232;">));

</span><span style="font-style:italic;color:#969896;">// Here, tuple is moved, because the String moved:
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(x, _s) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tuple;

</span><span style="font-style:italic;color:#969896;">// The next line would give &quot;error: use of partially moved value: `tuple`&quot;.
// println!(&quot;Tuple is: {:?}&quot;, tuple);

// However,

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> tuple </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;five&quot;</span><span style="color:#323232;">));

</span><span style="font-style:italic;color:#969896;">// Here, tuple is _not_ moved, as the String was never moved, and u32 is Copy:
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(x, </span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tuple;

</span><span style="font-style:italic;color:#969896;">// That means this works:
</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Tuple is: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, tuple);
</span></pre><p id = "para-557">This also means that any temporary variables will be dropped at the end of the statement:</p>
<pre><span style="font-style:italic;color:#969896;">// Here, the String created will be dropped immediately, as it’s not bound:

</span><span style="font-weight:bold;color:#a71d5d;">let _ = </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;  hello  &quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">();
</span></pre><p id = "para-558">You can also use <code>..</code> in a pattern to disregard multiple values:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">OptionalTuple {
    Value(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">),
    Missing,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">OptionalTuple::Value(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">-</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    OptionalTuple::Value(</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Got a tuple!&quot;</span><span style="color:#323232;">),
    OptionalTuple::Missing </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;No such luck.&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-559">This prints <code>Got a tuple!</code>.</p>
<h2 id = "link-117">ref and ref mut</h2>
<p id = "para-560">If you want to get a <a href = "#chapter-16">reference</a>, use the <code>ref</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> r </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Got a reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, r),
}
</span></pre><p id = "para-561">This prints <code>Got a reference to 5</code>.</p>
<p id = "para-562">Here, the <code>r</code> inside the <code>match</code> has the type <code>&amp;i32</code>. In other words, the <code>ref</code> keyword <em>creates</em> a reference, for use in the pattern. If you need a mutable reference, <code>ref mut</code> will work in the same way:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="font-weight:bold;color:#a71d5d;">ref mut</span><span style="color:#323232;"> mr </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Got a mutable reference to </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, mr),
}
</span></pre><h2 id = "link-118">Ranges</h2>
<p id = "para-563">You can match a range of values with <code>...</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;one through five&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-564">This prints <code>one through five</code>.</p>
<p id = "para-565">Ranges are mostly used with integers and <code>char</code>s:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&#39;💅&#39;</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#183691;">&#39;a&#39; </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#183691;">&#39;j&#39; </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;early letter&quot;</span><span style="color:#323232;">),
    </span><span style="color:#183691;">&#39;k&#39; </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#183691;">&#39;z&#39; </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;late letter&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;something else&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-566">This prints <code>something else</code>.</p>
<h2 id = "link-119">Bindings</h2>
<p id = "para-567">You can bind values to names with <code>@</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    e </span><span style="font-weight:bold;color:#a71d5d;">@ </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;got a range element </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, e),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-568">This prints <code>got a range element 1</code>. This is useful when you want to do a complicated match of part of a data structure:</p>
<pre><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Person {
    name: Option&lt;String&gt;,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Steve&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Option&lt;Person&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(Person { name: </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(name) });
</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(Person { name: </span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">@ </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">), </span><span style="font-weight:bold;color:#a71d5d;">.. </span><span style="color:#323232;">}) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">{}
}
</span></pre><p id = "para-569">This prints <code>Some(“Steve”)</code>: we’ve bound the inner <code>name</code> to <code>a</code>.</p>
<p id = "para-570">If you use <code>@</code> with <code>|</code>, you need to make sure the name is bound in each part of the pattern:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    e </span><span style="font-weight:bold;color:#a71d5d;">@ </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">|</span><span style="color:#323232;"> e </span><span style="font-weight:bold;color:#a71d5d;">@ </span><span style="color:#0086b3;">8 </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#0086b3;">10 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;got a range element </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, e),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;anything&quot;</span><span style="color:#323232;">),
}
</span></pre><h2 id = "link-120">Guards</h2>
<p id = "para-571">You can introduce ‘match guards’ with <code>if</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">OptionalInt {
    Value(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">),
    Missing,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">OptionalInt::Value(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    OptionalInt::Value(i) </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Got an int bigger than five!&quot;</span><span style="color:#323232;">),
    OptionalInt::Value(</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Got an int!&quot;</span><span style="color:#323232;">),
    OptionalInt::Missing </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;No such luck.&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-572">This prints <code>Got an int!</code>.</p>
<p id = "para-573">If you’re using <code>if</code> with multiple patterns, the <code>if</code> applies to both sides:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">4</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">false</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">4 </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;yes&quot;</span><span style="color:#323232;">),
    </span><span style="font-weight:bold;color:#a71d5d;">_ =&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;no&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-574">This prints <code>no</code>, because the <code>if</code> applies to the whole of <code>4 | 5</code>, and not to only the <code>5</code>. In other words, the precedence of <code>if</code> behaves like this:</p>
<pre><span style="color:#323232;">(4 | 5) if y =&gt; ...
</span></pre><p id = "para-575">not this:</p>
<pre><span style="color:#323232;">4 | (5 if y) =&gt; ...
</span></pre><h2 id = "link-121">Mix and Match</h2>
<p id = "para-576">Whew! That’s a lot of different ways to match things, and they can all be mixed and matched, depending on what you’re doing:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    Foo { x: </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> name), y: </span><span style="color:#0086b3;">None </span><span style="color:#323232;">} </span><span style="font-weight:bold;color:#a71d5d;">=&gt; ...
</span><span style="color:#323232;">}
</span></pre><p id = "para-577">Patterns are very powerful. Make good use of them.</p>

</div><div id = "chapter-23" class = "chapter">
  <h2 id = "link-122">Method Syntax</h2>
<p id = "para-578">Functions are great, but if you want to call a bunch of them on some data, it can be awkward. Consider this code:</p>
<pre><span style="color:#62a35c;">baz</span><span style="color:#323232;">(</span><span style="color:#62a35c;">bar</span><span style="color:#323232;">(foo));
</span></pre><p id = "para-579">We would read this left-to-right, and so we see ‘baz bar foo’. But this isn’t the order that the functions would get called in, that’s inside-out: ‘foo bar baz’. Wouldn’t it be nice if we could do this instead?</p>
<pre><span style="color:#323232;">foo.</span><span style="color:#62a35c;">bar</span><span style="color:#323232;">().</span><span style="color:#62a35c;">baz</span><span style="color:#323232;">();
</span></pre><p id = "para-580">Luckily, as you may have guessed with the leading question, you can! Rust provides the ability to use this ‘method call syntax’ via the <code>impl</code> keyword.</p>
<h2 id = "link-123">Method calls</h2>
<p id = "para-581">Here’s how it works:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Circle { x: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, radius: </span><span style="color:#0086b3;">2.0 </span><span style="color:#323232;">};
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
}
</span></pre><p id = "para-582">This will print <code>12.566371</code>.</p>
<p id = "para-583">We’ve made a <code>struct</code> that represents a circle. We then write an <code>impl</code> block, and inside it, define a method, <code>area</code>.</p>
<p id = "para-584">Methods take a special first parameter, of which there are three variants: <code>self</code>, <code>&amp;self</code>, and <code>&amp;mut self</code>. You can think of this first parameter as being the <code>foo</code> in <code>foo.bar()</code>. The three variants correspond to the three kinds of things <code>foo</code> could be: <code>self</code> if it’s a value on the stack, <code>&amp;self</code> if it’s a reference, and <code>&amp;mut self</code> if it’s a mutable reference. Because we took the <code>&amp;self</code> parameter to <code>area</code>, we can use it like any other parameter. Because we know it’s a <code>Circle</code>, we can access the <code>radius</code> like we would with any other <code>struct</code>.</p>
<p id = "para-585">We should default to using <code>&amp;self</code>, as you should prefer borrowing over taking ownership, as well as taking immutable references over mutable ones. Here’s an example of all three variants:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">reference</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) {
       println!(</span><span style="color:#183691;">&quot;taking self by reference!&quot;</span><span style="color:#323232;">);
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mutable_reference</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) {
       println!(</span><span style="color:#183691;">&quot;taking self by mutable reference!&quot;</span><span style="color:#323232;">);
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_ownership</span><span style="color:#323232;">(self) {
       println!(</span><span style="color:#183691;">&quot;taking ownership of self!&quot;</span><span style="color:#323232;">);
    }
}
</span></pre><p id = "para-586">You can use as many <code>impl</code> blocks as you’d like. The previous example could have also been written like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">reference</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) {
       println!(</span><span style="color:#183691;">&quot;taking self by reference!&quot;</span><span style="color:#323232;">);
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">mutable_reference</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) {
       println!(</span><span style="color:#183691;">&quot;taking self by mutable reference!&quot;</span><span style="color:#323232;">);
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_ownership</span><span style="color:#323232;">(self) {
       println!(</span><span style="color:#183691;">&quot;taking ownership of self!&quot;</span><span style="color:#323232;">);
    }
}
</span></pre><h2 id = "link-124">Chaining method calls</h2>
<p id = "para-587">So, now we know how to call a method, such as <code>foo.bar()</code>. But what about our original example, <code>foo.bar().baz()</code>? This is called ‘method chaining’. Let’s look at an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">grow</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, increment: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> increment }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Circle { x: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, radius: </span><span style="color:#0086b3;">2.0 </span><span style="color:#323232;">};
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> d </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> c.</span><span style="color:#62a35c;">grow</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2.0</span><span style="color:#323232;">).</span><span style="color:#62a35c;">area</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, d);
}
</span></pre><p id = "para-588">Check the return type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Circle;
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Circle {
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">grow</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, increment: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; Circle {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> Circle } }
</span></pre><p id = "para-589">We say we’re returning a <code>Circle</code>. With this method, we can grow a new <code>Circle</code> to any arbitrary size.</p>
<h2 id = "link-125">Associated functions</h2>
<p id = "para-590">You can also define associated functions that do not take a <code>self</code> parameter. Here’s a pattern that’s very common in Rust code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">new</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">, y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">, radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Circle::new(</span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2.0</span><span style="color:#323232;">);
}
</span></pre><p id = "para-591">This ‘associated function’ builds a new <code>Circle</code> for us. Note that associated functions are called with the <code>Struct::function()</code> syntax, rather than the <code>ref.method()</code> syntax. Some other languages call associated functions ‘static methods’.</p>
<h2 id = "link-126">Builder Pattern</h2>
<p id = "para-592">Let’s say that we want our users to be able to create <code>Circle</code>s, but we will allow them to only set the properties they care about. Otherwise, the <code>x</code> and <code>y</code> attributes will be <code>0.0</code>, and the <code>radius</code> will be <code>1.0</code>. Rust doesn’t have method overloading, named arguments, or variable arguments. We employ the builder pattern instead. It looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">CircleBuilder {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">CircleBuilder {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">new</span><span style="color:#323232;">() -&gt; CircleBuilder {
        CircleBuilder { x: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, radius: </span><span style="color:#0086b3;">1.0</span><span style="color:#323232;">, }
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">x</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self, coordinate: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> CircleBuilder {
        self.x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> coordinate;
        self
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">y</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self, coordinate: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> CircleBuilder {
        self.y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> coordinate;
        self
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">radius</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self, radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> CircleBuilder {
        self.radius </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> radius;
        self
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">finalize</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">CircleBuilder::new()
                .</span><span style="color:#62a35c;">x</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1.0</span><span style="color:#323232;">)
                .</span><span style="color:#62a35c;">y</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2.0</span><span style="color:#323232;">)
                .</span><span style="color:#62a35c;">radius</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2.0</span><span style="color:#323232;">)
                .</span><span style="color:#62a35c;">finalize</span><span style="color:#323232;">();

    println!(</span><span style="color:#183691;">&quot;area: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
    println!(</span><span style="color:#183691;">&quot;x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c.x);
    println!(</span><span style="color:#183691;">&quot;y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c.y);
}
</span></pre><p id = "para-593">What we’ve done here is make another <code>struct</code>, <code>CircleBuilder</code>. We’ve defined our builder methods on it. We’ve also defined our <code>area()</code> method on <code>Circle</code>. We also made one more method on <code>CircleBuilder</code>: <code>finalize()</code>. This method creates our final <code>Circle</code> from the builder. Now, we’ve used the type system to enforce our concerns: we can use the methods on <code>CircleBuilder</code> to constrain making <code>Circle</code>s in any way we choose.</p>

</div><div id = "chapter-24" class = "chapter">
  <h2 id = "link-127">Strings</h2>
<p id = "para-594">Strings are an important concept for any programmer to master. Rust’s string handling system is a bit different from other languages, due to its systems focus. Any time you have a data structure of variable size, things can get tricky, and strings are a re-sizable data structure. That being said, Rust’s strings also work differently than in some other systems languages, such as C.</p>
<p id = "para-595">Let’s dig into the details. A ‘string’ is a sequence of Unicode scalar values encoded as a stream of UTF-8 bytes. All strings are guaranteed to be a valid encoding of UTF-8 sequences. Additionally, unlike some systems languages, strings are not NUL-terminated and can contain NUL bytes.</p>
<p id = "para-596">Rust has two main types of strings: <code>&amp;str</code> and <code>String</code>. Let’s talk about <code>&amp;str</code> first. These are called ‘string slices’. A string slice has a fixed size, and cannot be mutated. It is a reference to a sequence of UTF-8 bytes.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> greeting </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello there.&quot;</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// greeting: &amp;&#39;static str
</span></pre><p id = "para-597"><code>“Hello there.”</code> is a string literal and its type is <code>&amp;’static str</code>. A string literal is a string slice that is statically allocated, meaning that it’s saved inside our compiled program, and exists for the entire duration it runs. The <code>greeting</code> binding is a reference to this statically allocated string. Any function expecting a string slice will also accept a string literal.</p>
<p id = "para-598">String literals can span multiple lines. There are two forms. The first will include the newline and the leading spaces:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;foo
    bar&quot;</span><span style="color:#323232;">;

assert_eq!(</span><span style="color:#183691;">&quot;foo</span><span style="color:#0086b3;">\n</span><span style="color:#183691;">    bar&quot;</span><span style="color:#323232;">, s);
</span></pre><p id = "para-599">The second, with a <code>\</code>, trims the spaces and the newline:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;foo\
    bar&quot;</span><span style="color:#323232;">;

assert_eq!(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">, s);
</span></pre><p id = "para-600">Note that you normally cannot access a <code>str</code> directly, but only through a <code>&amp;str</code> reference. This is because <code>str</code> is an unsized type which requires additional runtime information to be usable. For more information see the chapter on <a href = "#chapter-38">unsized types</a>.</p>
<p id = "para-601">Rust has more than only <code>&amp;str</code>s though. A <code>String</code> is a heap-allocated string. This string is growable, and is also guaranteed to be UTF-8. <code>String</code>s are commonly created by converting from a string slice using the <code>to_string</code> method.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// mut s: String
</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, s);

s.</span><span style="color:#62a35c;">push_str</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;, world.&quot;</span><span style="color:#323232;">);
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, s);
</span></pre><p id = "para-602"><code>String</code>s will coerce into <code>&amp;str</code> with an <code>&amp;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_slice</span><span style="color:#323232;">(slice: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;Got: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, slice);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
    </span><span style="color:#62a35c;">takes_slice</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">s);
}
</span></pre><p id = "para-603">This coercion does not happen for functions that accept one of <code>&amp;str</code>’s traits instead of <code>&amp;str</code>. For example, <a href = "src/../../std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> has a parameter of type <code>ToSocketAddrs</code>. A <code>&amp;str</code> is okay but a <code>String</code> must be explicitly converted using <code>&amp;*</code>.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::net::TcpStream;

TcpStream::connect(</span><span style="color:#183691;">&quot;192.168.0.1:3000&quot;</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// Parameter is of type &amp;str.

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> addr_string </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;192.168.0.1:3000&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
TcpStream::connect(</span><span style="font-weight:bold;color:#a71d5d;">&amp;*</span><span style="color:#323232;">addr_string); </span><span style="font-style:italic;color:#969896;">// Convert `addr_string` to &amp;str.
</span></pre><p id = "para-604">Viewing a <code>String</code> as a <code>&amp;str</code> is cheap, but converting the <code>&amp;str</code> to a <code>String</code> involves allocating memory. No reason to do that unless you have to!</p>
<h3 id = "link-128">Indexing</h3>
<p id = "para-605">Because strings are valid UTF-8, they do not support indexing:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;hello&quot;</span><span style="color:#323232;">;

println!(</span><span style="color:#183691;">&quot;The first letter of s is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, s[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">]); </span><span style="font-style:italic;color:#969896;">// ERROR!!!
</span></pre><p id = "para-606">Usually, access to a vector with <code>[]</code> is very fast. But, because each character in a UTF-8 encoded string can be multiple bytes, you have to walk over the string to find the nᵗʰ letter of a string. This is a significantly more expensive operation, and we don’t want to be misleading. Furthermore, ‘letter’ isn’t something defined in Unicode, exactly. We can choose to look at a string as individual bytes, or as codepoints:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hachiko </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;忠犬ハチ公&quot;</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> hachiko.</span><span style="color:#62a35c;">as_bytes</span><span style="color:#323232;">() {
    print!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, &quot;</span><span style="color:#323232;">, b);
}

println!(</span><span style="color:#183691;">&quot;&quot;</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> hachiko.</span><span style="color:#62a35c;">chars</span><span style="color:#323232;">() {
    print!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, &quot;</span><span style="color:#323232;">, c);
}

println!(</span><span style="color:#183691;">&quot;&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-607">This prints:</p>
<pre><span style="color:#323232;">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172,
忠, 犬, ハ, チ, 公,
</span></pre><p id = "para-608">As you can see, there are more bytes than <code>char</code>s.</p>
<p id = "para-609">You can get something similar to an index like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> hachiko </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;忠犬ハチ公&quot;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> dog </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> hachiko.</span><span style="color:#62a35c;">chars</span><span style="color:#323232;">().</span><span style="color:#62a35c;">nth</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// Kinda like `hachiko[1]`.
</span></pre><p id = "para-610">This emphasizes that we have to walk from the beginning of the list of <code>chars</code>.</p>
<h3 id = "link-129">Slicing</h3>
<p id = "para-611">You can get a slice of a string with the slicing syntax:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> dog </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;hachiko&quot;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hachi </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">dog[</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">5</span><span style="color:#323232;">];
</span></pre><p id = "para-612">But note that these are <em>byte</em> offsets, not <em>character</em> offsets. So this will fail at runtime:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> dog </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;忠犬ハチ公&quot;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hachi </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">dog[</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">2</span><span style="color:#323232;">];
</span></pre><p id = "para-613">with this error:</p>
<pre><span style="color:#323232;">thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;忠&#39;
(bytes 0..3) of `忠犬ハチ公`&#39;
</span></pre><h3 id = "link-130">Concatenation</h3>
<p id = "para-614">If you have a <code>String</code>, you can concatenate a <code>&amp;str</code> to the end of it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hello </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello &quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> world </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;world!&quot;</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hello_world </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> hello </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> world;
</span></pre><p id = "para-615">But if you have two <code>String</code>s, you need an <code>&amp;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hello </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello &quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> world </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;world!&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> hello_world </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> hello </span><span style="font-weight:bold;color:#a71d5d;">+ &amp;</span><span style="color:#323232;">world;
</span></pre><p id = "para-616">This is because <code>&amp;String</code> can automatically coerce to a <code>&amp;str</code>. This is a feature called ‘<a href = "#chapter-40"><code>Deref</code> coercions</a>’.</p>

</div><div id = "chapter-25" class = "chapter">
  <h2 id = "link-131">Generics</h2>
<p id = "para-617">Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics. Generics are called ‘parametric polymorphism’ in type theory, which means that they are types or functions that have multiple forms (‘poly’ is multiple, ‘morph’ is form) over a given parameter (‘parametric’).</p>
<p id = "para-618">Anyway, enough type theory, let’s check out some generic code. Rust’s standard library provides a type, <code>Option&lt;T&gt;</code>, that’s generic:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Option&lt;T&gt; {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(T),
    </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
}
</span></pre><p id = "para-619">The <code>&lt;T&gt;</code> part, which you’ve seen a few times before, indicates that this is a generic data type. Inside the declaration of our <code>enum</code>, wherever we see a <code>T</code>, we substitute that type for the same type used in the generic. Here’s an example of using <code>Option&lt;T&gt;</code>, with some extra type annotations:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span></pre><p id = "para-620">In the type declaration, we say <code>Option&lt;i32&gt;</code>. Note how similar this looks to <code>Option&lt;T&gt;</code>. So, in this particular <code>Option</code>, <code>T</code> has the value of <code>i32</code>. On the right-hand side of the binding, we make a <code>Some(T)</code>, where <code>T</code> is <code>5</code>. Since that’s an <code>i32</code>, the two sides match, and Rust is happy. If they didn’t match, we’d get an error:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-style:italic;color:#969896;">// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,
// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)
</span></pre><p id = "para-621">That doesn’t mean we can’t make <code>Option&lt;T&gt;</code>s that hold an <code>f64</code>! They have to match up:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">);
</span></pre><p id = "para-622">This is just fine. One definition, multiple uses.</p>
<p id = "para-623">Generics don’t have to only be generic over one type. Consider another type from Rust’s standard library that’s similar, <code>Result&lt;T, E&gt;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Result&lt;T, E&gt; {
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(T),
    </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(E),
}
</span></pre><p id = "para-624">This type is generic over <em>two</em> types: <code>T</code> and <code>E</code>. By the way, the capital letters can be any letter you’d like. We could define <code>Result&lt;T, E&gt;</code> as:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Result&lt;A, Z&gt; {
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(A),
    </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(Z),
}
</span></pre><p id = "para-625">if we wanted to. Convention says that the first generic parameter should be <code>T</code>, for ‘type’, and that we use <code>E</code> for ‘error’. Rust doesn’t care, however.</p>
<p id = "para-626">The <code>Result&lt;T, E&gt;</code> type is intended to be used to return the result of a computation, and to have the ability to return an error if it didn’t work out.</p>
<h3 id = "link-132">Generic functions</h3>
<p id = "para-627">We can write functions that take generic types with a similar syntax:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_anything</span><span style="color:#323232;">&lt;T&gt;(x: T) {
    </span><span style="font-style:italic;color:#969896;">// Do something with `x`.
</span><span style="color:#323232;">}
</span></pre><p id = "para-628">The syntax has two parts: the <code>&lt;T&gt;</code> says “this function is generic over one type, <code>T</code>”, and the <code>x: T</code> says “x has the type <code>T</code>.”</p>
<p id = "para-629">Multiple arguments can have the same generic type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_two_of_the_same_things</span><span style="color:#323232;">&lt;T&gt;(x: T, y: T) {
    </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="color:#323232;">}
</span></pre><p id = "para-630">We could write a version that takes multiple types:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">takes_two_things</span><span style="color:#323232;">&lt;T, U&gt;(x: T, y: U) {
    </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="color:#323232;">}
</span></pre><h3 id = "link-133">Generic structs</h3>
<p id = "para-631">You can store a generic type in a <code>struct</code> as well:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point&lt;T&gt; {
    x: T,
    y: T,
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> int_origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> float_origin </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">0.0</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0.0 </span><span style="color:#323232;">};
</span></pre><p id = "para-632">Similar to functions, the <code>&lt;T&gt;</code> is where we declare the generic parameters, and we then use <code>x: T</code> in the type declaration, too.</p>
<p id = "para-633">When you want to add an implementation for the generic <code>struct</code>, you declare the type parameter after the <code>impl</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Point&lt;T&gt; {
#     x: T,
#     y: T,
# }
</span><span style="font-weight:bold;color:#a71d5d;">#
impl</span><span style="color:#323232;">&lt;T&gt; Point&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">swap</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) {
        std::mem::swap(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self.x, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self.y);
    }
}
</span></pre><p id = "para-634">So far you’ve seen generics that take absolutely any type. These are useful in many cases: you’ve already seen <code>Option&lt;T&gt;</code>, and later you’ll meet universal container types like <a href = "src/../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>. On the other hand, often you want to trade that flexibility for increased expressive power. Read about <a href = "#chapter-26">trait bounds</a> to see why and how.</p>
<h3 id = "link-134">Resolving ambiguities</h3>
<p id = "para-635">Most of the time when generics are involved, the compiler can infer the generic parameters automatically:</p>
<pre><span style="font-style:italic;color:#969896;">// v must be a Vec&lt;T&gt; but we don&#39;t know what T is yet
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new();
</span><span style="font-style:italic;color:#969896;">// v just got a bool value, so T must be bool!
</span><span style="color:#323232;">v.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">true</span><span style="color:#323232;">);
</span><span style="font-style:italic;color:#969896;">// Debug-print v
</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-636">Sometimes though, the compiler needs a little help. For example, had we omitted the last line, we would get a compile error:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new();
</span><span style="font-style:italic;color:#969896;">//      ^^^^^^^^ cannot infer type for `T`
//
// note: type annotations or generic parameter binding required
</span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-637">We can solve this using either a type annotation:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new();
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-638">or by binding the generic parameter <code>T</code> via the so-called <a href = "src/../../std/iter/trait.Iterator.html#method.collect">‘turbofish’</a> <code>::&lt;&gt;</code> syntax:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::&lt;</span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">&gt;::new();
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, v);
</span></pre><p id = "para-639">The second approach is useful in situations where we don’t want to bind the result to a variable. It can also be used to bind generic parameters in functions or methods. See <a href = "#chapter-50">Iterators § Consumers</a> for an example.</p>

</div><div id = "chapter-26" class = "chapter">
  <h2 id = "link-135">Traits</h2>
<p id = "para-640">A trait is a language feature that tells the Rust compiler about functionality a type must provide.</p>
<p id = "para-641">Recall the <code>impl</code> keyword, used to call a function with <a href = "#chapter-23">method syntax</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }
}
</span></pre><p id = "para-642">Traits are similar, except that we first define a trait with a method signature, then implement the trait for a type. In this example, we implement the trait <code>HasArea</code> for <code>Circle</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">HasArea {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HasArea </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }
}
</span></pre><p id = "para-643">As you can see, the <code>trait</code> block looks very similar to the <code>impl</code> block, but we don’t define a body, only a type signature. When we <code>impl</code> a trait, we use <code>impl Trait for Item</code>, rather than only <code>impl Item</code>.</p>
<p id = "para-644"><code>Self</code> may be used in a type annotation to refer to an instance of the type implementing this trait passed as a parameter. <code>Self</code>, <code>&amp;Self</code> or <code>&amp;mut Self</code> may be used depending on the level of ownership required.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">HasArea {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_larger</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HasArea </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_larger</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, other: </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        self.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">() </span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> other.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">()
    }
}
</span></pre><h3 id = "link-136">Trait bounds on generic functions</h3>
<p id = "para-645">Traits are useful because they allow a type to make certain promises about its behavior. Generic functions can exploit this to constrain, or <a href = "#chapter-60">bound</a>, the types they accept. Consider this function, which does not compile:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_area</span><span style="color:#323232;">&lt;T&gt;(shape: T) {
    println!(</span><span style="color:#183691;">&quot;This shape has an area of </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, shape.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
}
</span></pre><p id = "para-646">Rust complains:</p>
<pre><span style="color:#323232;">error: no method named `area` found for type `T` in the current scope
</span></pre><p id = "para-647">Because <code>T</code> can be any type, we can’t be sure that it implements the <code>area</code> method. But we can add a trait bound to our generic <code>T</code>, ensuring that it does:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">HasArea {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_area</span><span style="color:#323232;">&lt;T: HasArea&gt;(shape: T) {
    println!(</span><span style="color:#183691;">&quot;This shape has an area of </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, shape.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
}
</span></pre><p id = "para-648">The syntax <code>&lt;T: HasArea&gt;</code> means “any type that implements the <code>HasArea</code> trait.” Because traits define function type signatures, we can be sure that any type which implements <code>HasArea</code> will have an <code>.area()</code> method.</p>
<p id = "para-649">Here’s an extended example of how this works:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">HasArea {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Circle {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    radius: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HasArea </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Circle {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        std::f64::consts::</span><span style="color:#0086b3;">PI </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">(self.radius </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.radius)
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Square {
    x: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    side: </span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HasArea </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Square {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        self.side </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.side
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_area</span><span style="color:#323232;">&lt;T: HasArea&gt;(shape: T) {
    println!(</span><span style="color:#183691;">&quot;This shape has an area of </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, shape.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Circle {
        x: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        y: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        radius: </span><span style="color:#0086b3;">1.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    };

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Square {
        x: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        y: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        side: </span><span style="color:#0086b3;">1.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    };

    </span><span style="color:#62a35c;">print_area</span><span style="color:#323232;">(c);
    </span><span style="color:#62a35c;">print_area</span><span style="color:#323232;">(s);
}
</span></pre><p id = "para-650">This program outputs:</p>
<pre><span style="color:#323232;">This shape has an area of 3.141593
This shape has an area of 1
</span></pre><p id = "para-651">As you can see, <code>print_area</code> is now generic, but also ensures that we have passed in the correct types. If we pass in an incorrect type:</p>
<pre><span style="color:#62a35c;">print_area</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span></pre><p id = "para-652">We get a compile-time error:</p>
<pre><span style="color:#323232;">error: the trait bound `_ : HasArea` is not satisfied [E0277]
</span></pre><h3 id = "link-137">Trait bounds on generic structs</h3>
<p id = "para-653">Your generic structs can also benefit from trait bounds. All you need to do is append the bound when you declare type parameters. Here is a new type <code>Rectangle&lt;T&gt;</code> and its operation <code>is_square()</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Rectangle&lt;T&gt; {
    x: T,
    y: T,
    width: T,
    height: T,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T: PartialEq&gt; Rectangle&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_square</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        self.width </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#323232;">self.height
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> r </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Rectangle {
        x: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">,
        y: </span><span style="color:#0086b3;">0</span><span style="color:#323232;">,
        width: </span><span style="color:#0086b3;">47</span><span style="color:#323232;">,
        height: </span><span style="color:#0086b3;">47</span><span style="color:#323232;">,
    };

    assert!(r.</span><span style="color:#62a35c;">is_square</span><span style="color:#323232;">());

    r.height </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;
    assert!(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">r.</span><span style="color:#62a35c;">is_square</span><span style="color:#323232;">());
}
</span></pre><p id = "para-654"><code>is_square()</code> needs to check that the sides are equal, so the sides must be of a type that implements the <a href = "src/../../core/cmp/trait.PartialEq.html"><code>core::cmp::PartialEq</code></a> trait:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T: PartialEq&gt; Rectangle&lt;T&gt; { </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#323232;">}
</span></pre><p id = "para-655">Now, a rectangle can be defined in terms of any type that can be compared for equality.</p>
<p id = "para-656">Here we defined a new struct <code>Rectangle</code> that accepts numbers of any precision—really, objects of pretty much any type—as long as they can be compared for equality. Could we do the same for our <code>HasArea</code> structs, <code>Square</code> and <code>Circle</code>? Yes, but they need multiplication, and to work with that we need to know more about <a href = "#chapter-39">operator traits</a>.</p>
<h2 id = "link-138">Rules for implementing traits</h2>
<p id = "para-657">So far, we’ve only added trait implementations to structs, but you can implement a trait for any type such as <code>f32</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">ApproxEqual {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">approx_equal</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, other: </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
}
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">ApproxEqual </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">f32 {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">approx_equal</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, other: </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Appropriate for `self` and `other` being close to 1.0.
        </span><span style="color:#323232;">(self </span><span style="font-weight:bold;color:#a71d5d;">-</span><span style="color:#323232;"> other).</span><span style="color:#62a35c;">abs</span><span style="color:#323232;">() </span><span style="font-weight:bold;color:#a71d5d;">&lt;= </span><span style="color:#323232;">::std::f32::</span><span style="color:#0086b3;">EPSILON
    </span><span style="color:#323232;">}
}

println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1.0</span><span style="color:#323232;">.</span><span style="color:#62a35c;">approx_equal</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#0086b3;">1.00000001</span><span style="color:#323232;">));
</span></pre><p id = "para-658">This may seem like the Wild West, but there are two restrictions around implementing traits that prevent this from getting out of hand. The first is that if the trait isn’t defined in your scope, it doesn’t apply. Here’s an example: the standard library provides a <a href = "src/../../std/io/trait.Write.html"><code>Write</code></a> trait which adds extra functionality to <code>File</code>s, for doing file I/O. By default, a <code>File</code> won’t have its methods:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">std::fs::File::create(</span><span style="color:#183691;">&quot;foo.txt&quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Couldn’t create foo.txt&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> buf </span><span style="font-weight:bold;color:#a71d5d;">= b</span><span style="color:#183691;">&quot;whatever&quot;</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// buf: &amp;[u8; 8], a byte string literal.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> result </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> f.</span><span style="color:#62a35c;">write</span><span style="color:#323232;">(buf);
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> result.</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// Ignore the error.
</span></pre><p id = "para-659">Here’s the error:</p>
<pre><span style="color:#323232;">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</span></pre><p id = "para-660">We need to <code>use</code> the <code>Write</code> trait first:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Write;

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">std::fs::File::create(</span><span style="color:#183691;">&quot;foo.txt&quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Couldn’t create foo.txt&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> buf </span><span style="font-weight:bold;color:#a71d5d;">= b</span><span style="color:#183691;">&quot;whatever&quot;</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> result </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> f.</span><span style="color:#62a35c;">write</span><span style="color:#323232;">(buf);
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;"> result.</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// Ignore the error.
</span></pre><p id = "para-661">This will compile without error.</p>
<p id = "para-662">This means that even if someone does something bad like add methods to <code>i32</code>, it won’t affect you, unless you <code>use</code> that trait.</p>
<p id = "para-663">There’s one more restriction on implementing traits: either the trait or the type you’re implementing it for must be defined by you. Or more precisely, one of them must be defined in the same crate as the <code>impl</code> you’re writing. For more on Rust’s module and package system, see the chapter on <a href = "#chapter-32">crates and modules</a>.</p>
<p id = "para-664">So, we could implement the <code>HasArea</code> type for <code>i32</code>, because we defined <code>HasArea</code> in our code. But if we tried to implement <code>ToString</code>, a trait provided by Rust, for <code>i32</code>, we could not, because neither the trait nor the type are defined in our crate.</p>
<p id = "para-665">One last thing about traits: generic functions with a trait bound use ‘monomorphization’ (mono: one, morph: form), so they are statically dispatched. What’s that mean? Check out the chapter on <a href = "#chapter-29">trait objects</a> for more details.</p>
<h2 id = "link-139">Multiple trait bounds</h2>
<p id = "para-666">You’ve seen that you can bound a generic type parameter with a trait:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: Clone&gt;(x: T) {
    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
}
</span></pre><p id = "para-667">If you need more than one bound, you can use <code>+</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Debug;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: Clone </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> Debug&gt;(x: T) {
    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-668"><code>T</code> now needs to be both <code>Clone</code> as well as <code>Debug</code>.</p>
<h2 id = "link-140">Where clause</h2>
<p id = "para-669">Writing functions with only a few generic types and a small number of trait bounds isn’t too bad, but as the number increases, the syntax gets increasingly awkward:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Debug;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: Clone, K: Clone </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> Debug&gt;(x: T, y: K) {
    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    y.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
}
</span></pre><p id = "para-670">The name of the function is on the far left, and the parameter list is on the far right. The bounds are getting in the way.</p>
<p id = "para-671">Rust has a solution, and it’s called a ‘<code>where</code> clause’:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Debug;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: Clone, K: Clone </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> Debug&gt;(x: T, y: K) {
    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    y.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">&lt;T, K&gt;(x: T, y: K) </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> T: Clone, K: Clone + Debug {
    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    y.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;world&quot;</span><span style="color:#323232;">);
    </span><span style="color:#62a35c;">bar</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;world&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-672"><code>foo()</code> uses the syntax we showed earlier, and <code>bar()</code> uses a <code>where</code> clause. All you need to do is leave off the bounds when defining your type parameters, and then add <code>where</code> after the parameter list. For longer lists, whitespace can be added:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Debug;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">&lt;T, K&gt;(x: T, y: K)
    </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> T: Clone,
          K: Clone + Debug {

    x.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    y.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, y);
}
</span></pre><p id = "para-673">This flexibility can add clarity in complex situations.</p>
<p id = "para-674"><code>where</code> is also more powerful than the simpler syntax. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">ConvertTo&lt;Output&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">convert</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Output;
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">ConvertTo&lt;</span><span style="font-weight:bold;color:#a71d5d;">i64</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">i32 {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">convert</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i64 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self </span><span style="font-weight:bold;color:#a71d5d;">as i64 </span><span style="color:#323232;">}
}

</span><span style="font-style:italic;color:#969896;">// Can be called with T == i32.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">convert_t_to_i64</span><span style="color:#323232;">&lt;T: ConvertTo&lt;</span><span style="font-weight:bold;color:#a71d5d;">i64</span><span style="color:#323232;">&gt;&gt;(x: T) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i64 </span><span style="color:#323232;">{
    x.</span><span style="color:#62a35c;">convert</span><span style="color:#323232;">()
}

</span><span style="font-style:italic;color:#969896;">// Can be called with T == i64.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">convert_i32_to_t</span><span style="color:#323232;">&lt;T&gt;(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; T
        </span><span style="font-style:italic;color:#969896;">// This is using ConvertTo as if it were &quot;ConvertTo&lt;i64&gt;&quot;.
        </span><span style="font-weight:bold;color:#a71d5d;">where i32</span><span style="color:#323232;">: ConvertTo&lt;T&gt; {
    x.</span><span style="color:#62a35c;">convert</span><span style="color:#323232;">()
}
</span></pre><p id = "para-675">This shows off the additional feature of <code>where</code> clauses: they allow bounds on the left-hand side not only of type parameters <code>T</code>, but also of types (<code>i32</code> in this case). In this example, <code>i32</code> must implement <code>ConvertTo&lt;T&gt;</code>. Rather than defining what <code>i32</code> is (since that’s obvious), the <code>where</code> clause here constrains <code>T</code>.</p>
<h2 id = "link-141">Default methods</h2>
<p id = "para-676">A default method can be added to a trait definition if it is already known how a typical implementor will define a method. For example, <code>is_invalid()</code> is defined as the opposite of <code>is_valid()</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_valid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_invalid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">self.</span><span style="color:#62a35c;">is_valid</span><span style="color:#323232;">() }
}
</span></pre><p id = "para-677">Implementors of the <code>Foo</code> trait need to implement <code>is_valid()</code> but not <code>is_invalid()</code> due to the added default behavior. This default behavior can still be overridden as in:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">is_valid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">#
#     fn </span><span style="font-weight:bold;color:#795da3;">is_invalid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">self.</span><span style="color:#62a35c;">is_valid</span><span style="color:#323232;">() }
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">UseDefault;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">UseDefault {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_valid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Called UseDefault.is_valid.&quot;</span><span style="color:#323232;">);
        </span><span style="color:#0086b3;">true
    </span><span style="color:#323232;">}
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">OverrideDefault;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">OverrideDefault {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_valid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Called OverrideDefault.is_valid.&quot;</span><span style="color:#323232;">);
        </span><span style="color:#0086b3;">true
    </span><span style="color:#323232;">}

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">is_invalid</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;Called OverrideDefault.is_invalid!&quot;</span><span style="color:#323232;">);
        </span><span style="color:#0086b3;">true </span><span style="font-style:italic;color:#969896;">// Overrides the expected value of `is_invalid()`.
    </span><span style="color:#323232;">}
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> default </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> UseDefault;
assert!(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">default.</span><span style="color:#62a35c;">is_invalid</span><span style="color:#323232;">()); </span><span style="font-style:italic;color:#969896;">// Prints &quot;Called UseDefault.is_valid.&quot;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> over </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> OverrideDefault;
assert!(over.</span><span style="color:#62a35c;">is_invalid</span><span style="color:#323232;">()); </span><span style="font-style:italic;color:#969896;">// Prints &quot;Called OverrideDefault.is_invalid!&quot;
</span></pre><h2 id = "link-142">Inheritance</h2>
<p id = "para-678">Sometimes, implementing a trait requires implementing another trait:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
}

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">FooBar : Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foobar</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
}
</span></pre><p id = "para-679">Implementors of <code>FooBar</code> must also implement <code>Foo</code>, like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">FooBar : Foo {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">foobar</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Baz;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">); }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">FooBar </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foobar</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">); }
}
</span></pre><p id = "para-680">If we forget to implement <code>Foo</code>, Rust will tell us:</p>
<pre><span style="color:#323232;">error: the trait bound `main::Baz : main::Foo` is not satisfied [E0277]
</span></pre><h2 id = "link-143">Deriving</h2>
<p id = "para-681">Implementing traits like <code>Debug</code> and <code>Default</code> repeatedly can become quite tedious. For that reason, Rust provides an <a href = "#chapter-34">attribute</a> that allows you to let Rust automatically implement traits for you:</p>
<pre><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, Foo);
}
</span></pre><p id = "para-682">However, deriving is limited to a certain set of traits:</p>
<ul>
<li><a href = "src/../../core/clone/trait.Clone.html"><code>Clone</code></a></li>
<li><a href = "src/../../core/marker/trait.Copy.html"><code>Copy</code></a></li>
<li><a href = "src/../../core/fmt/trait.Debug.html"><code>Debug</code></a></li>
<li><a href = "src/../../core/default/trait.Default.html"><code>Default</code></a></li>
<li><a href = "src/../../core/cmp/trait.Eq.html"><code>Eq</code></a></li>
<li><a href = "src/../../core/hash/trait.Hash.html"><code>Hash</code></a></li>
<li><a href = "src/../../core/cmp/trait.Ord.html"><code>Ord</code></a></li>
<li><a href = "src/../../core/cmp/trait.PartialEq.html"><code>PartialEq</code></a></li>
<li><a href = "src/../../core/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a></li>
</ul>

</div><div id = "chapter-27" class = "chapter">
  <h2 id = "link-144">Drop</h2>
<p id = "para-683">Now that we’ve discussed traits, let’s talk about a particular trait provided by the Rust standard library, <a href = "src/../../std/ops/trait.Drop.html"><code>Drop</code></a>. The <code>Drop</code> trait provides a way to run some code when a value goes out of scope. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">HasDrop;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Drop </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">HasDrop {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">drop</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) {
        println!(</span><span style="color:#183691;">&quot;Dropping!&quot;</span><span style="color:#323232;">);
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> HasDrop;

    </span><span style="font-style:italic;color:#969896;">// Do stuff.

</span><span style="color:#323232;">} </span><span style="font-style:italic;color:#969896;">// `x` goes out of scope here.
</span></pre><p id = "para-684">When <code>x</code> goes out of scope at the end of <code>main()</code>, the code for <code>Drop</code> will run. <code>Drop</code> has one method, which is also called <code>drop()</code>. It takes a mutable reference to <code>self</code>.</p>
<p id = "para-685">That’s it! The mechanics of <code>Drop</code> are very simple, but there are some subtleties. For example, values are dropped in the opposite order they are declared. Here’s another example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Firework {
    strength: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Drop </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Firework {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">drop</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">self) {
        println!(</span><span style="color:#183691;">&quot;BOOM times </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">!!!&quot;</span><span style="color:#323232;">, self.strength);
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> firecracker </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Firework { strength: </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">};
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> tnt </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Firework { strength: </span><span style="color:#0086b3;">100 </span><span style="color:#323232;">};
}
</span></pre><p id = "para-686">This will output:</p>
<pre><span style="color:#323232;">BOOM times 100!!!
BOOM times 1!!!
</span></pre><p id = "para-687">The <code>tnt</code> goes off before the <code>firecracker</code> does, because it was declared afterwards. Last in, first out.</p>
<p id = "para-688">So what is <code>Drop</code> good for? Generally, <code>Drop</code> is used to clean up any resources associated with a <code>struct</code>. For example, the <a href = "src/../../std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code> type</a> is a reference-counted type. When <code>Drop</code> is called, it will decrement the reference count, and if the total number of references is zero, will clean up the underlying value.</p>

</div><div id = "chapter-28" class = "chapter">
  <h2 id = "link-145">if let</h2>
<p id = "para-689"><code>if let</code> permits <a href = "#chapter-22">patterns</a> matching within the condition of an <a href = "#chapter-12">if</a> statement. This allows us to reduce the overhead of certain kinds of <a href = "#chapter-22">pattern</a> matches and express them in a more convenient way.</p>
<p id = "para-690">For example, let’s say we have some sort of <code>Option&lt;T&gt;</code>. We want to call a function on it if it’s <code>Some&lt;T&gt;</code>, but do nothing if it’s <code>None</code>. That looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> option </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { }
</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> option {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(x) },
    </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{},
}
</span></pre><p id = "para-691">We don’t have to use <code>match</code> here, for example, we could use <code>if</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> option </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { }
</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> option.</span><span style="color:#62a35c;">is_some</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> option.</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(x);
}
</span></pre><p id = "para-692">Neither of these options is particularly appealing. We can use <code>if let</code> to do the same thing in a nicer way:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> option </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { }
</span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> option {
    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(x);
}
</span></pre><p id = "para-693">If a <a href = "#chapter-22">pattern</a> matches successfully, it binds any appropriate parts of the value to the identifiers in the pattern, then evaluates the expression. If the pattern doesn’t match, nothing happens.</p>
<p id = "para-694">If you want to do something else when the pattern does not match, you can use <code>else</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> option </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) { }
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">() { }
</span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> option {
    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(x);
} </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
    </span><span style="color:#62a35c;">bar</span><span style="color:#323232;">();
}
</span></pre><h3 id = "link-146"><code>while let</code></h3>
<p id = "para-695">In a similar fashion, <code>while let</code> can be used when you want to conditionally loop as long as a value matches a certain pattern. It turns code like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">7</span><span style="color:#323232;">, </span><span style="color:#0086b3;">11</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> v.</span><span style="color:#62a35c;">pop</span><span style="color:#323232;">() {
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;  </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x),
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; break</span><span style="color:#323232;">,
    }
}
</span></pre><p id = "para-696">Into code like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">7</span><span style="color:#323232;">, </span><span style="color:#0086b3;">11</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">while let </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> v.</span><span style="color:#62a35c;">pop</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre>
</div><div id = "chapter-29" class = "chapter">
  <h2 id = "link-147">Trait Objects</h2>
<p id = "para-697">When code involves polymorphism, there needs to be a mechanism to determine which specific version is actually run. This is called ‘dispatch’. There are two major forms of dispatch: static dispatch and dynamic dispatch. While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects’.</p>
<h3 id = "link-148">Background</h3>
<p id = "para-698">For the rest of this chapter, we’ll need a trait and some implementations. Let’s make a simple one, <code>Foo</code>. It has one method that is expected to return a <code>String</code>.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String;
}
</span></pre><p id = "para-699">We’ll also implement this trait for <code>u8</code> and <code>String</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String; }
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">u8 {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;u8: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">String {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;string: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) }
}
</span></pre><h3 id = "link-149">Static dispatch</h3>
<p id = "para-700">We can use this trait to perform static dispatch with trait bounds:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String; }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">u8 { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;u8: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">String { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;string: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">do_something</span><span style="color:#323232;">&lt;T: Foo&gt;(x: T) {
    x.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();

    </span><span style="color:#62a35c;">do_something</span><span style="color:#323232;">(x);
    </span><span style="color:#62a35c;">do_something</span><span style="color:#323232;">(y);
}
</span></pre><p id = "para-701">Rust uses ‘monomorphization’ to perform static dispatch here. This means that Rust will create a special version of <code>do_something()</code> for both <code>u8</code> and <code>String</code>, and then replace the call sites with calls to these specialized functions. In other words, Rust generates something like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String; }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">u8 { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;u8: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">String { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;string: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">do_something_u8</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">) {
    x.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">do_something_string</span><span style="color:#323232;">(x: String) {
    x.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();

    </span><span style="color:#62a35c;">do_something_u8</span><span style="color:#323232;">(x);
    </span><span style="color:#62a35c;">do_something_string</span><span style="color:#323232;">(y);
}
</span></pre><p id = "para-702">This has a great upside: static dispatch allows function calls to be inlined because the callee is known at compile time, and inlining is the key to good optimization. Static dispatch is fast, but it comes at a tradeoff: ‘code bloat’, due to many copies of the same function existing in the binary, one for each type.</p>
<p id = "para-703">Furthermore, compilers aren’t perfect and may “optimize” code to become slower. For example, functions inlined too eagerly will bloat the instruction cache (cache rules everything around us). This is part of the reason that <code>#[inline]</code> and <code>#[inline(always)]</code> should be used carefully, and one reason why using a dynamic dispatch is sometimes more efficient.</p>
<p id = "para-704">However, the common case is that it is more efficient to use static dispatch, and one can always have a thin statically-dispatched wrapper function that does a dynamic dispatch, but not vice versa, meaning static calls are more flexible. The standard library tries to be statically dispatched where possible for this reason.</p>
<h3 id = "link-150">Dynamic dispatch</h3>
<p id = "para-705">Rust provides dynamic dispatch through a feature called ‘trait objects’. Trait objects, like <code>&amp;Foo</code> or <code>Box&lt;Foo&gt;</code>, are normal values that store a value of <em>any</em> type that implements the given trait, where the precise type can only be known at runtime.</p>
<p id = "para-706">A trait object can be obtained from a pointer to a concrete type that implements the trait by <em>casting</em> it (e.g. <code>&amp;x as &amp;Foo</code>) or <em>coercing</em> it (e.g. using <code>&amp;x</code> as an argument to a function that takes <code>&amp;Foo</code>).</p>
<p id = "para-707">These trait object coercions and casts also work for pointers like <code>&amp;mut T</code> to <code>&amp;mut Foo</code> and <code>Box&lt;T&gt;</code> to <code>Box&lt;Foo&gt;</code>, but that’s all at the moment. Coercions and casts are identical.</p>
<p id = "para-708">This operation can be seen as ‘erasing’ the compiler’s knowledge about the specific type of the pointer, and hence trait objects are sometimes referred to as ‘type erasure’.</p>
<p id = "para-709">Coming back to the example above, we can use the same trait to perform dynamic dispatch with trait objects by casting:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String; }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">u8 { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;u8: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">String { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;string: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">do_something</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Foo) {
    x.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">;
    </span><span style="color:#62a35c;">do_something</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">as &amp;</span><span style="color:#323232;">Foo);
}
</span></pre><p id = "para-710">or by coercing:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String; }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">u8 { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;u8: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">String { </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">method</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; String { format!(</span><span style="color:#183691;">&quot;string: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">self) } }
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">do_something</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Foo) {
    x.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
    </span><span style="color:#62a35c;">do_something</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x);
}
</span></pre><p id = "para-711">A function that takes a trait object is not specialized to each of the types that implements <code>Foo</code>: only one copy is generated, often (but not always) resulting in less code bloat. However, this comes at the cost of requiring slower virtual function calls, and effectively inhibiting any chance of inlining and related optimizations from occurring.</p>
<h4 id = "link-151">Why pointers?</h4>
<p id = "para-712">Rust does not put things behind a pointer by default, unlike many managed languages, so types can have different sizes. Knowing the size of the value at compile time is important for things like passing it as an argument to a function, moving it about on the stack and allocating (and deallocating) space on the heap to store it.</p>
<p id = "para-713">For <code>Foo</code>, we would need to have a value that could be at least either a <code>String</code> (24 bytes) or a <code>u8</code> (1 byte), as well as any other type for which dependent crates may implement <code>Foo</code> (any number of bytes at all). There’s no way to guarantee that this last point can work if the values are stored without a pointer, because those other types can be arbitrarily large.</p>
<p id = "para-714">Putting the value behind a pointer means the size of the value is not relevant when we are tossing a trait object around, only the size of the pointer itself.</p>
<h4 id = "link-152">Representation</h4>
<p id = "para-715">The methods of the trait can be called on a trait object via a special record of function pointers traditionally called a ‘vtable’ (created and managed by the compiler).</p>
<p id = "para-716">Trait objects are both simple and complicated: their core representation and layout is quite straight-forward, but there are some curly error messages and surprising behaviors to discover.</p>
<p id = "para-717">Let’s start simple, with the runtime representation of a trait object. The <code>std::raw</code> module contains structs with layouts that are the same as the complicated built-in types, <a href = "src/../../std/raw/struct.TraitObject.html">including trait objects</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># mod </span><span style="color:#323232;">foo {
</span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span style="color:#323232;">TraitObject {
    </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span style="color:#323232;">data: *</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">(),
    </span><span style="font-weight:bold;color:#a71d5d;">pub </span><span style="color:#323232;">vtable: *</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">(),
}
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-718">That is, a trait object like <code>&amp;Foo</code> consists of a ‘data’ pointer and a ‘vtable’ pointer.</p>
<p id = "para-719">The data pointer addresses the data (of some unknown type <code>T</code>) that the trait object is storing, and the vtable pointer points to the vtable (‘virtual method table’) corresponding to the implementation of <code>Foo</code> for <code>T</code>.</p>
<p id = "para-720">A vtable is essentially a struct of function pointers, pointing to the concrete piece of machine code for each method in the implementation. A method call like <code>trait_object.method()</code> will retrieve the correct pointer out of the vtable and then do a dynamic call of it. For example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">FooVtable {
    destructor: </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(*</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">()),
    size: </span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">,
    align: </span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">,
    method: </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(*const ()) -&gt; String,
}

</span><span style="font-style:italic;color:#969896;">// u8:

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_method_on_u8</span><span style="color:#323232;">(x: *const ()) -&gt; String {
    </span><span style="font-style:italic;color:#969896;">// The compiler guarantees that this function is only called
    // with `x` pointing to a u8.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> byte: </span><span style="font-weight:bold;color:#a71d5d;">&amp;u8 = unsafe </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">&amp;*</span><span style="color:#323232;">(x </span><span style="font-weight:bold;color:#a71d5d;">as *const u8</span><span style="color:#323232;">) };

    byte.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">()
}

</span><span style="font-weight:bold;color:#a71d5d;">static</span><span style="color:#323232;"> Foo_for_u8_vtable: FooVtable </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> FooVtable {
    destructor: </span><span style="font-style:italic;color:#969896;">/* compiler magic */</span><span style="color:#323232;">,
    size: </span><span style="color:#0086b3;">1</span><span style="color:#323232;">,
    align: </span><span style="color:#0086b3;">1</span><span style="color:#323232;">,

    </span><span style="font-style:italic;color:#969896;">// Cast to a function pointer:
</span><span style="color:#323232;">    method: call_method_on_u8 </span><span style="font-weight:bold;color:#a71d5d;">as fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*const </span><span style="color:#323232;">()) -&gt; String,
};


</span><span style="font-style:italic;color:#969896;">// String:

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_method_on_String</span><span style="color:#323232;">(x: *const ()) -&gt; String {
    </span><span style="font-style:italic;color:#969896;">// The compiler guarantees that this function is only called
    // with `x` pointing to a String.
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> string: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">= unsafe </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">&amp;*</span><span style="color:#323232;">(x </span><span style="font-weight:bold;color:#a71d5d;">as *const </span><span style="color:#0086b3;">String</span><span style="color:#323232;">) };

    string.</span><span style="color:#62a35c;">method</span><span style="color:#323232;">()
}

</span><span style="font-weight:bold;color:#a71d5d;">static</span><span style="color:#323232;"> Foo_for_String_vtable: FooVtable </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> FooVtable {
    destructor: </span><span style="font-style:italic;color:#969896;">/* compiler magic */</span><span style="color:#323232;">,
    </span><span style="font-style:italic;color:#969896;">// Values for a 64-bit computer, halve them for 32-bit ones.
</span><span style="color:#323232;">    size: </span><span style="color:#0086b3;">24</span><span style="color:#323232;">,
    align: </span><span style="color:#0086b3;">8</span><span style="color:#323232;">,

    method: call_method_on_String </span><span style="font-weight:bold;color:#a71d5d;">as fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*const </span><span style="color:#323232;">()) -&gt; String,
};
</span></pre><p id = "para-721">The <code>destructor</code> field in each vtable points to a function that will clean up any resources of the vtable’s type: for <code>u8</code> it is trivial, but for <code>String</code> it will free the memory. This is necessary for owning trait objects like <code>Box&lt;Foo&gt;</code>, which need to clean-up both the <code>Box</code> allocation as well as the internal type when they go out of scope. The <code>size</code> and <code>align</code> fields store the size of the erased type, and its alignment requirements.</p>
<p id = "para-722">Suppose we’ve got some values that implement <code>Foo</code>. The explicit form of construction and use of <code>Foo</code> trait objects might look a bit like (ignoring the type mismatches: they’re all pointers anyway):</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a: </span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">u8 = </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

</span><span style="font-style:italic;color:#969896;">// let b: &amp;Foo = &amp;a;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> TraitObject {
    </span><span style="font-style:italic;color:#969896;">// Store the data:
</span><span style="color:#323232;">    data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">a,
    </span><span style="font-style:italic;color:#969896;">// Store the methods:
</span><span style="color:#323232;">    vtable: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Foo_for_String_vtable
};

</span><span style="font-style:italic;color:#969896;">// let y: &amp;Foo = x;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> TraitObject {
    </span><span style="font-style:italic;color:#969896;">// Store the data:
</span><span style="color:#323232;">    data: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x,
    </span><span style="font-style:italic;color:#969896;">// Store the methods:
</span><span style="color:#323232;">    vtable: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Foo_for_u8_vtable
};

</span><span style="font-style:italic;color:#969896;">// b.method();
</span><span style="color:#323232;">(b.vtable.method)(b.data);

</span><span style="font-style:italic;color:#969896;">// y.method();
</span><span style="color:#323232;">(y.vtable.method)(y.data);
</span></pre><h3 id = "link-153">Object Safety</h3>
<p id = "para-723">Not every trait can be used to make a trait object. For example, vectors implement <code>Clone</code>, but if we try to make a trait object:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> o </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">v </span><span style="font-weight:bold;color:#a71d5d;">as &amp;</span><span style="color:#0086b3;">Clone</span><span style="color:#323232;">;
</span></pre><p id = "para-724">We get an error:</p>
<pre><span style="color:#323232;">error: cannot convert to a trait object because trait `core::clone::Clone` is not object-safe [E0038]
let o = &amp;v as &amp;Clone;
        ^~
note: the trait cannot require that `Self : Sized`
let o = &amp;v as &amp;Clone;
        ^~
</span></pre><p id = "para-725">The error says that <code>Clone</code> is not ‘object-safe’. Only traits that are object-safe can be made into trait objects. A trait is object-safe if both of these are true:</p>
<ul>
<li>the trait does not require that <code>Self: Sized</code></li>
<li>all of its methods are object-safe</li>
</ul>
<p id = "para-726">So what makes a method object-safe? Each method must require that <code>Self: Sized</code> or all of the following:</p>
<ul>
<li>must not have any type parameters</li>
<li>must not use <code>Self</code></li>
</ul>
<p id = "para-727">Whew! As we can see, almost all of these rules talk about <code>Self</code>. A good intuition is “except in special circumstances, if your trait’s method uses <code>Self</code>, it is not object-safe.”</p>

</div><div id = "chapter-30" class = "chapter">
  <h2 id = "link-154">Closures</h2>
<p id = "para-728">Sometimes it is useful to wrap up a function and <em>free variables</em> for better clarity and reuse. The free variables that can be used come from the enclosing scope and are ‘closed over’ when used in the function. From this, we get the name ‘closures’ and Rust provides a really great implementation of them, as we’ll see.</p>
<h2 id = "link-155">Syntax</h2>
<p id = "para-729">Closures look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_one </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

assert_eq!(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#62a35c;">plus_one</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">));
</span></pre><p id = "para-730">We create a binding, <code>plus_one</code>, and assign it to a closure. The closure’s arguments go between the pipes (<code>|</code>), and the body is an expression, in this case, <code>x + 1</code>. Remember that <code>{ }</code> is an expression, so we can have multi-line closures too:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_two </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x| {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> result: </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> x;

    result </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
    result </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

    result
};

assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">plus_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
</span></pre><p id = "para-731">You’ll notice a few things about closures that are a bit different from regular named functions defined with <code>fn</code>. The first is that we did not need to annotate the types of arguments the closure takes or the values it returns. We can:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_one </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">};

assert_eq!(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#62a35c;">plus_one</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">));
</span></pre><p id = "para-732">But we don’t have to. Why is this? Basically, it was chosen for ergonomic reasons. While specifying the full type for named functions is helpful with things like documentation and type inference, the full type signatures of closures are rarely documented since they’re anonymous, and they don’t cause the kinds of error-at-a-distance problems that inferring named function types can.</p>
<p id = "para-733">The second is that the syntax is similar, but a bit different. I’ve added spaces here for easier comparison:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn  </span><span style="font-weight:bold;color:#795da3;">plus_one_v1   </span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_one_v2 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1 </span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_one_v3 </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">|          x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1  </span><span style="color:#323232;">;
</span></pre><p id = "para-734">Small differences, but they’re similar.</p>
<h2 id = "link-156">Closures and their environment</h2>
<p id = "para-735">The environment for a closure can include bindings from its enclosing scope in addition to parameters and local bindings. It looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num;

assert_eq!(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">, </span><span style="color:#62a35c;">plus_num</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">));
</span></pre><p id = "para-736">This closure, <code>plus_num</code>, refers to a <code>let</code> binding in its scope: <code>num</code>. More specifically, it borrows the binding. If we do something that would conflict with that binding, we get an error. Like this one:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> num;
</span></pre><p id = "para-737">Which errors with:</p>
<pre><span style="color:#323232;">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;

    let y = &amp;mut num;
}
^
</span></pre><p id = "para-738">A verbose yet helpful error message! As it says, we can’t take a mutable borrow on <code>num</code> because the closure is already borrowing it. If we let the closure go out of scope, we can:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
{
    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">plus_num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num;

} </span><span style="font-style:italic;color:#969896;">// `plus_num` goes out of scope; borrow of `num` ends.

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> num;
</span></pre><p id = "para-739">If your closure requires it, however, Rust will take ownership and move the environment instead. This doesn’t work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="font-weight:bold;color:#795da3;">takes_nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|| nums;

println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, nums);
</span></pre><p id = "para-740">We get this error:</p>
<pre><span style="color:#323232;">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                 ^~~~~~~
</span></pre><p id = "para-741"><code>Vec&lt;T&gt;</code> has ownership over its contents, and therefore, when we refer to it in our closure, we have to take ownership of <code>nums</code>. It’s the same as if we’d passed <code>nums</code> to a function that took ownership of it.</p>
<h3 id = "link-157"><code>move</code> closures</h3>
<p id = "para-742">We can force our closure to take ownership of its environment with the <code>move</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> owns_num </span><span style="font-weight:bold;color:#a71d5d;">= move |</span><span style="color:#323232;">x: </span><span style="font-weight:bold;color:#a71d5d;">i32|</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num;
</span></pre><p id = "para-743">Now, even though the keyword is <code>move</code>, the variables follow normal move semantics. In this case, <code>5</code> implements <code>Copy</code>, and so <code>owns_num</code> takes ownership of a copy of <code>num</code>. So what’s the difference?</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut </span><span style="font-weight:bold;color:#795da3;">add_num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">|x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">| num </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> x;

    </span><span style="color:#62a35c;">add_num</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
}

assert_eq!(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">, num);
</span></pre><p id = "para-744">So in this case, our closure took a mutable reference to <code>num</code>, and then when we called <code>add_num</code>, it mutated the underlying value, as we’d expect. We also needed to declare <code>add_num</code> as <code>mut</code> too, because we’re mutating its environment.</p>
<p id = "para-745">If we change to a <code>move</code> closure, it’s different:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> add_num </span><span style="font-weight:bold;color:#a71d5d;">= move |</span><span style="color:#323232;">x: </span><span style="font-weight:bold;color:#a71d5d;">i32|</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> x;

    </span><span style="color:#62a35c;">add_num</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
}

assert_eq!(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, num);
</span></pre><p id = "para-746">We only get <code>5</code>. Rather than taking a mutable borrow out on our <code>num</code>, we took ownership of a copy.</p>
<p id = "para-747">Another way to think about <code>move</code> closures: they give a closure its own stack frame. Without <code>move</code>, a closure may be tied to the stack frame that created it, while a <code>move</code> closure is self-contained. This means that you cannot generally return a non-<code>move</code> closure from a function, for example.</p>
<p id = "para-748">But before we talk about taking and returning closures, we should talk some more about the way that closures are implemented. As a systems language, Rust gives you tons of control over what your code does, and closures are no different.</p>
<h2 id = "link-158">Closure implementation</h2>
<p id = "para-749">Rust’s implementation of closures is a bit different than other languages. They are effectively syntax sugar for traits. You’ll want to make sure to have read the <a href = "#chapter-26">traits</a> section before this one, as well as the section on <a href = "#chapter-29">trait objects</a>.</p>
<p id = "para-750">Got all that? Good.</p>
<p id = "para-751">The key to understanding how closures work under the hood is something a bit strange: Using <code>()</code> to call a function, like <code>foo()</code>, is an overloadable operator. From this, everything else clicks into place. In Rust, we use the trait system to overload operators. Calling functions is no different. We have three separate traits to overload with:</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p id = "para-752">There are a few differences between these traits, but a big one is <code>self</code>: <code>Fn</code> takes <code>&amp;self</code>, <code>FnMut</code> takes <code>&amp;mut self</code>, and <code>FnOnce</code> takes <code>self</code>. This covers all three kinds of <code>self</code> via the usual method call syntax. But we’ve split them up into three traits, rather than having a single one. This gives us a large amount of control over what kind of closures we can take.</p>
<p id = "para-753">The <code>|| {}</code> syntax for closures is sugar for these three traits. Rust will generate a struct for the environment, <code>impl</code> the appropriate trait, and then use it.</p>
<h2 id = "link-159">Taking closures as arguments</h2>
<p id = "para-754">Now that we know that closures are traits, we already know how to accept and return closures: the same as any other trait!</p>
<p id = "para-755">This also means that we can choose static vs dynamic dispatch as well. First, let’s write a function which takes something callable, calls it, and returns the result:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_one</span><span style="color:#323232;">&lt;F&gt;(some_closure: F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
    where</span><span style="color:#323232;"> F: Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{

    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">call_with_one</span><span style="color:#323232;">(|x| x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2</span><span style="color:#323232;">);

assert_eq!(</span><span style="color:#0086b3;">3</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-756">We pass our closure, <code>|x| x + 2</code>, to <code>call_with_one</code>. It does what it suggests: it calls the closure, giving it <code>1</code> as an argument.</p>
<p id = "para-757">Let’s examine the signature of <code>call_with_one</code> in more depth:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_one</span><span style="color:#323232;">&lt;F&gt;(some_closure: F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
#    where</span><span style="color:#323232;"> F: </span><span style="color:#0086b3;">Fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">) }
</span></pre><p id = "para-758">We take one parameter, and it has the type <code>F</code>. We also return an <code>i32</code>. This part isn’t interesting. The next part is:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">call_with_one</span><span style="color:#323232;">&lt;F&gt;(some_closure: F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
    where</span><span style="color:#323232;"> F: Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#   </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">) }
</span></pre><p id = "para-759">Because <code>Fn</code> is a trait, we can use it as a bound for our generic type. In this case, our closure takes an <code>i32</code> as an argument and returns an <code>i32</code>, and so the generic bound we use is <code>Fn(i32) -&gt; i32</code>.</p>
<p id = "para-760">There’s one other key point here: because we’re bounding a generic with a trait, this will get monomorphized, and therefore, we’ll be doing static dispatch into the closure. That’s pretty neat. In many languages, closures are inherently heap allocated, and will always involve dynamic dispatch. In Rust, we can stack allocate our closure environment, and statically dispatch the call. This happens quite often with iterators and their adapters, which often take closures as arguments.</p>
<p id = "para-761">Of course, if we want dynamic dispatch, we can get that too. A trait object handles this case, as usual:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_one</span><span style="color:#323232;">(some_closure: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Fn(i32) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">call_with_one</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;|</span><span style="color:#323232;">x</span><span style="font-weight:bold;color:#a71d5d;">|</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2</span><span style="color:#323232;">);

assert_eq!(</span><span style="color:#0086b3;">3</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-762">Now we take a trait object, a <code>&amp;Fn</code>. And we have to make a reference to our closure when we pass it to <code>call_with_one</code>, so we use <code>&amp;||</code>.</p>
<p id = "para-763">A quick note about closures that use explicit lifetimes. Sometimes you might have a closure that takes a reference like so:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_ref</span><span style="color:#323232;">&lt;F&gt;(some_closure:F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
    where</span><span style="color:#323232;"> F: Fn(</span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> value </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">value)
}
</span></pre><p id = "para-764">Normally you can specify the lifetime of the parameter to our closure. We could annotate it on the function declaration:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_ref</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, F&gt;(some_closure:F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
    where</span><span style="color:#323232;"> F: Fn(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
</span></pre><p id = "para-765">However, this presents a problem in our case. When a function has an explicit lifetime parameter, that lifetime must be at least as long as the <em>entire</em> call to that function. The borrow checker will complain that <code>value</code> doesn’t live long enough, because it is only in scope after its declaration inside the function body.</p>
<p id = "para-766">What we need is a closure that can borrow its argument only for its own invocation scope, not for the outer function’s scope. In order to say that, we can use Higher-Ranked Trait Bounds with the <code>for&lt;...&gt;</code> syntax:</p>
<pre><span style="color:#323232;">fn call_with_ref&lt;F&gt;(some_closure:F) -&gt; i32
    where F: for&lt;&#39;a&gt; Fn(&amp;&#39;a i32) -&gt; i32 {
</span></pre><p id = "para-767">This lets the Rust compiler find the minimum lifetime to invoke our closure and satisfy the borrow checker’s rules. Our function then compiles and executes as we expect.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_ref</span><span style="color:#323232;">&lt;F&gt;(some_closure:F) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32
    where</span><span style="color:#323232;"> F: </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; Fn(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> value </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">value)
}
</span></pre><h2 id = "link-160">Function pointers and closures</h2>
<p id = "para-768">A function pointer is kind of like a closure that has no environment. As such, you can pass a function pointer to any function expecting a closure argument, and it will work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">call_with_one</span><span style="color:#323232;">(some_closure: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Fn(i32) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="color:#62a35c;">some_closure</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add_one</span><span style="color:#323232;">(i: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    i </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> add_one;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">call_with_one</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">f);

assert_eq!(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-769">In this example, we don’t strictly need the intermediate variable <code>f</code>, the name of the function works just fine too:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">call_with_one</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">add_one);
</span></pre><h2 id = "link-161">Returning closures</h2>
<p id = "para-770">It’s very common for functional-style code to return closures in various situations. If you try to return a closure, you may run into an error. At first, it may seem strange, but we’ll figure it out. Here’s how you’d probably try to return a closure from a function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">factory</span><span style="color:#323232;">() -&gt; (Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    |x| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">factory</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-771">This gives us these long, related errors:</p>
<pre><span style="color:#323232;">error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait bound `core::ops::Fn(i32) -&gt; i32 : core::marker::Sized` is not satisfied [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</span></pre><p id = "para-772">In order to return something from a function, Rust needs to know what size the return type is. But since <code>Fn</code> is a trait, it could be various things of various sizes: many different types can implement <code>Fn</code>. An easy way to give something a size is to take a reference to it, as references have a known size. So we’d write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">factory</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">(Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    |x| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">factory</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-773">But we get another error:</p>
<pre><span style="color:#323232;">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</span></pre><p id = "para-774">Right. Because we have a reference, we need to give it a lifetime. But our <code>factory()</code> function takes no arguments, so <a href = "#chapter-17">elision</a> doesn’t kick in here. Then what choices do we have? Try <code>’static</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">factory</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static </span><span style="color:#323232;">(Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    |x| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">factory</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-775">But we get another error:</p>
<pre><span style="color:#323232;">error: mismatched types:
 expected `&amp;&#39;static core::ops::Fn(i32) -&gt; i32`,
    found `[closure@&lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</span></pre><p id = "para-776">This error is letting us know that we don’t have a <code>&amp;’static Fn(i32) -&gt; i32</code>, we have a <code>[closure@&lt;anon&gt;:7:9: 7:20]</code>. Wait, what?</p>
<p id = "para-777">Because each closure generates its own environment <code>struct</code> and implementation of <code>Fn</code> and friends, these types are anonymous. They exist solely for this closure. So Rust shows them as <code>closure@&lt;anon&gt;</code>, rather than some autogenerated name.</p>
<p id = "para-778">The error also points out that the return type is expected to be a reference, but what we are trying to return is not. Further, we cannot directly assign a <code>’static</code> lifetime to an object. So we’ll take a different approach and return a ‘trait object’ by <code>Box</code>ing up the <code>Fn</code>. This <em>almost</em> works:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">factory</span><span style="color:#323232;">() -&gt; Box&lt;Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(|x| x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">factory</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-779">There’s just one last problem:</p>
<pre><span style="color:#323232;">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</span></pre><p id = "para-780">Well, as we discussed before, closures borrow their environment. And in this case, our environment is based on a stack-allocated <code>5</code>, the <code>num</code> variable binding. So the borrow has a lifetime of the stack frame. So if we returned this closure, the function call would be over, the stack frame would go away, and our closure is capturing an environment of garbage memory! With one last fix, we can make this work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">factory</span><span style="color:#323232;">() -&gt; Box&lt;Fn(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

    </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(</span><span style="font-weight:bold;color:#a71d5d;">move |</span><span style="color:#323232;">x</span><span style="font-weight:bold;color:#a71d5d;">|</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> num)
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">factory</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">6</span><span style="color:#323232;">, answer);
</span></pre><p id = "para-781">By making the inner closure a <code>move Fn</code>, we create a new stack frame for our closure. By <code>Box</code>ing it up, we’ve given it a known size, allowing it to escape our stack frame.</p>

</div><div id = "chapter-31" class = "chapter">
  <h2 id = "link-162">Universal Function Call Syntax</h2>
<p id = "para-782">Sometimes, functions can have the same names. Consider this code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
}

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Bar {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Baz;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;Baz’s impl of Foo&quot;</span><span style="color:#323232;">); }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Bar </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;Baz’s impl of Bar&quot;</span><span style="color:#323232;">); }
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Baz;
</span></pre><p id = "para-783">If we were to try to call <code>b.f()</code>, we’d get an error:</p>
<pre><span style="color:#323232;">error: multiple applicable methods in scope [E0034]
b.f();
  ^~~
note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</span></pre><p id = "para-784">We need a way to disambiguate which method we need. This feature is called ‘universal function call syntax’, and it looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Foo {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Bar {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Baz;
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;Baz’s impl of Foo&quot;</span><span style="color:#323232;">); }
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Bar </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Baz {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;Baz’s impl of Bar&quot;</span><span style="color:#323232;">); }
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Baz;
Foo::f(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">b);
Bar::f(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">b);
</span></pre><p id = "para-785">Let’s break it down.</p>
<pre><span style="color:#323232;">Foo::
Bar::
</span></pre><p id = "para-786">These halves of the invocation are the types of the two traits: <code>Foo</code> and <code>Bar</code>. This is what ends up actually doing the disambiguation between the two: Rust calls the one from the trait name you use.</p>
<pre><span style="color:#62a35c;">f</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">b)
</span></pre><p id = "para-787">When we call a method like <code>b.f()</code> using <a href = "#chapter-23">method syntax</a>, Rust will automatically borrow <code>b</code> if <code>f()</code> takes <code>&amp;self</code>. In this case, Rust will not, and so we need to pass an explicit <code>&amp;b</code>.</p>
<h2 id = "link-163">Angle-bracket Form</h2>
<p id = "para-788">The form of UFCS we just talked about:</p>
<pre><span style="color:#323232;">Trait::method(args);
</span></pre><p id = "para-789">Is a short-hand. There’s an expanded form of this that’s needed in some situations:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">Type </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> Trait</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">::method(args);
</span></pre><p id = "para-790">The <code>&lt;&gt;::</code> syntax is a means of providing a type hint. The type goes inside the <code>&lt;&gt;</code>s. In this case, the type is <code>Type as Trait</code>, indicating that we want <code>Trait</code>’s version of <code>method</code> to be called here. The <code>as Trait</code> part is optional if it’s not ambiguous. Same with the angle brackets, hence the shorter form.</p>
<p id = "para-791">Here’s an example of using the longer form.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Bar;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Bar {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">20
    </span><span style="color:#323232;">}
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Bar {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">10
    </span><span style="color:#323232;">}
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">, &lt;Bar as Foo&gt;::foo());
    assert_eq!(</span><span style="color:#0086b3;">20</span><span style="color:#323232;">, Bar::foo());
}
</span></pre><p id = "para-792">Using the angle bracket syntax lets you call the trait method instead of the inherent one.</p>

</div><div id = "chapter-32" class = "chapter">
  <h2 id = "link-164">Crates and Modules</h2>
<p id = "para-793">When a project starts getting large, it’s considered good software engineering practice to split it up into a bunch of smaller pieces, and then fit them together. It is also important to have a well-defined interface, so that some of your functionality is private, and some is public. To facilitate these kinds of things, Rust has a module system.</p>
<h2 id = "link-165">Basic terminology: Crates and Modules</h2>
<p id = "para-794">Rust has two distinct terms that relate to the module system: ‘crate’ and ‘module’. A crate is synonymous with a ‘library’ or ‘package’ in other languages. Hence “Cargo” as the name of Rust’s package management tool: you ship your crates to others with Cargo. Crates can produce an executable or a library, depending on the project.</p>
<p id = "para-795">Each crate has an implicit <em>root module</em> that contains the code for that crate. You can then define a tree of sub-modules under that root module. Modules allow you to partition your code within the crate itself.</p>
<p id = "para-796">As an example, let’s make a <em>phrases</em> crate, which will give us various phrases in different languages. To keep things simple, we’ll stick to ‘greetings’ and ‘farewells’ as two kinds of phrases, and use English and Japanese (日本語) as two languages for those phrases to be in. We’ll use this module layout:</p>
<pre><span style="color:#323232;">                                    +-----------+
                                +---| greetings |
                  +---------+   |   +-----------+
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |   +-----------+
                                +---| farewells |
                                    +-----------+
</span></pre><p id = "para-797">In this example, <code>phrases</code> is the name of our crate. All of the rest are modules. You can see that they form a tree, branching out from the crate <em>root</em>, which is the root of the tree: <code>phrases</code> itself.</p>
<p id = "para-798">Now that we have a plan, let’s define these modules in code. To start, generate a new crate with Cargo:</p>
<pre><span style="color:#323232;">$ cargo new phrases
$ cd phrases
</span></pre><p id = "para-799">If you remember, this generates a simple project for us:</p>
<pre><span style="color:#323232;">$ tree .
</span><span style="color:#62a35c;">.
</span><span style="color:#323232;">├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</span></pre><p id = "para-800"><code>src/lib.rs</code> is our crate root, corresponding to the <code>phrases</code> in our diagram above.</p>
<h2 id = "link-166">Defining Modules</h2>
<p id = "para-801">To define each of our modules, we use the <code>mod</code> keyword. Let’s make our <code>src/lib.rs</code> look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">english {
    </span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">greetings {
    }

    </span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">farewells {
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">japanese {
    </span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">greetings {
    }

    </span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">farewells {
    }
}
</span></pre><p id = "para-802">After the <code>mod</code> keyword, you give the name of the module. Module names follow the conventions for other Rust identifiers: <code>lower_snake_case</code>. The contents of each module are within curly braces (<code>{}</code>).</p>
<p id = "para-803">Within a given <code>mod</code>, you can declare sub-<code>mod</code>s. We can refer to sub-modules with double-colon (<code>::</code>) notation: our four nested modules are <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code>, and <code>japanese::farewells</code>. Because these sub-modules are namespaced under their parent module, the names don’t conflict: <code>english::greetings</code> and <code>japanese::greetings</code> are distinct, even though their names are both <code>greetings</code>.</p>
<p id = "para-804">Because this crate does not have a <code>main()</code> function, and is called <code>lib.rs</code>, Cargo will build this crate as a library:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</span></pre><p id = "para-805"><code>libphrases-&lt;hash&gt;.rlib</code> is the compiled crate. Before we see how to use this crate from another crate, let’s break it up into multiple files.</p>
<h2 id = "link-167">Multiple File Crates</h2>
<p id = "para-806">If each crate were just one file, these files would get very large. It’s often easier to split up crates into multiple files, and Rust supports this in two ways.</p>
<p id = "para-807">Instead of declaring a module like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">english {
    </span><span style="font-style:italic;color:#969896;">// Contents of our module go here.
</span><span style="color:#323232;">}
</span></pre><p id = "para-808">We can instead declare our module like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">english;
</span></pre><p id = "para-809">If we do that, Rust will expect to find either a <code>english.rs</code> file, or a <code>english/mod.rs</code> file with the contents of our module.</p>
<p id = "para-810">Note that in these files, you don’t need to re-declare the module: that’s already been done with the initial <code>mod</code> declaration.</p>
<p id = "para-811">Using these two techniques, we can break up our crate into two directories and seven files:</p>
<pre><span style="color:#323232;">$ tree .
</span><span style="color:#62a35c;">.
</span><span style="color:#323232;">├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</span></pre><p id = "para-812"><code>src/lib.rs</code> is our crate root, and looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">english;
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">japanese;
</span></pre><p id = "para-813">These two declarations tell Rust to look for</p>
<ul>
<li>either <code>src/english.rs</code> or <code>src/english/mod.rs</code>, and</li>
<li>either <code>src/japanese.rs</code> or <code>src/japanese/mod.rs</code>,</li>
</ul>
<p id = "para-814">depending on our preference. In this case, because our modules have sub-modules, we’ve chosen the <code>mod.rs</code> approach. Both <code>src/english/mod.rs</code> and <code>src/japanese/mod.rs</code> look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">greetings;
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">farewells;
</span></pre><p id = "para-815">Again, these declarations tell Rust to look for</p>
<ul>
<li><code>src/english/greetings.rs</code> or <code>src/english/greetings/mod.rs</code>,</li>
<li><code>src/english/farewells.rs</code> or <code>src/english/farewells/mod.rs</code>,</li>
<li><code>src/japanese/greetings.rs</code> or <code>src/japanese/greetings/mod.rs</code>,</li>
<li>and <code>src/japanese/farewells.rs</code> or <code>src/japanese/farewells/mod.rs</code>.</li>
</ul>
<p id = "para-816">Because these sub-modules don’t have their own sub-modules, we’ve chosen to make them <code>src/english/greetings.rs</code>, <code>src/english/farewells.rs</code>, <code>src/japanese/greetings.rs</code> and <code>src/japanese/farewells.rs</code>. Whew!</p>
<p id = "para-817">The contents of <code>src/english/greetings.rs</code>, <code>src/english/farewells.rs</code>, <code>src/japanese/greetings.rs</code> and <code>src/japanese/farewells.rs</code> are all empty at the moment. Let’s add some functions.</p>
<p id = "para-818">Put this in <code>src/english/greetings.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">hello</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;Hello!&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-819">Put this in <code>src/english/farewells.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">goodbye</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;Goodbye.&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-820">Put this in <code>src/japanese/greetings.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">hello</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;こんにちは&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-821">Of course, you can copy and paste this from this web page, or type something else. It’s not important that you actually put ‘konnichiwa’ to learn about the module system.</p>
<p id = "para-822">Put this in <code>src/japanese/farewells.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">goodbye</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;さようなら&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-823">(This is ‘Sayōnara’, if you’re curious.)</p>
<p id = "para-824">Now that we have some functionality in our crate, let’s try to use it from another crate.</p>
<h2 id = "link-168">Importing External Crates</h2>
<p id = "para-825">We have a library crate. Let’s make an executable crate that imports and uses our library.</p>
<p id = "para-826">Make a <code>src/main.rs</code> and put this in it (it won’t quite compile yet):</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::english::greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::english::farewells::goodbye());

    println!(</span><span style="color:#183691;">&quot;Hello in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::japanese::greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::japanese::farewells::goodbye());
}
</span></pre><p id = "para-827">The <code>extern crate</code> declaration tells Rust that we need to compile and link to the <code>phrases</code> crate. We can then use <code>phrases</code>’ modules in this one. As we mentioned earlier, you can use double colons to refer to sub-modules and the functions inside of them.</p>
<p id = "para-828">(Note: when importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code>.)</p>
<p id = "para-829">Also, Cargo assumes that <code>src/main.rs</code> is the crate root of a binary crate, rather than a library crate. Our package now has two crates: <code>src/lib.rs</code> and <code>src/main.rs</code>. This pattern is quite common for executable crates: most functionality is in a library crate, and the executable crate uses that library. This way, other programs can also use the library crate, and it’s also a nice separation of concerns.</p>
<p id = "para-830">This doesn’t quite work yet, though. We get four errors that look similar to this:</p>
<pre><span style="color:#323232;">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Hello in English: {}&quot;</span><span style="color:#323232;">, phrases::english::greetings::hello())</span><span style="font-weight:bold;color:#a71d5d;">;
                                                   </span><span style="color:#323232;">^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:2:25: 2:58 note: expansion site
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:1:1: 2:62 note: in expansion of print!
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:3:1: 3:54 note: expansion site
</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">std macros</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</span></pre><p id = "para-831">By default, everything is private in Rust. Let’s talk about this in some more depth.</p>
<h2 id = "link-169">Exporting a Public Interface</h2>
<p id = "para-832">Rust allows you to precisely control which aspects of your interface are public, and so private is the default. To make things public, you use the <code>pub</code> keyword. Let’s focus on the <code>english</code> module first, so let’s reduce our <code>src/main.rs</code> to only this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::english::greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, phrases::english::farewells::goodbye());
}
</span></pre><p id = "para-833">In our <code>src/lib.rs</code>, let’s add <code>pub</code> to the <code>english</code> module declaration:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub mod </span><span style="color:#323232;">english;
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">japanese;
</span></pre><p id = "para-834">And in our <code>src/english/mod.rs</code>, let’s make both <code>pub</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub mod </span><span style="color:#323232;">greetings;
</span><span style="font-weight:bold;color:#a71d5d;">pub mod </span><span style="color:#323232;">farewells;
</span></pre><p id = "para-835">In our <code>src/english/greetings.rs</code>, let’s add <code>pub</code> to our <code>fn</code> declaration:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">hello</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;Hello!&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-836">And also in <code>src/english/farewells.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">goodbye</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;Goodbye.&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-837">Now, our crate compiles, albeit with warnings about not using the <code>japanese</code> functions:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, </span><span style="font-style:italic;color:#969896;">#[warn(dead_code)] on by default
</span><span style="color:#323232;">src/japanese/greetings.rs:1 fn hello() -</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> String {
src/japanese/greetings.rs:2     </span><span style="color:#183691;">&quot;こんにちは&quot;</span><span style="color:#323232;">.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, </span><span style="font-style:italic;color:#969896;">#[warn(dead_code)] on by default
</span><span style="color:#323232;">src/japanese/farewells.rs:1 fn goodbye() -</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> String {
src/japanese/farewells.rs:2     </span><span style="color:#183691;">&quot;さようなら&quot;</span><span style="color:#323232;">.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</span></pre><p id = "para-838"><code>pub</code> also applies to <code>struct</code>s and their member fields. In keeping with Rust’s tendency toward safety, simply making a <code>struct</code> public won’t automatically make its members public: you must mark the fields individually with <code>pub</code>.</p>
<p id = "para-839">Now that our functions are public, we can use them. Great! However, typing out <code>phrases::english::greetings::hello()</code> is very long and repetitive. Rust has another keyword for importing names into the current scope, so that you can refer to them with shorter names. Let’s talk about <code>use</code>.</p>
<h2 id = "link-170">Importing Modules with <code>use</code></h2>
<p id = "para-840">Rust has a <code>use</code> keyword, which allows us to import names into our local scope. Let’s change our <code>src/main.rs</code> to look like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::greetings;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::farewells;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, farewells::goodbye());
}
</span></pre><p id = "para-841">The two <code>use</code> lines import each module into the local scope, so we can refer to the functions by a much shorter name. By convention, when importing functions, it’s considered best practice to import the module, rather than the function directly. In other words, you <em>can</em> do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::greetings::hello;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::farewells::goodbye;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#62a35c;">hello</span><span style="color:#323232;">());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#62a35c;">goodbye</span><span style="color:#323232;">());
}
</span></pre><p id = "para-842">But it is not idiomatic. This is significantly more likely to introduce a naming conflict. In our short program, it’s not a big deal, but as it grows, it becomes a problem. If we have conflicting names, Rust will give a compilation error. For example, if we made the <code>japanese</code> functions public, and tried to do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::greetings::hello;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::japanese::greetings::hello;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#62a35c;">hello</span><span style="color:#323232;">());
    println!(</span><span style="color:#183691;">&quot;Hello in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#62a35c;">hello</span><span style="color:#323232;">());
}
</span></pre><p id = "para-843">Rust will give us a compile-time error:</p>
<pre><span style="color:#323232;">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</span></pre><p id = "para-844">If we’re importing multiple names from the same module, we don’t have to type it out twice. Instead of this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::greetings;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::farewells;
</span></pre><p id = "para-845">We can use this shortcut:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::{greetings, farewells};
</span></pre><h3 id = "link-171">Re-exporting with <code>pub use</code></h3>
<p id = "para-846">You don’t only use <code>use</code> to shorten identifiers. You can also use it inside of your crate to re-export a function inside another module. This allows you to present an external interface that may not directly map to your internal code organization.</p>
<p id = "para-847">Let’s look at an example. Modify your <code>src/main.rs</code> to read like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::english::{greetings,farewells};
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">phrases::japanese;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, farewells::goodbye());

    println!(</span><span style="color:#183691;">&quot;Hello in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, japanese::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, japanese::goodbye());
}
</span></pre><p id = "para-848">Then, modify your <code>src/lib.rs</code> to make the <code>japanese</code> mod public:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub mod </span><span style="color:#323232;">english;
</span><span style="font-weight:bold;color:#a71d5d;">pub mod </span><span style="color:#323232;">japanese;
</span></pre><p id = "para-849">Next, make the two functions public, first in <code>src/japanese/greetings.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">hello</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;こんにちは&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-850">And then in <code>src/japanese/farewells.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">goodbye</span><span style="color:#323232;">() -&gt; String {
    </span><span style="color:#183691;">&quot;さようなら&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()
}
</span></pre><p id = "para-851">Finally, modify your <code>src/japanese/mod.rs</code> to read like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub use </span><span style="color:#323232;">self::greetings::hello;
</span><span style="font-weight:bold;color:#a71d5d;">pub use </span><span style="color:#323232;">self::farewells::goodbye;

</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">greetings;
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">farewells;
</span></pre><p id = "para-852">The <code>pub use</code> declaration brings the function into scope at this part of our module hierarchy. Because we’ve <code>pub use</code>d this inside of our <code>japanese</code> module, we now have a <code>phrases::japanese::hello()</code> function and a <code>phrases::japanese::goodbye()</code> function, even though the code for them lives in <code>phrases::japanese::greetings::hello()</code> and <code>phrases::japanese::farewells::goodbye()</code>. Our internal organization doesn’t define our external interface.</p>
<p id = "para-853">Here we have a <code>pub use</code> for each function we want to bring into the <code>japanese</code> scope. We could alternatively use the wildcard syntax to include everything from <code>greetings</code> into the current scope: <code>pub use self::greetings::*</code>.</p>
<p id = "para-854">What about the <code>self</code>? Well, by default, <code>use</code> declarations are absolute paths, starting from your crate root. <code>self</code> makes that path relative to your current place in the hierarchy instead. There’s one more special form of <code>use</code>: you can <code>use super::</code> to reach one level up the tree from your current location. Some people like to think of <code>self</code> as <code>.</code> and <code>super</code> as <code>..</code>, from many shells’ display for the current directory and the parent directory.</p>
<p id = "para-855">Outside of <code>use</code>, paths are relative: <code>foo::bar()</code> refers to a function inside of <code>foo</code> relative to where we are. If that’s prefixed with <code>::</code>, as in <code>::foo::bar()</code>, it refers to a different <code>foo</code>, an absolute path from your crate root.</p>
<p id = "para-856">This will build and run:</p>
<pre><span style="color:#323232;">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</span></pre><h3 id = "link-172">Complex imports</h3>
<p id = "para-857">Rust offers several advanced options that can add compactness and convenience to your <code>extern crate</code> and <code>use</code> statements. Here is an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> phrases </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> sayings;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::japanese::greetings </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> ja_greetings;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::japanese::farewells::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::english::{self, greetings </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> en_greetings, farewells </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> en_farewells};

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;Hello in English; </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, en_greetings::hello());
    println!(</span><span style="color:#183691;">&quot;And in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, ja_greetings::hello());
    println!(</span><span style="color:#183691;">&quot;Goodbye in English: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, english::farewells::goodbye());
    println!(</span><span style="color:#183691;">&quot;Again: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, en_farewells::goodbye());
    println!(</span><span style="color:#183691;">&quot;And in Japanese: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#62a35c;">goodbye</span><span style="color:#323232;">());
}
</span></pre><p id = "para-858">What’s going on here?</p>
<p id = "para-859">First, both <code>extern crate</code> and <code>use</code> allow renaming the thing that is being imported. So the crate is still called “phrases”, but here we will refer to it as “sayings”. Similarly, the first <code>use</code> statement pulls in the <code>japanese::greetings</code> module from the crate, but makes it available as <code>ja_greetings</code> as opposed to simply <code>greetings</code>. This can help to avoid ambiguity when importing similarly-named items from different places.</p>
<p id = "para-860">The second <code>use</code> statement uses a star glob to bring in all public symbols from the <code>sayings::japanese::farewells</code> module. As you can see we can later refer to the Japanese <code>goodbye</code> function with no module qualifiers. This kind of glob should be used sparingly. It’s worth noting that it only imports the public symbols, even if the code doing the globbing is in the same module.</p>
<p id = "para-861">The third <code>use</code> statement bears more explanation. It’s using “brace expansion” globbing to compress three <code>use</code> statements into one (this sort of syntax may be familiar if you’ve written Linux shell scripts before). The uncompressed form of this statement would be:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::english;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::english::greetings </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> en_greetings;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">sayings::english::farewells </span><span style="font-weight:bold;color:#a71d5d;">as</span><span style="color:#323232;"> en_farewells;
</span></pre><p id = "para-862">As you can see, the curly brackets compress <code>use</code> statements for several items under the same path, and in this context <code>self</code> refers back to that path. Note: The curly brackets cannot be nested or mixed with star globbing.</p>

</div><div id = "chapter-33" class = "chapter">
  <h2 id = "link-173">const and static</h2>
<p id = "para-863">Rust has a way of defining constants with the <code>const</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">const</span><span style="color:#323232;"> N: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span></pre><p id = "para-864">Unlike <a href = "#chapter-8"><code>let</code></a> bindings, you must annotate the type of a <code>const</code>.</p>
<p id = "para-865">Constants live for the entire lifetime of a program. More specifically, constants in Rust have no fixed address in memory. This is because they’re effectively inlined to each place that they’re used. References to the same constant are not necessarily guaranteed to refer to the same memory address for this reason.</p>
<h2 id = "link-174"><code>static</code></h2>
<p id = "para-866">Rust provides a ‘global variable’ sort of facility in static items. They’re similar to constants, but static items aren’t inlined upon use. This means that there is only one instance for each value, and it’s at a fixed location in memory.</p>
<p id = "para-867">Here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">static</span><span style="color:#323232;"> N: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span></pre><p id = "para-868">Unlike <a href = "#chapter-8"><code>let</code></a> bindings, you must annotate the type of a <code>static</code>.</p>
<p id = "para-869">Statics live for the entire lifetime of a program, and therefore any reference stored in a static has a <a href = "#chapter-17"><code>’static</code> lifetime</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">static </span><span style="color:#0086b3;">NAME</span><span style="color:#323232;">: </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str = </span><span style="color:#183691;">&quot;Steve&quot;</span><span style="color:#323232;">;
</span></pre><p id = "para-870">The type of a <code>static</code> value must be <code>Sync</code> unless the <code>static</code> value is mutable.</p>
<h3 id = "link-175">Mutability</h3>
<p id = "para-871">You can introduce mutability with the <code>mut</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">static mut</span><span style="color:#323232;"> N: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span></pre><p id = "para-872">Because this is mutable, one thread could be updating <code>N</code> while another is reading it, causing memory unsafety. As such both accessing and mutating a <code>static mut</code> is <a href = "#chapter-43"><code>unsafe</code></a>, and so must be done in an <code>unsafe</code> block:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># static mut</span><span style="color:#323232;"> N: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
    N </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

    println!(</span><span style="color:#183691;">&quot;N: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, N);
}
</span></pre><h2 id = "link-176">Initializing</h2>
<p id = "para-873">Both <code>const</code> and <code>static</code> have requirements for giving them a value. They must be given a value that’s a constant expression. In other words, you cannot use the result of a function call or anything similarly complex or at runtime.</p>
<h2 id = "link-177">Dropping</h2>
<p id = "para-874">Types implementing <a href = "#chapter-27"><code>Drop</code></a> are allowed in <code>const</code> and <code>static</code> definitions. Constants are inlined where they are used and are dropped accordingly. <code>static</code> values are not dropped.</p>
<h2 id = "link-178">Which construct should I use?</h2>
<p id = "para-875">Almost always, if you can choose between the two, choose <code>const</code>. It’s pretty rare that you actually want a memory location associated with your constant, and using a <code>const</code> allows for optimizations like constant propagation not only in your crate but downstream crates.</p>

</div><div id = "chapter-34" class = "chapter">
  <h2 id = "link-179">Attributes</h2>
<p id = "para-876">Declarations can be annotated with ‘attributes’ in Rust. They look like this:</p>
<pre><span style="color:#323232;">#[test]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-877">or like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># mod </span><span style="color:#323232;">foo {
#![test]
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-878">The difference between the two is the <code>!</code>, which changes what the attribute applies to:</p>
<pre><span style="color:#323232;">#[foo]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo;

</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">bar {
    #![bar]
}
</span></pre><p id = "para-879">The <code>#[foo]</code> attribute applies to the next item, which is the <code>struct</code> declaration. The <code>#![bar]</code> attribute applies to the item enclosing it, which is the <code>mod</code> declaration. Otherwise, they’re the same. Both change the meaning of the item they’re attached to somehow.</p>
<p id = "para-880">For example, consider a function like this:</p>
<pre><span style="color:#323232;">#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">check</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
}
</span></pre><p id = "para-881">It is marked with <code>#[test]</code>. This means it’s special: when you run <a href = "#chapter-47">tests</a>, this function will execute. When you compile as usual, it won’t even be included. This function is now a test function.</p>
<p id = "para-882">Attributes may also have additional data:</p>
<pre><span style="color:#323232;">#[inline(always)]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">super_fast_fn</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-883">Or even keys and values:</p>
<pre><span style="color:#323232;">#[cfg(target_os </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;macos&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">macos_only {
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-884">Rust attributes are used for a number of different things. There is a full list of attributes <a href = "src/../../reference/attributes.html">in the reference</a>. Currently, you are not allowed to create your own attributes, the Rust compiler defines them.</p>

</div><div id = "chapter-35" class = "chapter">
  <h2 id = "link-180">Type Aliases</h2>
<p id = "para-885">The <code>type</code> keyword lets you declare an alias of another type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">;
</span></pre><p id = "para-886">You can then use this type as if it were a real type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span></pre><p id = "para-887">Note, however, that this is an <em>alias</em>, not a new type entirely. In other words, because Rust is strongly typed, you’d expect a comparison between two different types to fail:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: </span><span style="font-weight:bold;color:#a71d5d;">i64 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> y {
   </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="color:#323232;">}
</span></pre><p id = "para-888">this gives</p>
<pre><span style="color:#323232;">error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
</span></pre><p id = "para-889">But, if we had an alias:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Num </span><span style="font-weight:bold;color:#a71d5d;">= i32</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y: Num </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> y {
   </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="color:#323232;">}
</span></pre><p id = "para-890">This compiles without error. Values of a <code>Num</code> type are the same as a value of type <code>i32</code>, in every way. You can use <a href = "#chapter-19">tuple struct</a> to really get a new type.</p>
<p id = "para-891">You can also use type aliases with generics:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::result;

</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">ConcreteError {
    Foo,
    Bar,
}

</span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Result</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">T</span><span style="font-weight:bold;color:#a71d5d;">&gt; = </span><span style="color:#323232;">result::Result&lt;T, ConcreteError&gt;;
</span></pre><p id = "para-892">This creates a specialized version of the <code>Result</code> type, which always has a <code>ConcreteError</code> for the <code>E</code> part of <code>Result&lt;T, E&gt;</code>. This is commonly used in the standard library to create custom errors for each subsection. For example, <a href = "src/../../std/io/type.Result.html">io::Result</a>.</p>

</div><div id = "chapter-36" class = "chapter">
  <h2 id = "link-181">Casting Between Types</h2>
<p id = "para-893">Rust, with its focus on safety, provides two different ways of casting different types between each other. The first, <code>as</code>, is for safe casts. In contrast, <code>transmute</code> allows for arbitrary casting, and is one of the most dangerous features of Rust!</p>
<h2 id = "link-182">Coercion</h2>
<p id = "para-894">Coercion between types is implicit and has no syntax of its own, but can be spelled out with <a href = "src/#explicit-coercions"><code>as</code></a>.</p>
<p id = "para-895">Coercion occurs in <code>let</code>, <code>const</code>, and <code>static</code> statements; in function call arguments; in field values in struct initialization; and in a function result.</p>
<p id = "para-896">The most common case of coercion is removing mutability from a reference:</p>
<ul>
<li><code>&amp;mut T</code> to <code>&amp;T</code></li>
</ul>
<p id = "para-897">An analogous conversion is to remove mutability from a <a href = "#chapter-42">raw pointer</a>:</p>
<ul>
<li><code>*mut T</code> to <code>*const T</code></li>
</ul>
<p id = "para-898">References can also be coerced to raw pointers:</p>
<ul>
<li><p id = "para-899"><code>&amp;T</code> to <code>*const T</code></p>
</li>
<li><p id = "para-900"><code>&amp;mut T</code> to <code>*mut T</code></p>
</li>
</ul>
<p id = "para-901">Custom coercions may be defined using <a href = "#chapter-40"><code>Deref</code></a>.</p>
<p id = "para-902">Coercion is transitive.</p>
<h2 id = "link-183"><code>as</code></h2>
<p id = "para-903">The <code>as</code> keyword does safe casting:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">as i64</span><span style="color:#323232;">;
</span></pre><p id = "para-904">There are three major categories of safe cast: explicit coercions, casts between numeric types, and pointer casts.</p>
<p id = "para-905">Casting is not transitive: even if <code>e as U1 as U2</code> is a valid expression, <code>e as U2</code> is not necessarily so (in fact it will only be valid if <code>U1</code> coerces to <code>U2</code>).</p>
<h3 id = "link-184">Explicit coercions</h3>
<p id = "para-906">A cast <code>e as U</code> is valid if <code>e</code> has type <code>T</code> and <code>T</code> <em>coerces</em> to <code>U</code>.</p>
<h3 id = "link-185">Numeric casts</h3>
<p id = "para-907">A cast <code>e as U</code> is also valid in any of the following cases:</p>
<ul>
<li><code>e</code> has type <code>T</code> and <code>T</code> and <code>U</code> are any numeric types; <em>numeric-cast</em></li>
<li><code>e</code> is an enum with no data attached to the variants (a “field-less enumeration”), and <code>U</code> is an integer type; <em>enum-cast</em></li>
<li><code>e</code> has type <code>bool</code> or <code>char</code> and <code>U</code> is an integer type; <em>prim-int-cast</em></li>
<li><code>e</code> has type <code>u8</code> and <code>U</code> is <code>char</code>; <em>u8-char-cast</em></li>
</ul>
<p id = "para-908">For example</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> one </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">true </span><span style="font-weight:bold;color:#a71d5d;">as u8</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> at_sign </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">64 </span><span style="font-weight:bold;color:#a71d5d;">as char</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> two_hundred </span><span style="font-weight:bold;color:#a71d5d;">= -</span><span style="color:#0086b3;">56</span><span style="font-weight:bold;color:#a71d5d;">i8 as u8</span><span style="color:#323232;">;
</span></pre><p id = "para-909">The semantics of numeric casts are:</p>
<ul>
<li>Casting between two integers of the same size (e.g. i32 -&gt; u32) is a no-op</li>
<li>Casting from a larger integer to a smaller integer (e.g. u32 -&gt; u8) will truncate</li>
<li>Casting from a smaller integer to a larger integer (e.g. u8 -&gt; u32) will<ul>
<li>zero-extend if the source is unsigned</li>
<li>sign-extend if the source is signed</li>
</ul>
</li>
<li>Casting from a float to an integer will round the float towards zero<ul>
<li><b><a href = "https://github.com/rust-lang/rust/issues/10184">NOTE: currently this will cause Undefined Behavior if the rounded value cannot be represented by the target integer type</a></b>. This includes Inf and NaN. This is a bug and will be fixed.</li>
</ul>
</li>
<li>Casting from an integer to float will produce the floating point representation of the integer, rounded if necessary (rounding strategy unspecified)</li>
<li>Casting from an f32 to an f64 is perfect and lossless</li>
<li>Casting from an f64 to an f32 will produce the closest possible value (rounding strategy unspecified)<ul>
<li><b><a href = "https://github.com/rust-lang/rust/issues/15536">NOTE: currently this will cause Undefined Behavior if the value is finite but larger or smaller than the largest or smallest finite value representable by f32</a></b>. This is a bug and will be fixed.</li>
</ul>
</li>
</ul>
<h3 id = "link-186">Pointer casts</h3>
<p id = "para-910">Perhaps surprisingly, it is safe to cast <a href = "#chapter-42">raw pointers</a> to and from integers, and to cast between pointers to different types subject to some constraints. It is only unsafe to dereference the pointer:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">300 </span><span style="font-weight:bold;color:#a71d5d;">as *const char</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// `a` is a pointer to location 300.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">as u32</span><span style="color:#323232;">;
</span></pre><p id = "para-911"><code>e as U</code> is a valid pointer cast in any of the following cases:</p>
<ul>
<li><p id = "para-912"><code>e</code> has type <code>*T</code>, <code>U</code> has type <code>*U_0</code>, and either <code>U_0: Sized</code> or <code>unsize_kind(T) == unsize_kind(U_0)</code>; a <em>ptr-ptr-cast</em></p>
</li>
<li><p id = "para-913"><code>e</code> has type <code>*T</code> and <code>U</code> is a numeric type, while <code>T: Sized</code>; <em>ptr-addr-cast</em></p>
</li>
<li><p id = "para-914"><code>e</code> is an integer and <code>U</code> is <code>*U_0</code>, while <code>U_0: Sized</code>; <em>addr-ptr-cast</em></p>
</li>
<li><p id = "para-915"><code>e</code> has type <code>&amp;[T; n]</code> and <code>U</code> is <code>*const T</code>; <em>array-ptr-cast</em></p>
</li>
<li><p id = "para-916"><code>e</code> is a function pointer type and <code>U</code> has type <code>*T</code>, while <code>T: Sized</code>; <em>fptr-ptr-cast</em></p>
</li>
<li><p id = "para-917"><code>e</code> is a function pointer type and <code>U</code> is an integer; <em>fptr-addr-cast</em></p>
</li>
</ul>
<h2 id = "link-187"><code>transmute</code></h2>
<p id = "para-918"><code>as</code> only allows safe casting, and will for example reject an attempt to cast four bytes into a <code>u32</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">as u32</span><span style="color:#323232;">; </span><span style="font-style:italic;color:#969896;">// Four u8s makes a u32.
</span></pre><p id = "para-919">This errors with:</p>
<pre><span style="color:#323232;">error: non-scalar cast: `[u8; 4]` as `u32`
let b = a as u32; // Four u8s makes a u32.
        ^~~~~~~~
</span></pre><p id = "para-920">This is a ‘non-scalar cast’ because we have multiple values here: the four elements of the array. These kinds of casts are very dangerous, because they make assumptions about the way that multiple underlying structures are implemented. For this, we need something more dangerous.</p>
<p id = "para-921">The <code>transmute</code> function is very simple, but very scary. It tells Rust to treat a value of one type as though it were another type. It does this regardless of the typechecking system, and completely trusts you.</p>
<p id = "para-922">In our previous example, we know that an array of four <code>u8</code>s represents a <code>u32</code> properly, and so we want to do the cast. Using <code>transmute</code> instead of <code>as</code>, Rust lets us:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::mem;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">];
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">mem::transmute::&lt;[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">; </span><span style="color:#0086b3;">4</span><span style="color:#323232;">], </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">&gt;(a);
        println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, b); </span><span style="font-style:italic;color:#969896;">// 256
        // Or, more concisely:
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c: </span><span style="font-weight:bold;color:#a71d5d;">u32 = </span><span style="color:#323232;">mem::transmute(a);
        println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, c); </span><span style="font-style:italic;color:#969896;">// 256
    </span><span style="color:#323232;">}
}
</span></pre><p id = "para-923">We have to wrap the operation in an <code>unsafe</code> block for this to compile successfully. Technically, only the <code>mem::transmute</code> call itself needs to be in the block, but it’s nice in this case to enclose everything related, so you know where to look. In this case, the details about <code>a</code> are also important, and so they’re in the block. You’ll see code in either style, sometimes the context is too far away, and wrapping all of the code in <code>unsafe</code> isn’t a great idea.</p>
<p id = "para-924">While <code>transmute</code> does very little checking, it will at least make sure that the types are the same size. This errors:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::mem;

</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">[</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">mem::transmute::&lt;[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">; </span><span style="color:#0086b3;">4</span><span style="color:#323232;">], </span><span style="font-weight:bold;color:#a71d5d;">u64</span><span style="color:#323232;">&gt;(a);
}
</span></pre><p id = "para-925">with:</p>
<pre><span style="color:#323232;">error: transmute called with differently sized types: [u8; 4] (32 bits) to u64
(64 bits)
</span></pre><p id = "para-926">Other than that, you’re on your own!</p>

</div><div id = "chapter-37" class = "chapter">
  <h2 id = "link-188">Associated Types</h2>
<p id = "para-927">Associated types are a powerful part of Rust’s type system. They’re related to the idea of a ‘type family’, in other words, grouping multiple types together. That description is a bit abstract, so let’s dive right into an example. If you want to write a <code>Graph</code> trait, you have two types to be generic over: the node type and the edge type. So you might write a trait, <code>Graph&lt;N, E&gt;</code>, that looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Graph&lt;N, E&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">N) -&gt; Vec&lt;E&gt;;
    </span><span style="font-style:italic;color:#969896;">// Etc.
</span><span style="color:#323232;">}
</span></pre><p id = "para-928">While this sort of works, it ends up being awkward. For example, any function that wants to take a <code>Graph</code> as a parameter now <em>also</em> needs to be generic over the <code>N</code>ode and <code>E</code>dge types too:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">distance</span><span style="color:#323232;">&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">G, start: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">N, end: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">u32 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#323232;">}
</span></pre><p id = "para-929">Our distance calculation works regardless of our <code>Edge</code> type, so the <code>E</code> stuff in this signature is a distraction.</p>
<p id = "para-930">What we really want to say is that a certain <code>E</code>dge and <code>N</code>ode type come together to form each kind of <code>Graph</code>. We can do that with associated types:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Graph {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">N;
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">E;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
    </span><span style="font-style:italic;color:#969896;">// Etc.
</span><span style="color:#323232;">}
</span></pre><p id = "para-931">Now, our clients can be abstract over a given <code>Graph</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">distance</span><span style="color:#323232;">&lt;G: Graph&gt;(graph: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">G, start: </span><span style="font-weight:bold;color:#a71d5d;">&amp;G::</span><span style="color:#323232;">N, end: </span><span style="font-weight:bold;color:#a71d5d;">&amp;G::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">u32 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#323232;">}
</span></pre><p id = "para-932">No need to deal with the <code>E</code>dge type here!</p>
<p id = "para-933">Let’s go over all this in more detail.</p>
<h3 id = "link-189">Defining associated types</h3>
<p id = "para-934">Let’s build that <code>Graph</code> trait. Here’s the definition:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Graph {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">N;
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">E;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
}
</span></pre><p id = "para-935">Simple enough. Associated types use the <code>type</code> keyword, and go inside the body of the trait, with the functions.</p>
<p id = "para-936">These type declarations work the same way as those for functions. For example, if we wanted our <code>N</code> type to implement <code>Display</code>, so we can print the nodes out, we could do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt;

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Graph {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">N: fmt::Display;
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">E;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
}
</span></pre><h3 id = "link-190">Implementing associated types</h3>
<p id = "para-937">Just like any trait, traits that use associated types use the <code>impl</code> keyword to provide implementations. Here’s a simple implementation of Graph:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Graph {
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">N;
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">E;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Node;

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Edge;

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">MyGraph;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Graph </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">MyGraph {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">N </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Node;
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">E </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Edge;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n1: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node, n2: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">true
    </span><span style="color:#323232;">}

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; Vec&lt;Edge&gt; {
        </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new()
    }
}
</span></pre><p id = "para-938">This silly implementation always returns <code>true</code> and an empty <code>Vec&lt;Edge&gt;</code>, but it gives you an idea of how to implement this kind of thing. We first need three <code>struct</code>s, one for the graph, one for the node, and one for the edge. If it made more sense to use a different type, that would work as well, we’re going to use <code>struct</code>s for all three here.</p>
<p id = "para-939">Next is the <code>impl</code> line, which is an implementation like any other trait.</p>
<p id = "para-940">From here, we use <code>=</code> to define our associated types. The name the trait uses goes on the left of the <code>=</code>, and the concrete type we’re <code>impl</code>ementing this for goes on the right. Finally, we use the concrete types in our function declarations.</p>
<h3 id = "link-191">Trait objects with associated types</h3>
<p id = "para-941">There’s one more bit of syntax we should talk about: trait objects. If you try to create a trait object from a trait with an associated type, like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Graph {
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">N;
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">E;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Node;
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Edge;
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">MyGraph;
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Graph </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">MyGraph {
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">N </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Node;
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">E </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Edge;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n1: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node, n2: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#         </span><span style="color:#0086b3;">true
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; Vec&lt;Edge&gt; {
</span><span style="font-weight:bold;color:#a71d5d;">#         </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new()
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> graph </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> MyGraph;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> obj </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(graph) </span><span style="font-weight:bold;color:#a71d5d;">as </span><span style="color:#323232;">Box&lt;Graph&gt;;
</span></pre><p id = "para-942">You’ll get two errors:</p>
<pre><span style="color:#323232;">error: the value of the associated type `E` (from the trait `main::Graph`) must
be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Graph`) must be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span></pre><p id = "para-943">We can’t create a trait object like this, because we don’t know the associated types. Instead, we can write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># trait </span><span style="color:#323232;">Graph {
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">N;
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">E;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, </span><span style="font-weight:bold;color:#a71d5d;">&amp;Self::</span><span style="color:#323232;">N) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">E&gt;;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Node;
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Edge;
</span><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">MyGraph;
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">Graph </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">MyGraph {
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">N </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Node;
</span><span style="font-weight:bold;color:#a71d5d;">#     type </span><span style="color:#323232;">E </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Edge;
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">has_edge</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n1: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node, n2: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#         </span><span style="color:#0086b3;">true
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">edges</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, n: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Node) -&gt; Vec&lt;Edge&gt; {
</span><span style="font-weight:bold;color:#a71d5d;">#         </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new()
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> graph </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> MyGraph;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> obj </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(graph) </span><span style="font-weight:bold;color:#a71d5d;">as </span><span style="color:#323232;">Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;
</span></pre><p id = "para-944">The <code>N=Node</code> syntax allows us to provide a concrete type, <code>Node</code>, for the <code>N</code> type parameter. Same with <code>E=Edge</code>. If we didn’t provide this constraint, we couldn’t be sure which <code>impl</code> to match this trait object to.</p>

</div><div id = "chapter-38" class = "chapter">
  <h2 id = "link-192">Unsized Types</h2>
<p id = "para-945">Most types have a particular size, in bytes, that is knowable at compile time. For example, an <code>i32</code> is thirty-two bits big, or four bytes. However, there are some types which are useful to express, but do not have a defined size. These are called ‘unsized’ or ‘dynamically sized’ types. One example is <code>[T]</code>. This type represents a certain number of <code>T</code> in sequence. But we don’t know how many there are, so the size is not known.</p>
<p id = "para-946">Rust understands a few of these types, but they have some restrictions. There are three:</p>
<ol>
<li>We can only manipulate an instance of an unsized type via a pointer. An <code>&amp;[T]</code> works fine, but a <code>[T]</code> does not.</li>
<li>Variables and arguments cannot have dynamically sized types.</li>
<li>Only the last field in a <code>struct</code> may have a dynamically sized type; the other fields must not. Enum variants must not have dynamically sized types as data.</li>
</ol>
<p id = "para-947">So why bother? Well, because <code>[T]</code> can only be used behind a pointer, if we didn’t have language support for unsized types, it would be impossible to write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">str {
</span></pre><p id = "para-948">or</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T&gt; Foo </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> [T] {
</span></pre><p id = "para-949">Instead, you would have to write:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo </span><span style="font-weight:bold;color:#a71d5d;">for &amp;</span><span style="color:#323232;">str {
</span></pre><p id = "para-950">Meaning, this implementation would only work for <a href = "#chapter-16">references</a>, and not other types of pointers. With the <code>impl for str</code>, all pointers, including (at some point, there are some bugs to fix first) user-defined custom smart pointers, can use this <code>impl</code>.</p>
<h2 id = "link-193">?Sized</h2>
<p id = "para-951">If you want to write a function that accepts a dynamically sized type, you can use the special bound syntax, <code>?Sized</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo&lt;T: </span><span style="font-weight:bold;color:#b52a1d;">?</span><span style="color:#323232;">Sized&gt; {
    f: T,
}
</span></pre><p id = "para-952">This <code>?Sized</code>, read as “T may or may not be <code>Sized</code>”, which allows us to match both sized and unsized types. All generic type parameters implicitly have the <code>Sized</code> bound, so the <code>?Sized</code> can be used to opt-out of the implicit bound.</p>

</div><div id = "chapter-39" class = "chapter">
  <h2 id = "link-194">Operators and Overloading</h2>
<p id = "para-953">Rust allows for a limited form of operator overloading. There are certain operators that are able to be overloaded. To support a particular operator between types, there’s a specific trait that you can implement, which then overloads the operator.</p>
<p id = "para-954">For example, the <code>+</code> operator can be overloaded with the <code>Add</code> trait:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::ops::Add;

#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Add </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Point {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Output </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add</span><span style="color:#323232;">(self, other: Point) -&gt; Point {
        Point { x: self.x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> other.x, y: self.y </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> other.y }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p1 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">};
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p2 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Point { x: </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, y: </span><span style="color:#0086b3;">3 </span><span style="color:#323232;">};

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p3 </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> p1 </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> p2;

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, p3);
}
</span></pre><p id = "para-955">In <code>main</code>, we can use <code>+</code> on our two <code>Point</code>s, since we’ve implemented <code>Add&lt;Output=Point&gt;</code> for <code>Point</code>.</p>
<p id = "para-956">There are a number of operators that can be overloaded this way, and all of their associated traits live in the <a href = "src/../../std/ops/index.html"><code>std::ops</code></a> module. Check out its documentation for the full list.</p>
<p id = "para-957">Implementing these traits follows a pattern. Let’s look at <a href = "src/../../std/ops/trait.Add.html"><code>Add</code></a> in more detail:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># mod </span><span style="color:#323232;">foo {
</span><span style="font-weight:bold;color:#a71d5d;">pub trait </span><span style="color:#323232;">Add&lt;RHS = Self&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Output;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add</span><span style="color:#323232;">(self, rhs: RHS) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self::</span><span style="color:#323232;">Output;
}
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-958">There’s three types in total involved here: the type you <code>impl Add</code> for, <code>RHS</code>, which defaults to <code>Self</code>, and <code>Output</code>. For an expression <code>let z = x + y</code>, <code>x</code> is the <code>Self</code> type, <code>y</code> is the RHS, and <code>z</code> is the <code>Self::Output</code> type.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># struct </span><span style="color:#323232;">Point;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::ops::Add;
</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Add&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Point {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Output </span><span style="font-weight:bold;color:#a71d5d;">= f64</span><span style="color:#323232;">;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">add</span><span style="color:#323232;">(self, rhs: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">f64 </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Add an i32 to a Point and get an f64.
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#0086b3;">1.0
    </span><span style="color:#323232;">}
}
</span></pre><p id = "para-959">will let you do this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p: Point </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="font-style:italic;color:#969896;">// ...
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: </span><span style="font-weight:bold;color:#a71d5d;">f64 =</span><span style="color:#323232;"> p </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;
</span></pre><h2 id = "link-195">Using operator traits in generic structs</h2>
<p id = "para-960">Now that we know how operator traits are defined, we can define our <code>HasArea</code> trait and <code>Square</code> struct from the <a href = "#chapter-26">traits chapter</a> more generically:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::ops::Mul;

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">HasArea&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; T;
}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T&gt; HasArea&lt;T&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Square&lt;T&gt;
        </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> T: Mul&lt;Output=T&gt; + Copy {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">area</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; T {
        self.side </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">self.side
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> Square {
        x: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        y: </span><span style="color:#0086b3;">0.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
        side: </span><span style="color:#0086b3;">12.0</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">,
    };

    println!(</span><span style="color:#183691;">&quot;Area of s: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, s.</span><span style="color:#62a35c;">area</span><span style="color:#323232;">());
}
</span></pre><p id = "para-961">For <code>HasArea</code> and <code>Square</code>, we declare a type parameter <code>T</code> and replace <code>f64</code> with it. The <code>impl</code> needs more involved modifications:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T&gt; HasArea&lt;T&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Square&lt;T&gt;
        </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> T: Mul&lt;Output=T&gt; + Copy { </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#323232;">}
</span></pre><p id = "para-962">The <code>area</code> method requires that we can multiply the sides, so we declare that type <code>T</code> must implement <code>std::ops::Mul</code>. Like <code>Add</code>, mentioned above, <code>Mul</code> itself takes an <code>Output</code> parameter: since we know that numbers don’t change type when multiplied, we also set it to <code>T</code>. <code>T</code> must also support copying, so Rust doesn’t try to move <code>self.side</code> into the return value.</p>

</div><div id = "chapter-40" class = "chapter">
  <h2 id = "link-196"><code>Deref</code> coercions</h2>
<p id = "para-963">The standard library provides a special trait, <a href = "src/../../std/ops/trait.Deref.html"><code>Deref</code></a>. It’s normally used to overload <code>*</code>, the dereference operator:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::ops::Deref;

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">DerefExample&lt;T&gt; {
    value: T,
}

</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T&gt; Deref </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">DerefExample&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Target </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> T;

    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">deref</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">T {
        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self.value
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> DerefExample { value: </span><span style="color:#183691;">&#39;a&#39; </span><span style="color:#323232;">};
    assert_eq!(</span><span style="color:#183691;">&#39;a&#39;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">x);
}
</span></pre><p id = "para-964">This is useful for writing custom pointer types. However, there’s a language feature related to <code>Deref</code>: ‘deref coercions’. Here’s the rule: If you have a type <code>U</code>, and it implements <code>Deref&lt;Target=T&gt;</code>, values of <code>&amp;U</code> will automatically coerce to a <code>&amp;T</code>. Here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) {
    </span><span style="font-style:italic;color:#969896;">// Borrow a string for a second.
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// String implements Deref&lt;Target=str&gt;.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> owned </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();

</span><span style="font-style:italic;color:#969896;">// Therefore, this works:
</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">owned);
</span></pre><p id = "para-965">Using an ampersand in front of a value takes a reference to it. So <code>owned</code> is a <code>String</code>, <code>&amp;owned</code> is an <code>&amp;String</code>, and since <code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> will deref to <code>&amp;str</code>, which <code>foo()</code> takes.</p>
<p id = "para-966">That’s it. This rule is one of the only places in which Rust does an automatic conversion for you, but it adds a lot of flexibility. For example, the <code>Rc&lt;T&gt;</code> type implements <code>Deref&lt;Target=T&gt;</code>, so this works:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::rc::Rc;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) {
    </span><span style="font-style:italic;color:#969896;">// Borrow a string for a second.
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// String implements Deref&lt;Target=str&gt;.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> owned </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> counted </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Rc::new(owned);

</span><span style="font-style:italic;color:#969896;">// Therefore, this works:
</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">counted);
</span></pre><p id = "para-967">All we’ve done is wrap our <code>String</code> in an <code>Rc&lt;T&gt;</code>. But we can now pass the <code>Rc&lt;String&gt;</code> around anywhere we’d have a <code>String</code>. The signature of <code>foo</code> didn’t change, but works just as well with either type. This example has two conversions: <code>&amp;Rc&lt;String&gt;</code> to <code>&amp;String</code> and then <code>&amp;String</code> to <code>&amp;str</code>. Rust will do this as many times as possible until the types match.</p>
<p id = "para-968">Another very common implementation provided by the standard library is:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(s: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">]) {
    </span><span style="font-style:italic;color:#969896;">// Borrow a slice for a second.
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// Vec&lt;T&gt; implements Deref&lt;Target=[T]&gt;.
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> owned </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">owned);
</span></pre><p id = "para-969">Vectors can <code>Deref</code> to a slice.</p>
<h3 id = "link-197">Deref and method calls</h3>
<p id = "para-970"><code>Deref</code> will also kick in when calling a method. Consider the following example.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Foo {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) { println!(</span><span style="color:#183691;">&quot;Foo&quot;</span><span style="color:#323232;">); }
}

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= &amp;&amp;</span><span style="color:#323232;">Foo;

f.</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
</span></pre><p id = "para-971">Even though <code>f</code> is a <code>&amp;&amp;Foo</code> and <code>foo</code> takes <code>&amp;self</code>, this works. That’s because these things are the same:</p>
<pre><span style="color:#323232;">f.</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">f).</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&amp;</span><span style="color:#323232;">f).</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
(</span><span style="font-weight:bold;color:#a71d5d;">&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;</span><span style="color:#323232;">f).</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
</span></pre><p id = "para-972">A value of type <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code> can still have methods defined on <code>Foo</code> called, because the compiler will insert as many * operations as necessary to get it right. And since it’s inserting <code>*</code>s, that uses <code>Deref</code>.</p>

</div><div id = "chapter-41" class = "chapter">
  <h2 id = "link-198">Macros</h2>
<p id = "para-973">By now you’ve learned about many of the tools Rust provides for abstracting and reusing code. These units of code reuse have a rich semantic structure. For example, functions have a type signature, type parameters have trait bounds, and overloaded functions must belong to a particular trait.</p>
<p id = "para-974">This structure means that Rust’s core abstractions have powerful compile-time correctness checking. But this comes at the price of reduced flexibility. If you visually identify a pattern of repeated code, you may find it’s difficult or cumbersome to express that pattern as a generic function, a trait, or anything else within Rust’s semantics.</p>
<p id = "para-975">Macros allow us to abstract at a syntactic level. A macro invocation is shorthand for an “expanded” syntactic form. This expansion happens early in compilation, before any static checking. As a result, macros can capture many patterns of code reuse that Rust’s core abstractions cannot.</p>
<p id = "para-976">The drawback is that macro-based code can be harder to understand, because fewer of the built-in rules apply. Like an ordinary function, a well-behaved macro can be used without understanding its implementation. However, it can be difficult to design a well-behaved macro! Additionally, compiler errors in macro code are harder to interpret, because they describe problems in the expanded code, not the source-level form that developers use.</p>
<p id = "para-977">These drawbacks make macros something of a “feature of last resort”. That’s not to say that macros are bad; they are part of Rust because sometimes they’re needed for truly concise, well-abstracted code. Just keep this tradeoff in mind.</p>
<h2 id = "link-199">Defining a macro</h2>
<p id = "para-978">You may have seen the <code>vec!</code> macro, used to initialize a <a href = "#chapter-14">vector</a> with any number of elements.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">assert_eq!(x, [</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]);
</span></pre><p id = "para-979">This can’t be an ordinary function, because it takes any number of arguments. But we can imagine it as syntactic shorthand for</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> temp_vec </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new();
    temp_vec.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
    temp_vec.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">);
    temp_vec.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
    temp_vec
};
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">assert_eq!(x, [</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]);
</span></pre><p id = "para-981">We can implement this shorthand, using a macro: <a href = "#note-dest-1"><sup id = "note-source-1">[1]</sup></a></p>
 <pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">vec {
    ( </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">( $x:expr ),</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
        {
            </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> temp_vec </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::new();
            </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">(
                temp_vec.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">($x);
            )</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">
            temp_vec
        }
    };
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">assert_eq!(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">,</span><span style="color:#0086b3;">2</span><span style="color:#323232;">,</span><span style="color:#0086b3;">3</span><span style="color:#323232;">], [</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]);
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-982">Whoa, that’s a lot of new syntax! Let’s break it down.</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">vec { ... }
</span></pre><p id = "para-983">This says we’re defining a macro named <code>vec</code>, much as <code>fn vec</code> would define a function named <code>vec</code>. In prose, we informally write a macro’s name with an exclamation point, e.g. <code>vec!</code>. The exclamation point is part of the invocation syntax and serves to distinguish a macro from an ordinary function.</p>
<h3 id = "link-200">Matching</h3>
<p id = "para-984">The macro is defined through a series of rules, which are pattern-matching cases. Above, we had</p>
<pre><span style="color:#323232;">( </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">( $x:expr ),</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">... </span><span style="color:#323232;">};
</span></pre><p id = "para-985">This is like a <code>match</code> expression arm, but the matching happens on Rust syntax trees, at compile time. The semicolon is optional on the last (here, only) case. The “pattern” on the left-hand side of <code>=&gt;</code> is known as a ‘matcher’. These have <a href = "src/../../reference/macros.html">their own little grammar</a> within the language.</p>
<p id = "para-986">The matcher <code>$x:expr</code> will match any Rust expression, binding that syntax tree to the ‘metavariable’ <code>$x</code>. The identifier <code>expr</code> is a ‘fragment specifier’; the full possibilities are enumerated later in this chapter. Surrounding the matcher with <code>$(...),*</code> will match zero or more expressions, separated by commas.</p>
<p id = "para-987">Aside from the special matcher syntax, any Rust tokens that appear in a matcher must match exactly. For example,</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">foo {
    (x =&gt; $e:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(println!(</span><span style="color:#183691;">&quot;mode X: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, $e));
    (y =&gt; $e:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(println!(</span><span style="color:#183691;">&quot;mode Y: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, $e));
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    foo!(y </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
}
</span></pre><p id = "para-988">will print</p>
<pre><span style="color:#323232;">mode Y: 3
</span></pre><p id = "para-989">With</p>
<pre><span style="color:#323232;">foo!(z </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
</span></pre><p id = "para-990">we get the compiler error</p>
<pre><span style="color:#323232;">error: no rules expected the token `z`
</span></pre><h3 id = "link-201">Expansion</h3>
<p id = "para-991">The right-hand side of a macro rule is ordinary Rust syntax, for the most part. But we can splice in bits of syntax captured by the matcher. From the original example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">(
    temp_vec.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">($x);
)</span><span style="font-weight:bold;color:#a71d5d;">*
</span></pre><p id = "para-992">Each matched expression <code>$x</code> will produce a single <code>push</code> statement in the macro expansion. The repetition in the expansion proceeds in “lockstep” with repetition in the matcher (more on this in a moment).</p>
<p id = "para-993">Because <code>$x</code> was already declared as matching an expression, we don’t repeat <code>:expr</code> on the right-hand side. Also, we don’t include a separating comma as part of the repetition operator. Instead, we have a terminating semicolon within the repeated block.</p>
<p id = "para-994">Another detail: the <code>vec!</code> macro has <em>two</em> pairs of braces on the right-hand side. They are often combined like so:</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">foo {
    () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{{
        </span><span style="font-weight:bold;color:#a71d5d;">...
    </span><span style="color:#323232;">}}
}
</span></pre><p id = "para-995">The outer braces are part of the syntax of <code>macro_rules!</code>. In fact, you can use <code>()</code> or <code>[]</code> instead. They simply delimit the right-hand side as a whole.</p>
<p id = "para-996">The inner braces are part of the expanded syntax. Remember, the <code>vec!</code> macro is used in an expression context. To write an expression with multiple statements, including <code>let</code>-bindings, we use a block. If your macro expands to a single expression, you don’t need this extra layer of braces.</p>
<p id = "para-997">Note that we never <em>declared</em> that the macro produces an expression. In fact, this is not determined until we use the macro as an expression. With care, you can write a macro whose expansion works in several contexts. For example, shorthand for a data type could be valid as either an expression or a pattern.</p>
<h3 id = "link-202">Repetition</h3>
<p id = "para-998">The repetition operator follows two principal rules:</p>
<ol>
<li><code>$(...)*</code> walks through one “layer” of repetitions, for all of the <code>$name</code>s it contains, in lockstep, and</li>
<li>each <code>$name</code> must be under at least as many <code>$(...)*</code>s as it was matched against. If it is under more, it’ll be duplicated, as appropriate.</li>
</ol>
<p id = "para-999">This baroque macro illustrates the duplication of variables from outer repetition levels.</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">o_O {
    (
        </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">(
            $x:expr; [ $( $y:expr ),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ]
        );*
    ) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[ </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">( $x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#323232;">$y ),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">),</span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">]
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">]
        </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> o_O</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#323232;">(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">; [</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];
               </span><span style="color:#0086b3;">20</span><span style="color:#323232;">; [</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">]);

    assert_eq!(a, [</span><span style="color:#0086b3;">11</span><span style="color:#323232;">, </span><span style="color:#0086b3;">12</span><span style="color:#323232;">, </span><span style="color:#0086b3;">13</span><span style="color:#323232;">, </span><span style="color:#0086b3;">24</span><span style="color:#323232;">, </span><span style="color:#0086b3;">25</span><span style="color:#323232;">, </span><span style="color:#0086b3;">26</span><span style="color:#323232;">]);
}
</span></pre><p id = "para-1000">That’s most of the matcher syntax. These examples use <code>$(...)*</code>, which is a “zero or more” match. Alternatively you can write <code>$(...)+</code> for a “one or more” match. Both forms optionally include a separator, which can be any token except <code>+</code> or <code>*</code>.</p>
<p id = "para-1001">This system is based on "<a href = "https://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>" (PDF link).</p>
<h2 id = "link-203">Hygiene</h2>
<p id = "para-1002">Some languages implement macros using simple text substitution, which leads to various problems. For example, this C program prints <code>13</code> instead of the expected <code>25</code>.</p>
<pre><span style="color:#323232;">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</span></pre><p id = "para-1003">After expansion we have <code>5 * 2 + 3</code>, and multiplication has greater precedence than addition. If you’ve used C macros a lot, you probably know the standard idioms for avoiding this problem, as well as five or six others. In Rust, we don’t have to worry about it.</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">five_times {
    ($x:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">* </span><span style="color:#323232;">$x);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">25</span><span style="color:#323232;">, five_times!(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">3</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1004">The metavariable <code>$x</code> is parsed as a single expression node, and keeps its place in the syntax tree even after substitution.</p>
<p id = "para-1005">Another common problem in macro systems is ‘variable capture’. Here’s a C macro using a block with multiple statements.</p>
<pre><span style="color:#323232;">#define LOG(msg) do { \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
} while (0)
</span></pre><p id = "para-1006">Here’s a simple use case that goes terribly wrong:</p>
<pre><span style="color:#323232;">const char *state = &quot;reticulating splines&quot;;
LOG(state);
</span></pre><p id = "para-1007">This expands to</p>
<pre><span style="color:#323232;">const char *state = &quot;reticulating splines&quot;;
do {
    int state = get_log_state();
    if (state &gt; 0) {
        printf(&quot;log(%d): %s\n&quot;, state, state);
    }
} while (0);
</span></pre><p id = "para-1008">The second variable named <code>state</code> shadows the first one. This is a problem because the print statement should refer to both of them.</p>
<p id = "para-1009">The equivalent Rust macro has the desired behavior.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">get_log_state</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ </span><span style="color:#0086b3;">3 </span><span style="color:#323232;">}
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">log {
    ($msg:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> state: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#62a35c;">get_log_state</span><span style="color:#323232;">();
        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> state </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{
            println!(</span><span style="color:#183691;">&quot;log(</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">): </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, state, $msg);
        }
    }};
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> state: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str = </span><span style="color:#183691;">&quot;reticulating splines&quot;</span><span style="color:#323232;">;
    log!(state);
}
</span></pre><p id = "para-1010">This works because Rust has a <a href = "https://en.wikipedia.org/wiki/Hygienic_macro">hygienic macro system</a>. Each macro expansion happens in a distinct ‘syntax context’, and each variable is tagged with the syntax context where it was introduced. It’s as though the variable <code>state</code> inside <code>main</code> is painted a different “color” from the variable <code>state</code> inside the macro, and therefore they don’t conflict.</p>
<p id = "para-1011">This also restricts the ability of macros to introduce new bindings at the invocation site. Code such as the following will not work:</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">foo {
    () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    foo!();
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-1012">Instead you need to pass the variable name into the invocation, so that it’s tagged with the right syntax context.</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">foo {
    ($v:</span><span style="font-weight:bold;color:#a71d5d;">ident</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">$v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    foo!(x);
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-1013">This holds for <code>let</code> bindings and loop labels, but not for <a href = "src/../../reference/items.html">items</a>. So the following code does compile:</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">foo {
    () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">x</span><span style="color:#323232;">() { });
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    foo!();
    </span><span style="color:#62a35c;">x</span><span style="color:#323232;">();
}
</span></pre><h2 id = "link-204">Recursive macros</h2>
<p id = "para-1014">A macro’s expansion can include more macro invocations, including invocations of the very same macro being expanded. These recursive macros are useful for processing tree-structured input, as illustrated by this (simplistic) HTML shorthand:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">#![allow(unused_must_use)]
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">write_html {
    ($w:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">, ) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(());

    ($w:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">, $e:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(write!($w, </span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, $e));

    ($w:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">, $tag:</span><span style="font-weight:bold;color:#a71d5d;">ident</span><span style="color:#323232;"> [ </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($inner:tt)</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ] </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($rest:tt)</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{{
        write!($w, </span><span style="color:#183691;">&quot;&lt;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&gt;&quot;</span><span style="color:#323232;">, stringify!($tag));
        write_html!($w, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($inner)</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">);
        write!($w, </span><span style="color:#183691;">&quot;&lt;/</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&gt;&quot;</span><span style="color:#323232;">, stringify!($tag));
        write_html!($w, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($rest)</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">);
    }};
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;">#   </span><span style="font-style:italic;color:#969896;">// FIXME(#21826)
    </span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Write;
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> out </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();

    write_html!(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> out,
        html[
            head[title[</span><span style="color:#183691;">&quot;Macros guide&quot;</span><span style="color:#323232;">]]
            body[h1[</span><span style="color:#183691;">&quot;Macros are the best!&quot;</span><span style="color:#323232;">]]
        ]);

    assert_eq!(out,
        </span><span style="color:#183691;">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span><span style="color:#323232;">);
}
</span></pre><h2 id = "link-205">Debugging macro code</h2>
<p id = "para-1015">To see the results of expanding macros, run <code>rustc --pretty expanded</code>. The output represents a whole crate, so you can also feed it back in to <code>rustc</code>, which will sometimes produce better error messages than the original compilation. Note that the <code>--pretty expanded</code> output may have a different meaning if multiple variables of the same name (but different syntax contexts) are in play in the same scope. In this case <code>--pretty expanded,hygiene</code> will tell you about the syntax contexts.</p>
<p id = "para-1016"><code>rustc</code> provides two syntax extensions that help with macro debugging. For now, they are unstable and require feature gates.</p>
<ul>
<li><p id = "para-1017"><code>log_syntax!(...)</code> will print its arguments to standard output, at compile time, and “expand” to nothing.</p>
</li>
<li><p id = "para-1018"><code>trace_macros!(true)</code> will enable a compiler message every time a macro is expanded. Use <code>trace_macros!(false)</code> later in expansion to turn it off.</p>
</li>
</ul>
<h2 id = "link-206">Syntactic requirements</h2>
<p id = "para-1019">Even when Rust code contains un-expanded macros, it can be parsed as a full <a href = "#chapter-60">syntax tree</a>. This property can be very useful for editors and other tools that process code. It also has a few consequences for the design of Rust’s macro system.</p>
<p id = "para-1020">One consequence is that Rust must determine, when it parses a macro invocation, whether the macro stands in for</p>
<ul>
<li>zero or more items,</li>
<li>zero or more methods,</li>
<li>an expression,</li>
<li>a statement, or</li>
<li>a pattern.</li>
</ul>
<p id = "para-1021">A macro invocation within a block could stand for some items, or for an expression / statement. Rust uses a simple rule to resolve this ambiguity. A macro invocation that stands for items must be either</p>
<ul>
<li>delimited by curly braces, e.g. <code>foo! { ... }</code>, or</li>
<li>terminated by a semicolon, e.g. <code>foo!(...);</code></li>
</ul>
<p id = "para-1022">Another consequence of pre-expansion parsing is that the macro invocation must consist of valid Rust tokens. Furthermore, parentheses, brackets, and braces must be balanced within a macro invocation. For example, <code>foo!([)</code> is forbidden. This allows Rust to know where the macro invocation ends.</p>
<p id = "para-1023">More formally, the macro invocation body must be a sequence of ‘token trees’. A token tree is defined recursively as either</p>
<ul>
<li>a sequence of token trees surrounded by matching <code>()</code>, <code>[]</code>, or <code>{}</code>, or</li>
<li>any other single token.</li>
</ul>
<p id = "para-1024">Within a matcher, each metavariable has a ‘fragment specifier’, identifying which syntactic form it matches.</p>
<ul>
<li><code>ident</code>: an identifier. Examples: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: a qualified name. Example: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: an expression. Examples: <code>2 + 2</code>; <code>if true { 1 } else { 2 }</code>; <code>f(42)</code>.</li>
<li><code>ty</code>: a type. Examples: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: a pattern. Examples: <code>Some(t)</code>; <code>(17, ‘a’)</code>; <code>_</code>.</li>
<li><code>stmt</code>: a single statement. Example: <code>let x = 3</code>.</li>
<li><code>block</code>: a brace-delimited sequence of statements and optionally an expression. Example: <code>{ log(error, “hi”); return 12; }</code>.</li>
<li><code>item</code>: an <a href = "src/../../reference/items.html">item</a>. Examples: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: a “meta item”, as found in attributes. Example: <code>cfg(target_os = “windows”)</code>.</li>
<li><code>tt</code>: a single token tree.</li>
</ul>
<p id = "para-1025">There are additional rules regarding the next token after a metavariable:</p>
<ul>
<li><code>expr</code> and <code>stmt</code> variables may only be followed by one of: <code>=&gt; , ;</code></li>
<li><code>ty</code> and <code>path</code> variables may only be followed by one of: <code>=&gt; , = | ; : &gt; [ { as where</code></li>
<li><code>pat</code> variables may only be followed by one of: <code>=&gt; , = | if in</code></li>
<li>Other variables may be followed by any token.</li>
</ul>
<p id = "para-1026">These rules provide some flexibility for Rust’s syntax to evolve without breaking existing macros.</p>
<p id = "para-1027">The macro system does not deal with parse ambiguity at all. For example, the grammar <code>$($i:ident)* $e:expr</code> will always fail to parse, because the parser would be forced to choose between parsing <code>$i</code> and parsing <code>$e</code>. Changing the invocation syntax to put a distinctive token in front can solve the problem. In this case, you can write <code>$(I $i:ident)* E $e:expr</code>.</p>
<h2 id = "link-207">Scoping and macro import/export</h2>
<p id = "para-1028">Macros are expanded at an early stage in compilation, before name resolution. One downside is that scoping works differently for macros, compared to other constructs in the language.</p>
<p id = "para-1029">Definition and expansion of macros both happen in a single depth-first, lexical-order traversal of a crate’s source. So a macro defined at module scope is visible to any subsequent code in the same module, which includes the body of any subsequent child <code>mod</code> items. If you want to use your macro, which is defined in a different module, you need to use <code>macro_use</code> attribute <em>before</em> using the macro. Let’s say our macros are defined in module <code>macros</code> and we would like to use them inside module <code>client</code>. This is the required module definition order:</p>
<pre><span style="color:#323232;">#[macro_use]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">macros;
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">client;
</span></pre><p id = "para-1030">The opposite order would result in a compilation failure:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">client;
#[macro_use]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">macros;
</span></pre><pre><span style="color:#323232;">error: cannot find macro `my_macro!` in this scope
</span></pre><p id = "para-1031">A macro defined within the body of a single <code>fn</code>, or anywhere else not at module scope, is visible only within that item.</p>
<p id = "para-1032">If a module has the <code>macro_use</code> attribute, its macros are also visible in its parent module after the child’s <code>mod</code> item. If the parent also has <code>macro_use</code> then the macros will be visible in the grandparent after the parent’s <code>mod</code> item, and so forth.</p>
<p id = "para-1033">The <code>macro_use</code> attribute can also appear on <code>extern crate</code>. In this context it controls which macros are loaded from the external crate, e.g.</p>
<pre><span style="color:#323232;">#[macro_use(foo, bar)]
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> baz;
</span></pre><p id = "para-1034">If the attribute is given simply as <code>#[macro_use]</code>, all macros are loaded. If there is no <code>#[macro_use]</code> attribute then no macros are loaded. Only macros defined with the <code>#[macro_export]</code> attribute may be loaded.</p>
<p id = "para-1035">To load a crate’s macros without linking it into the output, use <code>#[no_link]</code> as well.</p>
<p id = "para-1036">An example:</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">m1 { () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(()) }

</span><span style="font-style:italic;color:#969896;">// Visible here: `m1`.

</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">foo {
    </span><span style="font-style:italic;color:#969896;">// Visible here: `m1`.

    </span><span style="color:#323232;">#[macro_export]
    </span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">m2 { () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(()) }

    </span><span style="font-style:italic;color:#969896;">// Visible here: `m1`, `m2`.
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// Visible here: `m1`.

</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">m3 { () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(()) }

</span><span style="font-style:italic;color:#969896;">// Visible here: `m1`, `m3`.

</span><span style="color:#323232;">#[macro_use]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">bar {
    </span><span style="font-style:italic;color:#969896;">// Visible here: `m1`, `m3`.

    </span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">m4 { () </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(()) }

    </span><span style="font-style:italic;color:#969896;">// Visible here: `m1`, `m3`, `m4`.
</span><span style="color:#323232;">}

</span><span style="font-style:italic;color:#969896;">// Visible here: `m1`, `m3`, `m4`.
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() { }
</span></pre><p id = "para-1037">When this library is loaded with <code>#[macro_use] extern crate</code>, only <code>m2</code> will be imported.</p>
<p id = "para-1038">The Rust Reference has a <a href = "src/../../reference/attributes.html#macro-related-attributes">listing of macro-related attributes</a>.</p>
<h2 id = "link-208">The variable <code>$crate</code></h2>
<p id = "para-1039">A further difficulty occurs when a macro is used in multiple crates. Say that <code>mylib</code> defines</p>
<pre><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">increment</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">u32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">u32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}

#[macro_export]
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">inc_a {
    ($x:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">( ::increment($x) )
}

#[macro_export]
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">inc_b {
    ($x:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">( ::mylib::increment($x) )
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() { }
</span></pre><p id = "para-1040"><code>inc_a</code> only works within <code>mylib</code>, while <code>inc_b</code> only works outside the library. Furthermore, <code>inc_b</code> will break if the user imports <code>mylib</code> under another name.</p>
<p id = "para-1041">Rust does not (yet) have a hygiene system for crate references, but it does provide a simple workaround for this problem. Within a macro imported from a crate named <code>foo</code>, the special macro variable <code>$crate</code> will expand to <code>::foo</code>. By contrast, when a macro is defined and then used in the same crate, <code>$crate</code> will expand to nothing. This means we can write</p>
<pre><span style="color:#323232;">#[macro_export]
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">inc {
    ($x:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">( $crate::increment($x) )
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() { }
</span></pre><p id = "para-1042">to define a single macro that works both inside and outside our library. The function name will expand to either <code>::increment</code> or <code>::mylib::increment</code>.</p>
<p id = "para-1043">To keep this system simple and correct, <code>#[macro_use] extern crate ...</code> may only appear at the root of your crate, not inside <code>mod</code>.</p>
<h2 id = "link-209">The deep end</h2>
<p id = "para-1044">The introductory chapter mentioned recursive macros, but it did not give the full story. Recursive macros are useful for another reason: Each recursive invocation gives you another opportunity to pattern-match the macro’s arguments.</p>
<p id = "para-1045">As an extreme example, it is possible, though hardly advisable, to implement the <a href = "https://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a> automaton within Rust’s macro system.</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">bct {
    </span><span style="font-style:italic;color:#969896;">// cmd 0:  d ... =&gt; ...
    </span><span style="color:#323232;">(0, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; $_d:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">)
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(bct!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">; ));
    (0, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; $_d:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">)
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(bct!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">; </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">));

    </span><span style="font-style:italic;color:#969896;">// cmd 1p:  1 ... =&gt; 1 ... p
    </span><span style="color:#323232;">(1, $p:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; 1)
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(bct!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, $p ; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, $p));
    (1, $p:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; 1, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">)
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(bct!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, $p ; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, $p));

    </span><span style="font-style:italic;color:#969896;">// cmd 1p:  0 ... =&gt; 0 ...
    </span><span style="color:#323232;">(1, $p:</span><span style="font-weight:bold;color:#a71d5d;">tt</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">)
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(bct!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">1</span><span style="color:#323232;">, $p ; </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ds),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">));

    </span><span style="font-style:italic;color:#969896;">// Halt on empty data string:
    </span><span style="color:#323232;">( </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($ps:tt),</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> ; )
        </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(());
}
</span></pre><p id = "para-1046">Exercise: use macros to reduce duplication in the above definition of the <code>bct!</code> macro.</p>
<h2 id = "link-210">Common macros</h2>
<p id = "para-1047">Here are some common macros you’ll see in Rust code.</p>
<h3 id = "link-211">panic!</h3>
<p id = "para-1048">This macro causes the current thread to panic. You can give it a message to panic with:</p>
<pre><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;oh no!&quot;</span><span style="color:#323232;">);
</span></pre><h3 id = "link-212">vec!</h3>
<p id = "para-1049">The <code>vec!</code> macro is used throughout the book, so you’ve probably seen it already. It creates <code>Vec&lt;T&gt;</code>s with ease:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">, </span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">5</span><span style="color:#323232;">];
</span></pre><p id = "para-1050">It also lets you make vectors with repeating values. For example, a hundred zeroes:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> v </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">0</span><span style="color:#323232;">; </span><span style="color:#0086b3;">100</span><span style="color:#323232;">];
</span></pre><h3 id = "link-213">assert! and assert_eq!</h3>
<p id = "para-1051">These two macros are used in tests. <code>assert!</code> takes a boolean. <code>assert_eq!</code> takes two values and checks them for equality. <code>true</code> passes, <code>false</code> <code>panic!</code>s. Like this:</p>
<pre><span style="font-style:italic;color:#969896;">// A-ok!

</span><span style="color:#323232;">assert!(</span><span style="color:#0086b3;">true</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2</span><span style="color:#323232;">);

</span><span style="font-style:italic;color:#969896;">// Nope :(

</span><span style="color:#323232;">assert!(</span><span style="color:#0086b3;">5 </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
assert_eq!(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
</span></pre><h3 id = "link-214">try!</h3>
<p id = "para-1052"><code>try!</code> is used for error handling. It takes something that can return a <code>Result&lt;T, E&gt;</code>, and gives <code>T</code> if it’s a <code>Ok&lt;T&gt;</code>, and <code>return</code>s with the <code>Err(E)</code> if it’s that. Like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() -&gt; std::io::Result&lt;()&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::create(</span><span style="color:#183691;">&quot;foo.txt&quot;</span><span style="color:#323232;">));

    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(())
}
</span></pre><p id = "para-1053">This is cleaner than doing this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() -&gt; std::io::Result&lt;()&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">File::create(</span><span style="color:#183691;">&quot;foo.txt&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> f </span><span style="font-weight:bold;color:#a71d5d;">= match</span><span style="color:#323232;"> f {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(t) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> t,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(e) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(e),
    };

    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(())
}
</span></pre><h3 id = "link-215">unreachable!</h3>
<p id = "para-1054">This macro is used when you think some code should never execute:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#0086b3;">false </span><span style="color:#323232;">{
    unreachable!();
}
</span></pre><p id = "para-1055">Sometimes, the compiler may make you have a different branch that you know will never, ever run. In these cases, use this macro, so that if you end up wrong, you’ll get a <code>panic!</code> about it.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">None</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> x {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">unreachable!(),
    </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;I know x is None!&quot;</span><span style="color:#323232;">),
}
</span></pre><h3 id = "link-216">unimplemented!</h3>
<p id = "para-1056">The <code>unimplemented!</code> macro can be used when you’re trying to get your functions to typecheck, and don’t want to worry about writing out the body of the function. One example of this situation is implementing a trait with multiple required methods, where you want to tackle one at a time. Define the others as <code>unimplemented!</code> until you’re ready to write them.</p>

</div><div id = "chapter-42" class = "chapter">
  <h2 id = "link-217">Raw Pointers</h2>
<p id = "para-1057">Rust has a number of different smart pointer types in its standard library, but there are two types that are extra-special. Much of Rust’s safety comes from compile-time checks, but raw pointers don’t have such guarantees, and are <a href = "#chapter-43">unsafe</a> to use.</p>
<p id = "para-1058"><code>*const T</code> and <code>*mut T</code> are called ‘raw pointers’ in Rust. Sometimes, when writing certain kinds of libraries, you’ll need to get around Rust’s safety guarantees for some reason. In this case, you can use raw pointers to implement your library, while exposing a safe interface for your users. For example, <code>*</code> pointers are allowed to alias, allowing them to be used to write shared-ownership types, and even thread-safe shared memory types (the <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code> types are both implemented entirely in Rust).</p>
<p id = "para-1059">Here are some things to remember about raw pointers that are different than other pointer types. They:</p>
<ul>
<li>are not guaranteed to point to valid memory and are not even guaranteed to be non-NULL (unlike both <code>Box</code> and <code>&amp;</code>);</li>
<li>do not have any automatic clean-up, unlike <code>Box</code>, and so require manual resource management;</li>
<li>are plain-old-data, that is, they don’t move ownership, again unlike <code>Box</code>, hence the Rust compiler cannot protect against bugs like use-after-free;</li>
<li>lack any form of lifetimes, unlike <code>&amp;</code>, and so the compiler cannot reason about dangling pointers; and</li>
<li>have no guarantees about aliasing or mutability other than mutation not being allowed directly through a <code>*const T</code>.</li>
</ul>
<h2 id = "link-218">Basics</h2>
<p id = "para-1060">Creating a raw pointer is perfectly safe:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> raw </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">as *const i32</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> raw_mut </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">as *mut i32</span><span style="color:#323232;">;
</span></pre><p id = "para-1061">However, dereferencing one is not. This won’t work:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> raw </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">as *const i32</span><span style="color:#323232;">;

println!(</span><span style="color:#183691;">&quot;raw points at </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">raw);
</span></pre><p id = "para-1062">It gives this error:</p>
<pre><span style="color:#323232;">error: dereference of raw pointer requires unsafe function or block [E0133]
     println!(&quot;raw points at {}&quot;, *raw);
                                  ^~~~
</span></pre><p id = "para-1063">When you dereference a raw pointer, you’re taking responsibility that it’s not pointing somewhere that would be incorrect. As such, you need <code>unsafe</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> raw </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">as *const i32</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> points_at </span><span style="font-weight:bold;color:#a71d5d;">= unsafe </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">raw };

println!(</span><span style="color:#183691;">&quot;raw points at </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, points_at);
</span></pre><p id = "para-1064">For more operations on raw pointers, see <a href = "src/../../std/primitive.pointer.html">their API documentation</a>.</p>
<h2 id = "link-219">FFI</h2>
<p id = "para-1065">Raw pointers are useful for FFI: Rust’s <code>*const T</code> and <code>*mut T</code> are similar to C’s <code>const T*</code> and <code>T*</code>, respectively. For more about this use, consult the <a href = "#chapter-54">FFI chapter</a>.</p>
<h2 id = "link-220">References and raw pointers</h2>
<p id = "para-1066">At runtime, a raw pointer <code>*</code> and a reference pointing to the same piece of data have an identical representation. In fact, an <code>&amp;T</code> reference will implicitly coerce to an <code>*const T</code> raw pointer in safe code and similarly for the <code>mut</code> variants (both coercions can be performed explicitly with, respectively, <code>value as *const T</code> and <code>value as *mut T</code>).</p>
<p id = "para-1067">Going the opposite direction, from <code>*const</code> to a reference <code>&amp;</code>, is not safe. A <code>&amp;T</code> is always valid, and so, at a minimum, the raw pointer <code>*const T</code> has to point to a valid instance of type <code>T</code>. Furthermore, the resulting pointer must satisfy the aliasing and mutability laws of references. The compiler assumes these properties are true for any references, no matter how they are created, and so any conversion from raw pointers is asserting that they hold. The programmer <em>must</em> guarantee this.</p>
<p id = "para-1068">The recommended method for the conversion is:</p>
<pre><span style="font-style:italic;color:#969896;">// Explicit cast:
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> i: </span><span style="font-weight:bold;color:#a71d5d;">u32 = </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p_imm: </span><span style="font-weight:bold;color:#a71d5d;">*const u32 = &amp;</span><span style="color:#323232;">i </span><span style="font-weight:bold;color:#a71d5d;">as *const u32</span><span style="color:#323232;">;

</span><span style="font-style:italic;color:#969896;">// Implicit coercion:
</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> m: </span><span style="font-weight:bold;color:#a71d5d;">u32 = </span><span style="color:#0086b3;">2</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> p_mut: </span><span style="font-weight:bold;color:#a71d5d;">*mut u32 = &amp;mut</span><span style="color:#323232;"> m;

</span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> ref_imm: </span><span style="font-weight:bold;color:#a71d5d;">&amp;u32 = &amp;*</span><span style="color:#323232;">p_imm;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> ref_mut: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut u32 = &amp;mut *</span><span style="color:#323232;">p_mut;
}
</span></pre><p id = "para-1069">The <code>&amp;*x</code> dereferencing style is preferred to using a <code>transmute</code>. The latter is far more powerful than necessary, and the more restricted operation is harder to use incorrectly; for example, it requires that <code>x</code> is a pointer (unlike <code>transmute</code>).</p>

</div><div id = "chapter-43" class = "chapter">
  <h2 id = "link-221">Unsafe</h2>
<p id = "para-1070">Rust’s main draw is its powerful static guarantees about behavior. But safety checks are conservative by nature: there are some programs that are actually safe, but the compiler is not able to verify this is true. To write these kinds of programs, we need to tell the compiler to relax its restrictions a bit. For this, Rust has a keyword, <code>unsafe</code>. Code using <code>unsafe</code> has fewer restrictions than normal code does.</p>
<p id = "para-1071">Let’s go over the syntax, and then we’ll talk semantics. <code>unsafe</code> is used in four contexts. The first one is to mark a function as unsafe:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">unsafe fn </span><span style="font-weight:bold;color:#795da3;">danger_will_robinson</span><span style="color:#323232;">() {
    </span><span style="font-style:italic;color:#969896;">// Scary stuff...
</span><span style="color:#323232;">}
</span></pre><p id = "para-1072">All functions called from <a href = "#chapter-54">FFI</a> must be marked as <code>unsafe</code>, for example. The second use of <code>unsafe</code> is an unsafe block:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
    </span><span style="font-style:italic;color:#969896;">// Scary stuff...
</span><span style="color:#323232;">}
</span></pre><p id = "para-1073">The third is for unsafe traits:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">unsafe trait </span><span style="color:#323232;">Scary { }
</span></pre><p id = "para-1074">And the fourth is for <code>impl</code>ementing one of those traits:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># unsafe trait </span><span style="color:#323232;">Scary { }
</span><span style="font-weight:bold;color:#a71d5d;">unsafe impl </span><span style="color:#323232;">Scary </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">i32 {}
</span></pre><p id = "para-1075">It’s important to be able to explicitly delineate code that may have bugs that cause big problems. If a Rust program segfaults, you can be sure the cause is related to something marked <code>unsafe</code>.</p>
<h2 id = "link-222">What does ‘safe’ mean?</h2>
<p id = "para-1076">Safe, in the context of Rust, means ‘doesn’t do anything unsafe’. It’s also important to know that there are certain behaviors that are probably not desirable in your code, but are expressly <em>not</em> unsafe:</p>
<ul>
<li>Deadlocks</li>
<li>Leaks of memory or other resources</li>
<li>Exiting without calling destructors</li>
<li>Integer overflow</li>
</ul>
<p id = "para-1077">Rust cannot prevent all kinds of software problems. Buggy code can and will be written in Rust. These things aren’t great, but they don’t qualify as <code>unsafe</code> specifically.</p>
<p id = "para-1078">In addition, the following are all undefined behaviors in Rust, and must be avoided, even when writing <code>unsafe</code> code:</p>
<ul>
<li>Data races</li>
<li>Dereferencing a NULL/dangling raw pointer</li>
<li>Reads of <a href = "http://llvm.org/docs/LangRef.html#undefined-values">undef</a> (uninitialized) memory</li>
<li>Breaking the <a href = "http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">pointer aliasing rules</a> with raw pointers.</li>
<li><code>&amp;mut T</code> and <code>&amp;T</code> follow LLVM’s scoped <a href = "http://llvm.org/docs/LangRef.html#noalias">noalias</a> model, except if the <code>&amp;T</code> contains an <code>UnsafeCell&lt;U&gt;</code>. Unsafe code must not violate these aliasing guarantees.</li>
<li>Mutating an immutable value/reference without <code>UnsafeCell&lt;U&gt;</code></li>
<li>Invoking undefined behavior via compiler intrinsics:<ul>
<li>Indexing outside of the bounds of an object with <code>std::ptr::offset</code> (<code>offset</code> intrinsic), with the exception of one byte past the end which is permitted.</li>
<li>Using <code>std::ptr::copy_nonoverlapping_memory</code> (<code>memcpy32</code>/<code>memcpy64</code> intrinsics) on overlapping buffers</li>
</ul>
</li>
<li>Invalid values in primitive types, even in private fields/locals:<ul>
<li>NULL/dangling references or boxes</li>
<li>A value other than <code>false</code> (0) or <code>true</code> (1) in a <code>bool</code></li>
<li>A discriminant in an <code>enum</code> not included in its type definition</li>
<li>A value in a <code>char</code> which is a surrogate or above <code>char::MAX</code></li>
<li>Non-UTF-8 byte sequences in a <code>str</code></li>
</ul>
</li>
<li>Unwinding into Rust from foreign code or unwinding from Rust into foreign code.</li>
</ul>
<h2 id = "link-223">Unsafe Superpowers</h2>
<p id = "para-1079">In both unsafe functions and unsafe blocks, Rust will let you do three things that you normally can not do. Just three. Here they are:</p>
<ol>
<li>Access or update a <a href = "#chapter-33">static mutable variable</a>.</li>
<li>Dereference a raw pointer.</li>
<li>Call unsafe functions. This is the most powerful ability.</li>
</ol>
<p id = "para-1080">That’s it. It’s important that <code>unsafe</code> does not, for example, ‘turn off the borrow checker’. Adding <code>unsafe</code> to some random Rust code doesn’t change its semantics, it won’t start accepting anything. But it will let you write things that <em>do</em> break some of the rules.</p>
<p id = "para-1081">You will also encounter the <code>unsafe</code> keyword when writing bindings to foreign (non-Rust) interfaces. You’re encouraged to write a safe, native Rust interface around the methods provided by the library.</p>
<p id = "para-1082">Let’s go over the basic three abilities listed, in order.</p>
<h3 id = "link-224">Access or update a <code>static mut</code></h3>
<p id = "para-1083">Rust has a feature called ‘<code>static mut</code>’ which allows for mutable global state. Doing so can cause a data race, and as such is inherently not safe. For more details, see the <a href = "#chapter-33">static</a> section of the book.</p>
<h3 id = "link-225">Dereference a raw pointer</h3>
<p id = "para-1084">Raw pointers let you do arbitrary pointer arithmetic, and can cause a number of different memory safety and security issues. In some senses, the ability to dereference an arbitrary pointer is one of the most dangerous things you can do. For more on raw pointers, see <a href = "#chapter-42">their section of the book</a>.</p>
<h3 id = "link-226">Call unsafe functions</h3>
<p id = "para-1085">This last ability works with both aspects of <code>unsafe</code>: you can only call functions marked <code>unsafe</code> from inside an unsafe block.</p>
<p id = "para-1086">This ability is powerful and varied. Rust exposes some <a href = "src/../../unstable-book/language-features/intrinsics.html">compiler intrinsics</a> as unsafe functions, and some unsafe functions bypass safety checks, trading safety for speed.</p>
<p id = "para-1087">I’ll repeat again: even though you <em>can</em> do arbitrary things in unsafe blocks and functions doesn’t mean you should. The compiler will act as though you’re upholding its invariants, so be careful!</p>

</div><div id = "chapter-44" class = "chapter">
  <h2 class = 'part'>Part V</h2> <h1 id = 'link-227' class = 'part'>Effective Rust</h1>
</div><div id = "chapter-45" class = "chapter">
  <h1 id = 'link-228'><span class = 'chapter-header'>Chapter 1</span><br />Effective Rust</h1><p id = "para-1088">So you’ve learned how to write some Rust code. But there’s a difference between writing <em>any</em> Rust code and writing <em>good</em> Rust code.</p>
<p id = "para-1089">This chapter consists of relatively independent tutorials which show you how to take your Rust to the next level. Common patterns and standard library features will be introduced. Read these sections in any order of your choosing.</p>

</div><div id = "chapter-46" class = "chapter">
  <h2 id = "link-229">The Stack and the Heap</h2>
<p id = "para-1090">As a systems language, Rust operates at a low level. If you’re coming from a high-level language, there are some aspects of systems programming that you may not be familiar with. The most important one is how memory works, with a stack and a heap. If you’re familiar with how C-like languages use stack allocation, this chapter will be a refresher. If you’re not, you’ll learn about this more general concept, but with a Rust-y focus.</p>
<p id = "para-1091">As with most things, when learning about them, we’ll use a simplified model to start. This lets you get a handle on the basics, without getting bogged down with details which are, for now, irrelevant. The examples we’ll use aren’t 100% accurate, but are representative for the level we’re trying to learn at right now. Once you have the basics down, learning more about how allocators are implemented, virtual memory, and other advanced topics will reveal the leaks in this particular abstraction.</p>
<h2 id = "link-230">Memory management</h2>
<p id = "para-1092">These two terms are about memory management. The stack and the heap are abstractions that help you determine when to allocate and deallocate memory.</p>
<p id = "para-1093">Here’s a high-level comparison:</p>
<p id = "para-1094">The stack is very fast, and is where memory is allocated in Rust by default. But the allocation is local to a function call, and is limited in size. The heap, on the other hand, is slower, and is explicitly allocated by your program. But it’s effectively unlimited in size, and is globally accessible. Note this meaning of heap, which allocates arbitrary-sized blocks of memory in arbitrary order, is quite different from the heap data structure.</p>
<h2 id = "link-231">The Stack</h2>
<p id = "para-1095">Let’s talk about this Rust program:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;
}
</span></pre><p id = "para-1096">This program has one variable binding, <code>x</code>. This memory needs to be allocated from somewhere. Rust ‘stack allocates’ by default, which means that basic values ‘go on the stack’. What does that mean?</p>
<p id = "para-1097">Well, when a function gets called, some memory gets allocated for all of its local variables and some other information. This is called a ‘stack frame’, and for the purpose of this tutorial, we’re going to ignore the extra information and only consider the local variables we’re allocating. So in this case, when <code>main()</code> is run, we’ll allocate a single 32-bit integer for our stack frame. This is automatically handled for you, as you can see; we didn’t have to write any special Rust code or anything.</p>
<p id = "para-1098">When the function exits, its stack frame gets deallocated. This happens automatically as well.</p>
<p id = "para-1099">That’s all there is for this simple program. The key thing to understand here is that stack allocation is very, very fast. Since we know all the local variables we have ahead of time, we can grab the memory all at once. And since we’ll throw them all away at the same time as well, we can get rid of it very fast too.</p>
<p id = "para-1100">The downside is that we can’t keep values around if we need them for longer than a single function. We also haven’t talked about what the word, ‘stack’, means. To do that, we need a slightly more complicated example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">100</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;

    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">();
}
</span></pre><p id = "para-1102">This program has three variables total: two in <code>foo()</code>, one in <code>main()</code>. Just as before, when <code>main()</code> is called, a single integer is allocated for its stack frame. But before we can show what happens when <code>foo()</code> is called, we need to visualize what’s going on with memory. Your operating system presents a view of memory to your program that’s pretty simple: a huge list of addresses, from 0 to a large number, representing how much RAM your computer has. For example, if you have a gigabyte of RAM, your addresses go from <code>0</code> to <code>1,073,741,823</code>. That number comes from 230, the number of bytes in a gigabyte. <a href = "#note-dest-2"><sup id = "note-source-2">[2]</sup></a></p>
 <p id = "para-1103">This memory is kind of like a giant array: addresses start at zero and go up to the final number. So here’s a diagram of our first stack frame:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1104">We’ve got <code>x</code> located at address <code>0</code>, with the value <code>42</code>.</p>
<p id = "para-1105">When <code>foo()</code> is called, a new stack frame is allocated:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 2 </td><td> z </td><td> 100 </td></tr>
<tr>
<td> 1 </td><td> y </td><td> 5 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1106">Because <code>0</code> was taken by the first frame, <code>1</code> and <code>2</code> are used for <code>foo()</code>’s stack frame. It grows upward, the more functions we call. Notice that we are <b>not</b> taking into account the size of each variable (for example, a 32 bit variable would use the memory addresses from 0 to 3, or 4 bytes).</p>
<p id = "para-1107">There are some important things we have to take note of here. The numbers 0, 1, and 2 are all solely for illustrative purposes, and bear no relationship to the address values the computer will use in reality. In particular, the series of addresses are in reality going to be separated by some number of bytes that separate each address, and that separation may even exceed the size of the value being stored.</p>
<p id = "para-1108">After <code>foo()</code> is over, its frame is deallocated:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1109">And then, after <code>main()</code>, even this last value goes away. Easy!</p>
<p id = "para-1110">It’s called a ‘stack’ because it works like a stack of dinner plates: the first plate you put down is the last plate to pick back up. Stacks are sometimes called ‘last in, first out queues’ for this reason, as the last value you put on the stack is the first one you retrieve from it.</p>
<p id = "para-1111">Let’s try a three-deep example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">italic</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bold</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> a </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> b </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">100</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

    </span><span style="color:#62a35c;">italic</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;

    </span><span style="color:#62a35c;">bold</span><span style="color:#323232;">();
}
</span></pre><p id = "para-1112">We have some kooky function names to make the diagrams clearer.</p>
<p id = "para-1113">Okay, first, we call <code>main()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1114">Next up, <code>main()</code> calls <code>bold()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> <b>3</b> </td><td> <b>c</b></td><td><b>1</b> </td></tr>
<tr>
<td> <b>2</b> </td><td> <b>b</b></td><td><b>100</b></td></tr>
<tr>
<td> <b>1</b> </td><td> <b>a</b></td><td> <b>5</b> </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1115">And then <code>bold()</code> calls <code>italic()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> <em>4</em> </td><td> <em>i</em> </td><td> <em>6</em> </td></tr>
<tr>
<td> <b>3</b> </td><td> <b>c</b></td><td><b>1</b> </td></tr>
<tr>
<td> <b>2</b> </td><td> <b>b</b></td><td><b>100</b></td></tr>
<tr>
<td> <b>1</b> </td><td> <b>a</b></td><td> <b>5</b> </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1116">Whew! Our stack is growing tall.</p>
<p id = "para-1117">After <code>italic()</code> is over, its frame is deallocated, leaving only <code>bold()</code> and <code>main()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> <b>3</b> </td><td> <b>c</b></td><td><b>1</b> </td></tr>
<tr>
<td> <b>2</b> </td><td> <b>b</b></td><td><b>100</b></td></tr>
<tr>
<td> <b>1</b> </td><td> <b>a</b></td><td> <b>5</b> </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1118">And then <code>bold()</code> ends, leaving only <code>main()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 0 </td><td> x </td><td> 42 </td></tr>

    </table>
</div>
<p id = "para-1119">And then we’re done. Getting the hang of it? It’s like piling up dishes: you add to the top, you take away from the top.</p>
<h2 id = "link-232">The Heap</h2>
<p id = "para-1120">Now, this works pretty well, but not everything can work like this. Sometimes, you need to pass some memory between different functions, or keep it alive for longer than a single function’s execution. For this, we can use the heap.</p>
<p id = "para-1121">In Rust, you can allocate memory on the heap with the <a href = "src/../../std/boxed/index.html"><code>Box&lt;T&gt;</code> type</a>. Here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;
}
</span></pre><p id = "para-1122">Here’s what happens in memory when <code>main()</code> is called:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 1 </td><td> y </td><td> 42 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> ?????? </td></tr>

    </table>
</div>
<p id = "para-1123">We allocate space for two variables on the stack. <code>y</code> is <code>42</code>, as it always has been, but what about <code>x</code>? Well, <code>x</code> is a <code>Box&lt;i32&gt;</code>, and boxes allocate memory on the heap. The actual value of the box is a structure which has a pointer to ‘the heap’. When we start executing the function, and <code>Box::new()</code> is called, it allocates some memory for the heap, and puts <code>5</code> there. The memory now looks like this:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 5 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 1 </td><td> y </td><td> 42 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> → (230) - 1 </td></tr>

    </table>
</div>
<p id = "para-1124">We have (230) addresses in our hypothetical computer with 1GiB of RAM. And since our stack grows from zero, the easiest place to allocate memory is from the other end. So our first value is at the highest place in memory. And the value of the struct at <code>x</code> has a <a href = "#chapter-42">raw pointer</a> to the place we’ve allocated on the heap, so the value of <code>x</code> is (230) - 1, the memory location we’ve asked for.</p>
<p id = "para-1125">We haven’t really talked too much about what it actually means to allocate and deallocate memory in these contexts. Getting into very deep detail is out of the scope of this tutorial, but what’s important to point out here is that the heap isn’t a stack that grows from the opposite end. We’ll have an example of this later in the book, but because the heap can be allocated and freed in any order, it can end up with ‘holes’. Here’s a diagram of the memory layout of a program which has been running for a while now:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 5 </td></tr>
<tr>
<td> (230) - 2 </td><td> </td><td> </td></tr>
<tr>
<td> (230) - 3 </td><td> </td><td> </td></tr>
<tr>
<td> (230) - 4 </td><td> </td><td> 42 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 2 </td><td> z </td><td> → (230) - 4 </td></tr>
<tr>
<td> 1 </td><td> y </td><td> 42 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> → (230) - 1 </td></tr>

    </table>
</div>
<p id = "para-1126">In this case, we’ve allocated four things on the heap, but deallocated two of them. There’s a gap between (230) - 1 and (230) - 4 which isn’t currently being used. The specific details of how and why this happens depends on what kind of strategy you use to manage the heap. Different programs can use different ‘memory allocators’, which are libraries that manage this for you. Rust programs use <a href = "http://www.canonware.com/jemalloc/">jemalloc</a> for this purpose.</p>
<p id = "para-1128">Anyway, back to our example. Since this memory is on the heap, it can stay alive longer than the function which allocates the box. In this case, however, it doesn’t.<a href = "#note-dest-3"><sup id = "note-source-3">[3]</sup></a> When the function is over, we need to free the stack frame for <code>main()</code>. <code>Box&lt;T&gt;</code>, though, has a trick up its sleeve: <a href = "#chapter-27">Drop</a>. The implementation of <code>Drop</code> for <code>Box</code> deallocates the memory that was allocated when it was created. Great! So when <code>x</code> goes away, it first frees the memory allocated on the heap:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 1 </td><td> y </td><td> 42 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> ?????? </td></tr>

    </table>
</div>
 <p id = "para-1129">And then the stack frame goes away, freeing all of our memory.</p>
<h2 id = "link-233">Arguments and borrowing</h2>
<p id = "para-1130">We’ve got some basic examples with the stack and the heap going, but what about function arguments and borrowing? Here’s a small Rust program:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(i: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">42</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x;

    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(y);
}
</span></pre><p id = "para-1131">When we enter <code>main()</code>, memory looks like this:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 1 </td><td> y </td><td> → 0 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 5 </td></tr>

    </table>
</div>
<p id = "para-1132"><code>x</code> is a plain old <code>5</code>, and <code>y</code> is a reference to <code>x</code>. So its value is the memory location that <code>x</code> lives at, which in this case is <code>0</code>.</p>
<p id = "para-1133">What about when we call <code>foo()</code>, passing <code>y</code> as an argument?</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> 3 </td><td> z </td><td> 42 </td></tr>
<tr>
<td> 2 </td><td> i </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> y </td><td> → 0 </td></tr>
<tr>
<td> 0 </td><td> x </td><td> 5 </td></tr>

    </table>
</div>
<p id = "para-1134">Stack frames aren’t only for local bindings, they’re for arguments too. So in this case, we need to have both <code>i</code>, our argument, and <code>z</code>, our local variable binding. <code>i</code> is a copy of the argument, <code>y</code>. Since <code>y</code>’s value is <code>0</code>, so is <code>i</code>’s.</p>
<p id = "para-1135">This is one reason why borrowing a variable doesn’t deallocate any memory: the value of a reference is a pointer to a memory location. If we got rid of the underlying memory, things wouldn’t work very well.</p>
<h2 id = "link-234">A complex example</h2>
<p id = "para-1136">Okay, let’s go through this complex program step-by-step:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">10</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">y;

    </span><span style="color:#62a35c;">baz</span><span style="color:#323232;">(z);
    </span><span style="color:#62a35c;">bar</span><span style="color:#323232;">(x, z);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">, b: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> d </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> e </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">d;

    </span><span style="color:#62a35c;">baz</span><span style="color:#323232;">(e);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">baz</span><span style="color:#323232;">(f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;i32</span><span style="color:#323232;">) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> g </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">100</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> h </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(</span><span style="color:#0086b3;">20</span><span style="color:#323232;">);
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> j </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">h;

    </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(j);
}
</span></pre><p id = "para-1137">First, we call <code>main()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1138">We allocate memory for <code>j</code>, <code>i</code>, and <code>h</code>. <code>i</code> is on the heap, and so has a value pointing there.</p>
<p id = "para-1139">Next, at the end of <code>main()</code>, <code>foo()</code> gets called:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1140">Space gets allocated for <code>x</code>, <code>y</code>, and <code>z</code>. The argument <code>x</code> has the same value as <code>j</code>, since that’s what we passed it in. It’s a pointer to the <code>0</code> address, since <code>j</code> points at <code>h</code>.</p>
<p id = "para-1141">Next, <code>foo()</code> calls <code>baz()</code>, passing <code>z</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 7 </td><td> g </td><td> 100 </td></tr>
<tr>
<td> 6 </td><td> f </td><td> → 4 </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1142">We’ve allocated memory for <code>f</code> and <code>g</code>. <code>baz()</code> is very short, so when it’s over, we get rid of its stack frame:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1143">Next, <code>foo()</code> calls <code>bar()</code> with <code>x</code> and <code>z</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> (230) - 2 </td><td> </td><td> 5 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 10 </td><td> e </td><td> → 9 </td></tr>
<tr>
<td> 9 </td><td> d </td><td> → (230) - 2 </td></tr>
<tr>
<td> 8 </td><td> c </td><td> 5 </td></tr>
<tr>
<td> 7 </td><td> b </td><td> → 4 </td></tr>
<tr>
<td> 6 </td><td> a </td><td> → 0 </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1144">We end up allocating another value on the heap, and so we have to subtract one from (230) - 1. It’s easier to write that than <code>1,073,741,822</code>. In any case, we set up the variables as usual.</p>
<p id = "para-1145">At the end of <code>bar()</code>, it calls <code>baz()</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> (230) - 2 </td><td> </td><td> 5 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 12 </td><td> g </td><td> 100 </td></tr>
<tr>
<td> 11 </td><td> f </td><td> → (230) - 2 </td></tr>
<tr>
<td> 10 </td><td> e </td><td> → 9 </td></tr>
<tr>
<td> 9 </td><td> d </td><td> → (230) - 2 </td></tr>
<tr>
<td> 8 </td><td> c </td><td> 5 </td></tr>
<tr>
<td> 7 </td><td> b </td><td> → 4 </td></tr>
<tr>
<td> 6 </td><td> a </td><td> → 0 </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1146">With this, we’re at our deepest point! Whew! Congrats for following along this far.</p>
<p id = "para-1147">After <code>baz()</code> is over, we get rid of <code>f</code> and <code>g</code>:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> (230) - 2 </td><td> </td><td> 5 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 10 </td><td> e </td><td> → 9 </td></tr>
<tr>
<td> 9 </td><td> d </td><td> → (230) - 2 </td></tr>
<tr>
<td> 8 </td><td> c </td><td> 5 </td></tr>
<tr>
<td> 7 </td><td> b </td><td> → 4 </td></tr>
<tr>
<td> 6 </td><td> a </td><td> → 0 </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1148">Next, we return from <code>bar()</code>. <code>d</code> in this case is a <code>Box&lt;T&gt;</code>, so it also frees what it points to: (230) - 2.</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 5 </td><td> z </td><td> → 4 </td></tr>
<tr>
<td> 4 </td><td> y </td><td> 10 </td></tr>
<tr>
<td> 3 </td><td> x </td><td> → 0 </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1149">And after that, <code>foo()</code> returns:</p>
<div class = "table">
    <table>
<tr>
<th> Address </th><th> Name </th><th> Value </th></tr>
<tr>
<td> (230) - 1 </td><td> </td><td> 20 </td></tr>
<tr>
<td> ... </td><td> ... </td><td> ... </td></tr>
<tr>
<td> 2 </td><td> j </td><td> → 0 </td></tr>
<tr>
<td> 1 </td><td> i </td><td> → (230) - 1 </td></tr>
<tr>
<td> 0 </td><td> h </td><td> 3 </td></tr>

    </table>
</div>
<p id = "para-1150">And then, finally, <code>main()</code>, which cleans the rest up. When <code>i</code> is <code>Drop</code>ped, it will clean up the last of the heap too.</p>
<h2 id = "link-235">What do other languages do?</h2>
<p id = "para-1151">Most languages with a garbage collector heap-allocate by default. This means that every value is boxed. There are a number of reasons why this is done, but they’re out of scope for this tutorial. There are some possible optimizations that don’t make it true 100% of the time, too. Rather than relying on the stack and <code>Drop</code> to clean up memory, the garbage collector deals with the heap instead.</p>
<h2 id = "link-236">Which to use?</h2>
<p id = "para-1152">So if the stack is faster and easier to manage, why do we need the heap? A big reason is that Stack-allocation alone means you only have ‘Last In First Out (LIFO)’ semantics for reclaiming storage. Heap-allocation is strictly more general, allowing storage to be taken from and returned to the pool in arbitrary order, but at a complexity cost.</p>
<p id = "para-1153">Generally, you should prefer stack allocation, and so, Rust stack-allocates by default. The LIFO model of the stack is simpler, at a fundamental level. This has two big impacts: runtime efficiency and semantic impact.</p>
<h3 id = "link-237">Runtime Efficiency</h3>
<p id = "para-1154">Managing the memory for the stack is trivial: The machine increments or decrements a single value, the so-called “stack pointer”. Managing memory for the heap is non-trivial: heap-allocated memory is freed at arbitrary points, and each block of heap-allocated memory can be of arbitrary size, so the memory manager must generally work much harder to identify memory for reuse.</p>
<p id = "para-1155">If you’d like to dive into this topic in greater detail, <a href = "http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.143.4688">this paper</a> is a great introduction.</p>
<h3 id = "link-238">Semantic impact</h3>
<p id = "para-1156">Stack-allocation impacts the Rust language itself, and thus the developer’s mental model. The LIFO semantics is what drives how the Rust language handles automatic memory management. Even the deallocation of a uniquely-owned heap-allocated box can be driven by the stack-based LIFO semantics, as discussed throughout this chapter. The flexibility (i.e. expressiveness) of non LIFO-semantics means that in general the compiler cannot automatically infer at compile-time where memory should be freed; it has to rely on dynamic protocols, potentially from outside the language itself, to drive deallocation (reference counting, as used by <code>Rc&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, is one example of this).</p>
<p id = "para-1157">When taken to the extreme, the increased expressive power of heap allocation comes at the cost of either significant runtime support (e.g. in the form of a garbage collector) or significant programmer effort (in the form of explicit memory management calls that require verification not provided by the Rust compiler).</p>

</div><div id = "chapter-47" class = "chapter">
  <h2 id = "link-239">Testing</h2>
<blockquote><p id = "para-1158">Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.</p>
<p id = "para-1159">Edsger W. Dijkstra, “The Humble Programmer” (1972)</p>
</blockquote>
<p id = "para-1160">Let’s talk about how to test Rust code. What we will not be talking about is the right way to test Rust code. There are many schools of thought regarding the right and wrong way to write tests. All of these approaches use the same basic tools, and so we’ll show you the syntax for using them.</p>
<h2 id = "link-240">The <code>test</code> attribute</h2>
<p id = "para-1161">At its simplest, a test in Rust is a function that’s annotated with the <code>test</code> attribute. Let’s make a new project with Cargo called <code>adder</code>:</p>
<pre><span style="color:#323232;">$ cargo new adder
$ cd adder
</span></pre><p id = "para-1162">Cargo will automatically generate a simple test when you make a new project. Here’s the contents of <code>src/lib.rs</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[cfg(test)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">tests {
    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    }
}
</span></pre><p id = "para-1163">For now, let’s remove the <code>mod</code> bit, and focus on just the function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
}
</span></pre><p id = "para-1164">Note the <code>#[test]</code>. This attribute indicates that this is a test function. It currently has no body. That’s good enough to pass! We can run the tests with <code>cargo test</code>:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.15 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 1 test
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1165">Cargo compiled and ran our tests. There are two sets of output here: one for the test we wrote, and another for documentation tests. We’ll talk about those later. For now, see this line:</p>
<pre><span style="color:#323232;">test it_works ... ok
</span></pre><p id = "para-1166">Note the <code>it_works</code>. This comes from the name of our function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
}
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-1167">We also get a summary line:</p>
<pre><span style="color:#323232;">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</span></pre><p id = "para-1168">So why does our do-nothing test pass? Any test which doesn’t <code>panic!</code> passes, and any test that does <code>panic!</code> fails. Let’s make our test fail:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert!(</span><span style="color:#0086b3;">false</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1169"><code>assert!</code> is a macro provided by Rust which takes one argument: if the argument is <code>true</code>, nothing happens. If the argument is <code>false</code>, it will <code>panic!</code>. Let’s run our tests again:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.17 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread </span><span style="color:#183691;">&#39;it_works&#39;</span><span style="color:#323232;"> panicked at </span><span style="color:#183691;">&#39;assertion failed: false&#39;</span><span style="color:#323232;">, src/lib.rs:5
note: Run with `RUST_BACKTRACE</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#183691;">1` </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#183691;"> a backtrace.


</span><span style="color:#323232;">failures:
    it_works

test</span><span style="color:#183691;"> result: FAILED. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">1</span><span style="color:#183691;"> failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0</span><span style="color:#183691;"> ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0</span><span style="color:#183691;"> measured

</span><span style="color:#323232;">error:</span><span style="color:#183691;"> test failed
</span></pre><p id = "para-1170">Rust indicates that our test failed:</p>
<pre><span style="color:#323232;">test it_works ... FAILED
</span></pre><p id = "para-1171">And that’s reflected in the summary line:</p>
<pre><span style="color:#323232;">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</span></pre><p id = "para-1172">We also get a non-zero status code. We can use <code>$?</code> on macOS and Linux:</p>
<pre><span style="color:#323232;">$ echo $?
101
</span></pre><p id = "para-1173">On Windows, if you’re using <code>cmd</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> echo %ERRORLEVEL%
</span></pre><p id = "para-1174">And if you’re using PowerShell:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> echo $LASTEXITCODE </span><span style="font-style:italic;color:#969896;"># the code itself
</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> echo $? </span><span style="font-style:italic;color:#969896;"># a boolean, fail or succeed
</span></pre><p id = "para-1175">This is useful if you want to integrate <code>cargo test</code> into other tooling.</p>
<p id = "para-1176">We can invert our test’s failure with another attribute: <code>should_panic</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[test]
#[should_panic]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert!(</span><span style="color:#0086b3;">false</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1177">This test will now succeed if we <code>panic!</code> and fail if we complete. Let’s try it:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.17 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 1 test
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1178">Rust provides another macro, <code>assert_eq!</code>, that compares two arguments for equality:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[test]
#[should_panic]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;world&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1179">Does this test pass or fail? Because of the <code>should_panic</code> attribute, it passes:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.21 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 1 test
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1180"><code>should_panic</code> tests can be fragile, as it’s hard to guarantee that the test didn’t fail for an unexpected reason. To help with this, an optional <code>expected</code> parameter can be added to the <code>should_panic</code> attribute. The test harness will make sure that the failure message contains the provided text. A safer version of the example above would be:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="color:#323232;">#[test]
#[should_panic(expected </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;assertion failed&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;world&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1181">That’s all there is to the basics! Let’s write one ‘real’ test:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
pub fn </span><span style="font-weight:bold;color:#795da3;">add_two</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    a </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}

#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">add_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1182">This is a very common use of <code>assert_eq!</code>: call some function with some known arguments and compare it to the expected output.</p>
<h2 id = "link-241">The <code>ignore</code> attribute</h2>
<p id = "para-1183">Sometimes a few specific tests can be very time-consuming to execute. These can be disabled by default by using the <code>ignore</code> attribute:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
pub fn </span><span style="font-weight:bold;color:#795da3;">add_two</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    a </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}

#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">add_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
}

#[test]
#[ignore]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">expensive_test</span><span style="color:#323232;">() {
    </span><span style="font-style:italic;color:#969896;">// Code that takes an hour to run...
</span><span style="color:#323232;">}
</span></pre><p id = "para-1184">Now we run our tests and see that <code>it_works</code> is run, but <code>expensive_test</code> is not:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.20 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">1 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1185">The expensive tests can be run explicitly using <code>cargo test -- --ignored</code>:</p>
<pre><span style="color:#323232;">$ cargo test</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span style="color:#323232;"> --ignored
    Finished debug </span><span style="font-weight:bold;color:#a71d5d;">[</span><span style="color:#323232;">unoptimized + debuginfo</span><span style="font-weight:bold;color:#a71d5d;">]</span><span style="color:#323232;"> target(s) in 0.0 secs
     Running target/debug/deps/adder-941f01916ca4a642

running 1 test
test expensive_test ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1186">The <code>--ignored</code> argument is an argument to the test binary, and not to Cargo, which is why the command is <code>cargo test -- --ignored</code>.</p>
<h2 id = "link-242">The <code>tests</code> module</h2>
<p id = "para-1187">There is one way in which our existing example is not idiomatic: it’s missing the <code>tests</code> module. You might have noticed this test module was present in the code that was initially generated with <code>cargo new</code> but was missing from our last example. Let’s explain what this does.</p>
<p id = "para-1188">The idiomatic way of writing our example looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
pub fn </span><span style="font-weight:bold;color:#795da3;">add_two</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    a </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}

#[cfg(test)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">tests {
    </span><span style="font-weight:bold;color:#a71d5d;">use super</span><span style="color:#323232;">::add_two;

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
        assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">add_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
    }
}
</span></pre><p id = "para-1189">There’s a few changes here. The first is the introduction of a <code>mod tests</code> with a <code>cfg</code> attribute. The module allows us to group all of our tests together, and to also define helper functions if needed, that don’t become a part of the rest of our crate. The <code>cfg</code> attribute only compiles our test code if we’re currently trying to run the tests. This can save compile time, and also ensures that our tests are entirely left out of a normal build.</p>
<p id = "para-1190">The second change is the <code>use</code> declaration. Because we’re in an inner module, we need to bring the tested function into scope. This can be annoying if you have a large module, and so this is a common use of globs. Let’s change our <code>src/lib.rs</code> to make use of it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
pub fn </span><span style="font-weight:bold;color:#795da3;">add_two</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    a </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}

#[cfg(test)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">tests {
    </span><span style="font-weight:bold;color:#a71d5d;">use super</span><span style="color:#323232;">::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">;

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
        assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">add_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
    }
}
</span></pre><p id = "para-1191">Note the different <code>use</code> line. Now we run our tests:</p>
<pre><span style="color:#323232;">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
     Running target/debug/deps/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1192">It works!</p>
<p id = "para-1193">The current convention is to use the <code>tests</code> module to hold your “unit-style” tests. Anything that tests one small bit of functionality makes sense to go here. But what about “integration-style” tests instead? For that, we have the <code>tests</code> directory.</p>
<h2 id = "link-243">The <code>tests</code> directory</h2>
<p id = "para-1194">Each file in <code>tests/*.rs</code> directory is treated as an individual crate. To write an integration test, let’s make a <code>tests</code> directory and put a <code>tests/integration_test.rs</code> file inside with this as its contents:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
# </span><span style="font-style:italic;color:#969896;">// Sadly, this code will not work in play.rust-lang.org, because we have no
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// crate adder to import. You&#39;ll need to try this part on your own machine.
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> adder;

#[test]
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, adder::add_two(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1195">This looks similar to our previous tests, but slightly different. We now have an <code>extern crate adder</code> at the top. This is because each test in the <code>tests</code> directory is an entirely separate crate, and so we need to import our library. This is also why <code>tests</code> is a suitable place to write integration-style tests: they use the library like any other consumer of it would.</p>
<p id = "para-1196">Let’s run them:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0 (file:///home/you/projects/adder)
     Running target/debug/deps/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

     Running target/debug/integration_test-68064b69521c828a

running 1 test
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1197">Now we have three sections: our previous test is also run, as well as our new one.</p>
<p id = "para-1198">Cargo will ignore files in subdirectories of the <code>tests/</code> directory. Therefore shared modules in integrations tests are possible. For example <code>tests/common/mod.rs</code> is not separately compiled by cargo but can be imported in every test with <code>mod common;</code></p>
<p id = "para-1199">That’s all there is to the <code>tests</code> directory. The <code>tests</code> module isn’t needed here, since the whole thing is focused on tests.</p>
<p id = "para-1200">Note, when building integration tests, cargo will not pass the <code>test</code> attribute to the compiler. It means that all parts in <code>cfg(test)</code> won’t be included in the build used in your integration tests.</p>
<p id = "para-1201">Let’s finally check out that third section: documentation tests.</p>
<h2 id = "link-244">Documentation tests</h2>
<p id = "para-1202">Nothing is better than documentation with examples. Nothing is worse than examples that don’t actually work, because the code has changed since the documentation has been written. To this end, Rust supports automatically running examples in your documentation (<b>note:</b> this only works in library crates, not binary crates). Here’s a fleshed-out <code>src/lib.rs</code> with examples:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// The next line exists to trick play.rust-lang.org into running our code as a
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// test:
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-style:italic;color:#969896;">// fn main
</span><span style="font-weight:bold;color:#a71d5d;">#
</span><span style="font-style:italic;color:#969896;">//! The `adder` crate provides functions that add numbers to other numbers.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// This function adds two to its argument.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">add_two</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    a </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">2
</span><span style="color:#323232;">}

#[cfg(test)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">tests {
    </span><span style="font-weight:bold;color:#a71d5d;">use super</span><span style="color:#323232;">::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">;

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">it_works</span><span style="color:#323232;">() {
        assert_eq!(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#62a35c;">add_two</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">));
    }
}
</span></pre><p id = "para-1203">Note the module-level documentation with <code>//!</code> and the function-level documentation with <code>///</code>. Rust’s documentation supports Markdown in comments, and so triple graves mark code blocks. It is conventional to include the <code># Examples</code> section, exactly like that, with examples following.</p>
<p id = "para-1204">Let’s run the tests again:</p>
<pre><span style="color:#323232;">$ cargo test
   Compiling adder v0.1.0. (file:///home/you/projects/adder)
     Running target/debug/deps/adder-91b3e234d4ed382a

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

     Running target/debug/integration_test-68064b69521c828a

running 1 test
test it_works ... ok

test result: ok. 1 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 failed</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 ignored</span><span style="font-weight:bold;color:#a71d5d;">; </span><span style="color:#323232;">0 measured
</span></pre><p id = "para-1205">Now we have all three kinds of tests running! Note the names of the documentation tests: the <code>_0</code> is generated for the module test, and <code>add_two_0</code> for the function test. These will auto increment with names like <code>add_two_1</code> as you add more examples.</p>
<p id = "para-1206">We haven’t covered all of the details with writing documentation tests. For more, please see the <a href = "#chapter-49">Documentation chapter</a>.</p>
<h2 id = "link-245">Testing and concurrency</h2>
<p id = "para-1207">It is important to note that tests are run concurrently using threads. For this reason, care should be taken to ensure your tests do not depend on each-other, or on any shared state. “Shared state” can also include the environment, such as the current working directory, or environment variables.</p>
<p id = "para-1208">If this is an issue it is possible to control this concurrency, either by setting the environment variable <code>RUST_TEST_THREADS</code>, or by passing the argument <code>--test-threads</code> to the tests:</p>
<pre><span style="color:#323232;">$ RUST_TEST_THREADS=1 cargo test   </span><span style="font-style:italic;color:#969896;"># Run tests with no concurrency
</span><span style="color:#323232;">...
$ cargo test</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span style="color:#323232;"> --test-threads=1   </span><span style="font-style:italic;color:#969896;"># Same as above
</span><span style="color:#323232;">...
</span></pre><h2 id = "link-246">Test output</h2>
<p id = "para-1209">By default Rust’s test library captures and discards output to standard out/error, e.g. output from <code>println!()</code>. This too can be controlled using the environment or a switch:</p>
<pre><span style="color:#323232;">$ RUST_TEST_NOCAPTURE=1 cargo test   </span><span style="font-style:italic;color:#969896;"># Preserve stdout/stderr
</span><span style="color:#323232;">...
$ cargo test</span><span style="font-weight:bold;color:#a71d5d;"> --</span><span style="color:#323232;"> --nocapture          </span><span style="font-style:italic;color:#969896;"># Same as above
</span><span style="color:#323232;">...
</span></pre><p id = "para-1210">However a better method avoiding capture is to use logging rather than raw output. Rust has a <a href = "https://crates.io/crates/log">standard logging API</a>, which provides a frontend to multiple logging implementations. This can be used in conjunction with the default <a href = "https://crates.io/crates/env_logger">env_logger</a> to output any debugging information in a manner that can be controlled at runtime.</p>

</div><div id = "chapter-48" class = "chapter">
  <h2 id = "link-247">Conditional Compilation</h2>
<p id = "para-1211">Rust has a special attribute, <code>#[cfg]</code>, which allows you to compile code based on a flag passed to the compiler. It has two forms:</p>
<pre><span style="color:#323232;">#[cfg(foo)]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}

#[cfg(bar </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;baz&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1212">They also have some helpers:</p>
<pre><span style="color:#323232;">#[cfg(any(unix, windows))]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}

#[cfg(all(unix, target_pointer_width </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;32&quot;</span><span style="color:#323232;">))]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">() {}

#[cfg(not(foo))]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">not_foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1213">These can nest arbitrarily:</p>
<pre><span style="color:#323232;">#[cfg(any(not(unix), all(target_os</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#183691;">&quot;macos&quot;</span><span style="color:#323232;">, target_arch </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;powerpc&quot;</span><span style="color:#323232;">)))]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1214">As for how to enable or disable these switches, if you’re using Cargo, they get set in the <a href = "http://doc.crates.io/manifest.html#the-features-section"><code>[features]</code> section</a> of your <code>Cargo.toml</code>:</p>
<pre><span style="color:#323232;">[features]
# no features by default
default = []

# Add feature &quot;foo&quot; here, then you can use it. 
# Our &quot;foo&quot; feature depends on nothing else.
foo = []
</span></pre><p id = "para-1215">When you do this, Cargo passes along a flag to <code>rustc</code>:</p>
<pre><span style="color:#323232;">--cfg feature=&quot;${feature_name}&quot;
</span></pre><p id = "para-1216">The sum of these <code>cfg</code> flags will determine which ones get activated, and therefore, which code gets compiled. Let’s take this code:</p>
<pre><span style="color:#323232;">#[cfg(feature </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">foo {
}
</span></pre><p id = "para-1217">If we compile it with <code>cargo build --features “foo”</code>, it will send the <code>--cfg feature=“foo”</code> flag to <code>rustc</code>, and the output will have the <code>mod foo</code> in it. If we compile it with a regular <code>cargo build</code>, no extra flags get passed on, and so, no <code>foo</code> module will exist.</p>
<h2 id = "link-248">cfg_attr</h2>
<p id = "para-1218">You can also set another attribute based on a <code>cfg</code> variable with <code>cfg_attr</code>:</p>
<pre><span style="color:#323232;">#[cfg_attr(a, b)]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1219">Will be the same as <code>#[b]</code> if <code>a</code> is set by <code>cfg</code> attribute, and nothing otherwise.</p>
<h2 id = "link-249">cfg!</h2>
<p id = "para-1220">The <code>cfg!</code> macro lets you use these kinds of flags elsewhere in your code, too:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#323232;">cfg!(target_os </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;macos&quot;</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">|| </span><span style="color:#323232;">cfg!(target_os </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;ios&quot;</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;Think Different!&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1221">These will be replaced by a <code>true</code> or <code>false</code> at compile-time, depending on the configuration settings.</p>

</div><div id = "chapter-49" class = "chapter">
  <h2 id = "link-250">Documentation</h2>
<p id = "para-1222">Documentation is an important part of any software project, and it’s first-class in Rust. Let’s talk about the tooling Rust gives you to document your project.</p>
<h3 id = "link-251">About <code>rustdoc</code></h3>
<p id = "para-1223">The Rust distribution includes a tool, <code>rustdoc</code>, that generates documentation. <code>rustdoc</code> is also used by Cargo through <code>cargo doc</code>.</p>
<p id = "para-1224">Documentation can be generated in two ways: from source code, and from standalone Markdown files.</p>
<h3 id = "link-252">Documenting source code</h3>
<p id = "para-1225">The primary way of documenting a Rust project is through annotating the source code. You can use documentation comments for this purpose:</p>
<pre><span style="font-style:italic;color:#969896;">/// Constructs a new `Rc&lt;T&gt;`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">new</span><span style="color:#323232;">(value: T) -&gt; Rc&lt;T&gt; {
    </span><span style="font-style:italic;color:#969896;">// Implementation goes here.
</span><span style="color:#323232;">}
</span></pre><p id = "para-1226">This code generates documentation that looks <a href = "src/../../std/rc/struct.Rc.html#method.new">like this</a>. I’ve left the implementation out, with a regular comment in its place.</p>
<p id = "para-1227">The first thing to notice about this annotation is that it uses <code>///</code> instead of <code>//</code>. The triple slash indicates a documentation comment.</p>
<p id = "para-1228">Documentation comments are written in Markdown.</p>
<p id = "para-1229">Rust keeps track of these comments, and uses them when generating documentation. This is important when documenting things like enums:</p>
<pre><span style="font-style:italic;color:#969896;">/// The `Option` type. See [the module level documentation](index.html) for more.
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Option&lt;T&gt; {
    </span><span style="font-style:italic;color:#969896;">/// No value
    </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
    </span><span style="font-style:italic;color:#969896;">/// Some value `T`
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(T),
}
</span></pre><p id = "para-1230">The above works, but this does not:</p>
<pre><span style="font-style:italic;color:#969896;">/// The `Option` type. See [the module level documentation](index.html) for more.
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Option&lt;T&gt; {
    </span><span style="color:#0086b3;">None</span><span style="color:#323232;">, </span><span style="font-style:italic;color:#969896;">/// No value
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(T), </span><span style="font-style:italic;color:#969896;">/// Some value `T`
</span><span style="color:#323232;">}
</span></pre><p id = "para-1231">You’ll get an error:</p>
<pre><span style="color:#323232;">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</span></pre><p id = "para-1232">This <a href = "https://github.com/rust-lang/rust/issues/22547">unfortunate error</a> is correct; documentation comments apply to the thing after them, and there’s nothing after that last comment.</p>
<h4 id = "link-253">Writing documentation comments</h4>
<p id = "para-1233">Anyway, let’s cover each part of this comment in detail:</p>
<pre><span style="font-style:italic;color:#969896;">/// Constructs a new `Rc&lt;T&gt;`.
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1234">The first line of a documentation comment should be a short summary of its functionality. One sentence. Just the basics. High level.</p>
<pre><span style="font-style:italic;color:#969896;">///
/// Other details about constructing `Rc&lt;T&gt;`s, maybe describing complicated
/// semantics, maybe additional options, all kinds of stuff.
///
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1235">Our original example had just a summary line, but if we had more things to say, we could have added more explanation in a new paragraph.</p>
<h5 id = "link-254">Special sections</h5>
<p id = "para-1236">Next, are special sections. These are indicated with a header, <code>#</code>. There are four kinds of headers that are commonly used. They aren’t special syntax, just convention, for now.</p>
<pre><span style="font-style:italic;color:#969896;">/// # Panics
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1237">Unrecoverable misuses of a function (i.e. programming errors) in Rust are usually indicated by panics, which kill the whole current thread at the very least. If your function has a non-trivial contract like this, that is detected/enforced by panics, documenting it is very important.</p>
<pre><span style="font-style:italic;color:#969896;">/// # Errors
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1238">If your function or method returns a <code>Result&lt;T, E&gt;</code>, then describing the conditions under which it returns <code>Err(E)</code> is a nice thing to do. This is slightly less important than <code>Panics</code>, because failure is encoded into the type system, but it’s still a good thing to do.</p>
<pre><span style="font-style:italic;color:#969896;">/// # Safety
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1239">If your function is <code>unsafe</code>, you should explain which invariants the caller is responsible for upholding.</p>
<pre><span style="font-style:italic;color:#969896;">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1240">Fourth, <code>Examples</code>. Include one or more examples of using your function or method, and your users will love you for it. These examples go inside of code block annotations, which we’ll talk about in a moment, and can have more than one section:</p>
<pre><span style="font-style:italic;color:#969896;">/// # Examples
///
/// Simple `&amp;str` patterns:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;Mary had a little lamb&quot;.split(&#39; &#39;).collect();
/// assert_eq!(v, vec![&quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;]);
/// ```
///
/// More complex patterns with a lambda:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;abc1def2ghi&quot;.split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec![&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><h5 id = "link-255">Code block annotations</h5>
<p id = "para-1241">To write some Rust code in a comment, use the triple graves:</p>
<pre><span style="font-style:italic;color:#969896;">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1242">This will add code highlighting. If you are only showing plain text, put <code>text</code> instead of <code>rust</code> after the triple graves (see below).</p>
<h3 id = "link-256">Documentation as tests</h3>
<p id = "para-1243">Let’s discuss our sample example documentation:</p>
<pre><span style="font-style:italic;color:#969896;">/// ```
/// println!(&quot;Hello, world&quot;);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1244">You’ll notice that you don’t need a <code>fn main()</code> or anything here. <code>rustdoc</code> will automatically add a <code>main()</code> wrapper around your code, using heuristics to attempt to put it in the right place. For example:</p>
<pre><span style="font-style:italic;color:#969896;">/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1245">This will end up testing:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::rc::Rc;
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> five </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Rc::new(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1246">Here’s the full algorithm rustdoc uses to preprocess examples:</p>
<ol>
<li>Any leading <code>#![foo]</code> attributes are left intact as crate attributes.</li>
<li>Some common <code>allow</code> attributes are inserted, including <code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>, and <code>dead_code</code>. Small examples often trigger these lints.</li>
<li>If the example does not contain <code>extern crate</code>, then <code>extern crate &lt;mycrate&gt;;</code> is inserted (note the lack of <code>#[macro_use]</code>).</li>
<li>Finally, if the example does not contain <code>fn main</code>, the remainder of the text is wrapped in <code>fn main() { your_code }</code>.</li>
</ol>
<p id = "para-1247">This generated <code>fn main</code> can be a problem! If you have <code>extern crate</code> or a <code>mod</code> statements in the example code that are referred to by <code>use</code> statements, they will fail to resolve unless you include at least <code>fn main() {}</code> to inhibit step 4. <code>#[macro_use] extern crate</code> also does not work except at the crate root, so when testing macros an explicit <code>main</code> is always required. It doesn’t have to clutter up your docs, though -- keep reading!</p>
<p id = "para-1248">Sometimes this algorithm isn’t enough, though. For example, all of these code samples with <code>///</code> we’ve been talking about? The raw text:</p>
<pre><span style="color:#323232;">/// Some documentation.
# fn foo() {}
</span></pre><p id = "para-1249">looks different than the output:</p>
<pre><span style="font-style:italic;color:#969896;">/// Some documentation.
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1250">Yes, that’s right: you can add lines that start with <code>#</code>, and they will be hidden from the output, but will be used when compiling your code. You can use this to your advantage. In this case, documentation comments need to apply to some kind of function, so if I want to show you just a documentation comment, I need to add a little function definition below it. At the same time, it’s only there to satisfy the compiler, so hiding it makes the example more clear. You can use this technique to explain longer examples in detail, while still preserving the testability of your documentation.</p>
<p id = "para-1251">For example, imagine that we wanted to document this code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
</span></pre><p id = "para-1252">We might want the documentation to end up looking like this:</p>
<blockquote><p id = "para-1253">First, we set <code>x</code> to five:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
</span></pre><p id = "para-1254">Next, we set <code>y</code> to six:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
</span></pre><p id = "para-1255">Finally, we print the sum of <code>x</code> and <code>y</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;"># let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">6</span><span style="color:#323232;">;
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> y);
</span></pre></blockquote>
<p id = "para-1256">To keep each code block testable, we want the whole program in each block, but we don’t want the reader to see every line every time. Here’s what we put in our source code:</p>
<pre><span style="color:#323232;">    First, we set `x` to five:

    ```rust
    let x = 5;
    # let y = 6;
    # println!(&quot;{}&quot;, x + y);
    ```

    Next, we set `y` to six:

    ```rust
    # let x = 5;
    let y = 6;
    # println!(&quot;{}&quot;, x + y);
    ```

    Finally, we print the sum of `x` and `y`:

    ```rust
    # let x = 5;
    # let y = 6;
    println!(&quot;{}&quot;, x + y);
    ```
</span></pre><p id = "para-1257">By repeating all parts of the example, you can ensure that your example still compiles, while only showing the parts that are relevant to that part of your explanation.</p>
<h4 id = "link-257">Documenting macros</h4>
<p id = "para-1258">Here’s an example of documenting a macro:</p>
<pre><span style="font-style:italic;color:#969896;">/// Panic with a given message unless an expression evaluates to true.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, “Math is broken.”);
/// # }
/// ```
///
/// ```rust,should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, “I’m broken.”);
/// # }
/// ```
</span><span style="color:#323232;">#[macro_export]
</span><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">panic_unless {
    ($condition:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($rest:expr),</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">({ </span><span style="font-weight:bold;color:#a71d5d;">if ! </span><span style="color:#323232;">$condition { panic!(</span><span style="font-weight:bold;color:#a71d5d;">$</span><span style="color:#323232;">($rest),</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;">); } });
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1259">You’ll note three things: we need to add our own <code>extern crate</code> line, so that we can add the <code>#[macro_use]</code> attribute. Second, we’ll need to add our own <code>main()</code> as well (for reasons discussed above). Finally, a judicious use of <code>#</code> to comment out those two things, so they don’t show up in the output.</p>
<p id = "para-1260">Another case where the use of <code>#</code> is handy is when you want to ignore error handling. Lets say you want the following,</p>
<pre><span style="font-style:italic;color:#969896;">/// use std::io;
/// let mut input = String::new();
/// try!(io::stdin().read_line(&amp;mut input));
</span></pre><p id = "para-1261">The problem is that <code>try!</code> returns a <code>Result&lt;T, E&gt;</code> and test functions don’t return anything so this will give a mismatched types error.</p>
<pre><span style="font-style:italic;color:#969896;">/// A doc test using try!
///
/// ```
/// use std::io;
/// # fn foo() -&gt; io::Result&lt;()&gt; {
/// let mut input = String::new();
/// try!(io::stdin().read_line(&amp;mut input));
/// # Ok(())
/// # }
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1262">You can get around this by wrapping the code in a function. This catches and swallows the <code>Result&lt;T, E&gt;</code> when running tests on the docs. This pattern appears regularly in the standard library.</p>
<h4 id = "link-258">Running documentation tests</h4>
<p id = "para-1263">To run the tests, either:</p>
<pre><span style="color:#323232;">$ rustdoc --test path/to/my/crate/root.rs
</span><span style="font-style:italic;color:#969896;"># or
</span><span style="color:#323232;">$ cargo test
</span></pre><p id = "para-1264">That’s right, <code>cargo test</code> tests embedded documentation too. <b>However, <code>cargo test</code> will not test binary crates, only library ones.</b> This is due to the way <code>rustdoc</code> works: it links against the library to be tested, but with a binary, there’s nothing to link to.</p>
<p id = "para-1265">There are a few more annotations that are useful to help <code>rustdoc</code> do the right thing when testing your code:</p>
<pre><span style="font-style:italic;color:#969896;">/// ```rust,ignore
/// fn foo() {
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1266">The <code>ignore</code> directive tells Rust to ignore your code. This is almost never what you want, as it’s the most generic. Instead, consider annotating it with <code>text</code> if it’s not code, or using <code>#</code>s to get a working example that only shows the part you care about.</p>
<pre><span style="font-style:italic;color:#969896;">/// ```rust,should_panic
/// assert!(false);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1267"><code>should_panic</code> tells <code>rustdoc</code> that the code should compile correctly, but not actually pass as a test.</p>
<pre><span style="font-style:italic;color:#969896;">/// ```rust,no_run
/// loop {
///     println!(&quot;Hello, world&quot;);
/// }
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1268">The <code>no_run</code> attribute will compile your code, but not run it. This is important for examples such as “Here’s how to retrieve a web page,” which you would want to ensure compiles, but might be run in a test environment that has no network access.</p>
<h4 id = "link-259">Documenting modules</h4>
<p id = "para-1269">Rust has another kind of doc comment, <code>//!</code>. This comment doesn’t document the next item, but the enclosing item. In other words:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">foo {
    </span><span style="font-style:italic;color:#969896;">//! This is documentation for the `foo` module.
    //!
    //! # Examples

    // ...
</span><span style="color:#323232;">}
</span></pre><p id = "para-1270">This is where you’ll see <code>//!</code> used most often: for module documentation. If you have a module in <code>foo.rs</code>, you’ll often open its code and see this:</p>
<pre><span style="font-style:italic;color:#969896;">//! A module for using `foo`s.
//!
//! The `foo` module contains a lot of useful functionality blah blah blah...
</span></pre><h4 id = "link-260">Crate documentation</h4>
<p id = "para-1271">Crates can be documented by placing an inner doc comment (<code>//!</code>) at the beginning of the crate root, aka <code>lib.rs</code>:</p>
<pre><span style="font-style:italic;color:#969896;">//! This is documentation for the `foo` crate.
//!
//! The foo crate is meant to be used for bar.
</span></pre><h4 id = "link-261">Documentation comment style</h4>
<p id = "para-1272">Check out <a href = "https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> for full conventions around the style and format of documentation.</p>
<h3 id = "link-262">Other documentation</h3>
<p id = "para-1273">All of this behavior works in non-Rust source files too. Because comments are written in Markdown, they’re often <code>.md</code> files.</p>
<p id = "para-1274">When you write documentation in Markdown files, you don’t need to prefix the documentation with comments. For example:</p>
<pre><span style="font-style:italic;color:#969896;">/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1275">is:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="font-weight:bold;color:#323232;">Examples

</span><span style="color:#a71d5d;">```</span><span style="color:#323232;">
use std::rc::Rc;
</span><span style="font-weight:bold;color:#b52a1d;">
</span><span style="color:#323232;">let five = Rc::new(5);
</span><span style="color:#a71d5d;">```
</span></pre><p id = "para-1276">when it’s in a Markdown file. There is one wrinkle though: Markdown files need to have a title like this:</p>
<pre><span style="color:#323232;">% The title

This is the example documentation.
</span></pre><p id = "para-1277">This <code>%</code> line needs to be the very first line of the file.</p>
<h3 id = "link-263"><code>doc</code> attributes</h3>
<p id = "para-1278">At a deeper level, documentation comments are syntactic sugar for documentation attributes:</p>
<pre><span style="font-style:italic;color:#969896;">/// this
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}

#[doc</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#183691;">&quot;this&quot;</span><span style="color:#323232;">]
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1279">are the same, as are these:</p>
<pre><span style="font-style:italic;color:#969896;">//! this

</span><span style="color:#323232;">#![doc</span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#183691;">&quot;this&quot;</span><span style="color:#323232;">]
</span></pre><p id = "para-1280">You won’t often see this attribute used for writing documentation, but it can be useful when changing some options, or when writing a macro.</p>
<h4 id = "link-264">Re-exports</h4>
<p id = "para-1281"><code>rustdoc</code> will show the documentation for a public re-export in both places:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> foo;

</span><span style="font-weight:bold;color:#a71d5d;">pub use </span><span style="color:#323232;">foo::bar;
</span></pre><p id = "para-1282">This will create documentation for <code>bar</code> both inside the documentation for the crate <code>foo</code>, as well as the documentation for your crate. It will use the same documentation in both places.</p>
<p id = "para-1283">This behavior can be suppressed with <code>no_inline</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> foo;

#[doc(no_inline)]
</span><span style="font-weight:bold;color:#a71d5d;">pub use </span><span style="color:#323232;">foo::bar;
</span></pre><h3 id = "link-265">Missing documentation</h3>
<p id = "para-1284">Sometimes you want to make sure that every single public thing in your project is documented, especially when you are working on a library. Rust allows you to to generate warnings or errors, when an item is missing documentation. To generate warnings you use <code>warn</code>:</p>
<pre><span style="color:#323232;">#![warn(missing_docs)]
</span></pre><p id = "para-1285">And to generate errors you use <code>deny</code>:</p>
<pre><span style="color:#323232;">#![deny(missing_docs)]
</span></pre><p id = "para-1286">There are cases where you want to disable these warnings/errors to explicitly leave something undocumented. This is done by using <code>allow</code>:</p>
<pre><span style="color:#323232;">#[allow(missing_docs)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Undocumented;
</span></pre><p id = "para-1287">You might even want to hide items from the documentation completely:</p>
<pre><span style="color:#323232;">#[doc(hidden)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Hidden;
</span></pre><h4 id = "link-266">Controlling HTML</h4>
<p id = "para-1288">You can control a few aspects of the HTML that <code>rustdoc</code> generates through the <code>#![doc]</code> version of the attribute:</p>
<pre><span style="color:#323232;">#![doc(html_logo_url </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;</span><span style="color:#323232;">,
       html_favicon_url </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;https://www.rust-lang.org/favicon.ico&quot;</span><span style="color:#323232;">,
       html_root_url </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;https://doc.rust-lang.org/&quot;</span><span style="color:#323232;">)]
</span></pre><p id = "para-1289">This sets a few different options, with a logo, favicon, and a root URL.</p>
<h4 id = "link-267">Configuring documentation tests</h4>
<p id = "para-1290">You can also configure the way that <code>rustdoc</code> tests your documentation examples through the <code>#![doc(test(..))]</code> attribute.</p>
<pre><span style="color:#323232;">#![doc(test(attr(allow(unused_variables), deny(warnings))))]
</span></pre><p id = "para-1291">This allows unused variables within the examples, but will fail the test for any other lint warning thrown.</p>
<h3 id = "link-268">Generation options</h3>
<p id = "para-1292"><code>rustdoc</code> also contains a few other options on the command line, for further customization:</p>
<ul>
<li><code>--html-in-header FILE</code>: includes the contents of FILE at the end of the <code>&lt;head&gt;...&lt;/head&gt;</code> section.</li>
<li><code>--html-before-content FILE</code>: includes the contents of FILE directly after <code>&lt;body&gt;</code>, before the rendered content (including the search bar).</li>
<li><code>--html-after-content FILE</code>: includes the contents of FILE after all the rendered content.</li>
</ul>
<h3 id = "link-269">Security note</h3>
<p id = "para-1293">The Markdown in documentation comments is placed without processing into the final webpage. Be careful with literal HTML:</p>
<pre><span style="font-style:italic;color:#969896;">/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">() {}
</span></pre>
</div><div id = "chapter-50" class = "chapter">
  <h2 id = "link-270">Iterators</h2>
<p id = "para-1294">Let’s talk about loops.</p>
<p id = "para-1295">Remember Rust’s <code>for</code> loop? Here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-1296">Now that you know more Rust, we can talk in detail about how this works. Ranges (the <code>0..10</code>) are ‘iterators’. An iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things.</p>
<p id = "para-1297">A range with two dots like <code>0..10</code> is inclusive on the left (so it starts at 0) and exclusive on the right (so it ends at 9). A mathematician would write “[0, 10)”.</p>
<p id = "para-1298">Like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> range </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;">loop </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> range.</span><span style="color:#62a35c;">next</span><span style="color:#323232;">() {
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(x) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
            println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
        },
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">break </span><span style="color:#323232;">}
    }
}
</span></pre><p id = "para-1299">We make a mutable binding to the range, which is our iterator. We then <code>loop</code>, with an inner <code>match</code>. This <code>match</code> is used on the result of <code>range.next()</code>, which gives us a reference to the next value of the iterator. <code>next</code> returns an <code>Option&lt;i32&gt;</code>, in this case, which will be <code>Some(i32)</code> when we have a value and <code>None</code> once we run out. If we get <code>Some(i32)</code>, we print it out, and if we get <code>None</code>, we <code>break</code> out of the loop.</p>
<p id = "para-1300">This code sample is basically the same as our <code>for</code> loop version. The <code>for</code> loop is a handy way to write this <code>loop</code>/<code>match</code>/<code>break</code> construct.</p>
<p id = "para-1301"><code>for</code> loops aren’t the only thing that uses iterators, however. Writing your own iterator involves implementing the <code>Iterator</code> trait. While doing that is outside of the scope of this guide, Rust provides a number of useful iterators to accomplish various tasks. But first, a few notes about limitations of ranges.</p>
<p id = "para-1302">Ranges are very primitive, and we often can use better alternatives. Consider the following Rust anti-pattern: using ranges to emulate a C-style <code>for</code> loop. Let’s suppose you needed to iterate over the contents of a vector. You may be tempted to write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">nums.</span><span style="color:#62a35c;">len</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, nums[i]);
}
</span></pre><p id = "para-1303">This is strictly worse than using an actual iterator. You can iterate over vectors directly, so write this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">nums {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, num);
}
</span></pre><p id = "para-1304">There are two reasons for this. First, this more directly expresses what we mean. We iterate through the entire vector, rather than iterating through indexes, and then indexing the vector. Second, this version is more efficient: the first version will have extra bounds checking because it used indexing, <code>nums[i]</code>. But since we yield a reference to each element of the vector in turn with the iterator, there’s no bounds checking in the second example. This is very common with iterators: we can ignore unnecessary bounds checks, but still know that we’re safe.</p>
<p id = "para-1305">There’s another detail here that’s not 100% clear because of how <code>println!</code> works. <code>num</code> is actually of type <code>&amp;i32</code>. That is, it’s a reference to an <code>i32</code>, not an <code>i32</code> itself. <code>println!</code> handles the dereferencing for us, so we don’t see it. This code works fine too:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">in &amp;</span><span style="color:#323232;">nums {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">num);
}
</span></pre><p id = "para-1306">Now we’re explicitly dereferencing <code>num</code>. Why does <code>&amp;nums</code> give us references? Firstly, because we explicitly asked it to with <code>&amp;</code>. Secondly, if it gave us the data itself, we would have to be its owner, which would involve making a copy of the data and giving us the copy. With references, we’re only borrowing a reference to the data, and so it’s only passing a reference, without needing to do the move.</p>
<p id = "para-1307">So, now that we’ve established that ranges are often not what you want, let’s talk about what you do want instead.</p>
<p id = "para-1308">There are three broad classes of things that are relevant here: iterators, <em>iterator adaptors</em>, and <em>consumers</em>. Here’s some definitions:</p>
<ul>
<li><em>iterators</em> give you a sequence of values.</li>
<li><em>iterator adaptors</em> operate on an iterator, producing a new iterator with a different output sequence.</li>
<li><em>consumers</em> operate on an iterator, producing some final set of values.</li>
</ul>
<p id = "para-1309">Let’s talk about consumers first, since you’ve already seen an iterator, ranges.</p>
<h3 id = "link-271">Consumers</h3>
<p id = "para-1310">A <em>consumer</em> operates on an iterator, returning some kind of value or values. The most common consumer is <code>collect()</code>. This code doesn’t quite compile, but it shows the intention:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> one_to_one_hundred </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">101</span><span style="color:#323232;">).</span><span style="color:#62a35c;">collect</span><span style="color:#323232;">();
</span></pre><p id = "para-1311">As you can see, we call <code>collect()</code> on our iterator. <code>collect()</code> takes as many values as the iterator will give it, and returns a collection of the results. So why won’t this compile? Rust can’t determine what type of things you want to collect, and so you need to let it know. Here’s the version that does compile:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> one_to_one_hundred </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">101</span><span style="color:#323232;">).collect::&lt;Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;&gt;();
</span></pre><p id = "para-1312">If you remember, the <a href = "#chapter-25"><code>::&lt;&gt;</code> syntax</a> allows us to give a type hint that tells the compiler we want a vector of integers. You don’t always need to use the whole type, though. Using a <code>_</code> will let you provide a partial hint:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> one_to_one_hundred </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">101</span><span style="color:#323232;">).collect::&lt;Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">&gt;&gt;();
</span></pre><p id = "para-1313">This says “Collect into a <code>Vec&lt;T&gt;</code>, please, but infer what the <code>T</code> is for me." <code>_</code> is sometimes called a “type placeholder” for this reason.</p>
<p id = "para-1314"><code>collect()</code> is the most common consumer, but there are others too. <code>find()</code> is one:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> greater_than_forty_two </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">)
                             .</span><span style="color:#62a35c;">find</span><span style="color:#323232;">(|x| </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">x </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">42</span><span style="color:#323232;">);

</span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> greater_than_forty_two {
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Found a match!&quot;</span><span style="color:#323232;">),
    </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;No match found :(&quot;</span><span style="color:#323232;">),
}
</span></pre><p id = "para-1315"><code>find</code> takes a closure, and works on a reference to each element of an iterator. This closure returns <code>true</code> if the element is the element we’re looking for, and <code>false</code> otherwise. <code>find</code> returns the first element satisfying the specified predicate. Because we might not find a matching element, <code>find</code> returns an <code>Option</code> rather than the element itself.</p>
<p id = "para-1316">Another important consumer is <code>fold</code>. Here’s what it looks like:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> sum </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">4</span><span style="color:#323232;">).</span><span style="color:#62a35c;">fold</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, |sum, x| sum </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> x);
</span></pre><p id = "para-1317"><code>fold()</code> is a consumer that looks like this: <code>fold(base, |accumulator, element| ...)</code>. It takes two arguments: the first is an element called the <em>base</em>. The second is a closure that itself takes two arguments: the first is called the <em>accumulator</em>, and the second is an <em>element</em>. Upon each iteration, the closure is called, and the result is the value of the accumulator on the next iteration. On the first iteration, the base is assigned the value of the accumulator.</p>
<p id = "para-1318">Okay, that’s a bit confusing. Let’s examine the values of all of these things in this iterator:</p>
<div class = "table">
    <table>
<tr>
<th> base </th><th> accumulator </th><th> element </th><th> closure result </th></tr>
<tr>
<td> 0 </td><td> 0 </td><td> 1 </td><td> 1 </td></tr>
<tr>
<td> 0 </td><td> 1 </td><td> 2 </td><td> 3 </td></tr>
<tr>
<td> 0 </td><td> 3 </td><td> 3 </td><td> 6 </td></tr>

    </table>
</div>
<p id = "para-1319">We called <code>fold()</code> with these arguments:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">4</span><span style="color:#323232;">)
.</span><span style="color:#62a35c;">fold</span><span style="color:#323232;">(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, |sum, x| sum </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> x);
</span></pre><p id = "para-1320">So, <code>0</code> is our base, <code>sum</code> is our accumulator, and <code>x</code> is our element. On the first iteration, we set <code>sum</code> to <code>0</code>, and <code>x</code> is the first element of <code>nums</code>, <code>1</code>. We then add <code>sum</code> and <code>x</code>, which gives us <code>0 + 1 = 1</code>. On the second iteration, that value becomes our accumulator, <code>sum</code>, and the element is the second element of the array, <code>2</code>. <code>1 + 2 = 3</code>, and so that becomes the value of the accumulator for the last iteration. On that iteration, <code>x</code> is the last element, <code>3</code>, and <code>3 + 3 = 6</code>, which is our final result for our sum. <code>1 + 2 + 3 = 6</code>, and that’s the result we got.</p>
<p id = "para-1321">Whew. <code>fold</code> can be a bit strange the first few times you see it, but once it clicks, you can use it all over the place. Any time you have a list of things, and you want a single result, <code>fold</code> is appropriate.</p>
<p id = "para-1322">Consumers are important due to one additional property of iterators we haven’t talked about yet: laziness. Let’s talk some more about iterators, and you’ll see why consumers matter.</p>
<h3 id = "link-272">Iterators</h3>
<p id = "para-1323">As we’ve said before, an iterator is something that we can call the <code>.next()</code> method on repeatedly, and it gives us a sequence of things. Because you need to call the method, this means that iterators can be <em>lazy</em> and not generate all of the values upfront. This code, for example, does not actually generate the numbers <code>1-99</code>, instead creating a value that merely represents the sequence:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">;
</span></pre><p id = "para-1324">Since we didn’t do anything with the range, it didn’t generate the sequence. Let’s add the consumer:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">).collect::&lt;Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;&gt;();
</span></pre><p id = "para-1325">Now, <code>collect()</code> will require that the range gives it some numbers, and so it will do the work of generating the sequence.</p>
<p id = "para-1326">Ranges are one of two basic iterators that you’ll see. The other is <code>iter()</code>. <code>iter()</code> can turn a vector into a simple iterator that gives you each element in turn:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> nums </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

</span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> num </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> nums.</span><span style="color:#62a35c;">iter</span><span style="color:#323232;">() {
   println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, num);
}
</span></pre><p id = "para-1327">These two basic iterators should serve you well. There are some more advanced iterators, including ones that are infinite.</p>
<p id = "para-1328">That’s enough about iterators. Iterator adaptors are the last concept we need to talk about with regards to iterators. Let’s get to it!</p>
<h3 id = "link-273">Iterator adaptors</h3>
<p id = "para-1329"><em>Iterator adaptors</em> take an iterator and modify it somehow, producing a new iterator. The simplest one is called <code>map</code>:</p>
<pre><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">).</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|x| x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
</span></pre><p id = "para-1330"><code>map</code> is called upon another iterator, and produces a new iterator where each element reference has the closure it’s been given as an argument called on it. So this would give us the numbers from <code>2-100</code>. Well, almost! If you compile the example, you’ll get a warning:</p>
<pre><span style="color:#323232;">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</span></pre><p id = "para-1331">Laziness strikes again! That closure will never execute. This example doesn’t print any numbers:</p>
<pre><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">).</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|x| println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x));
</span></pre><p id = "para-1332">If you are trying to execute a closure on an iterator for its side effects, use <code>for</code> instead.</p>
<p id = "para-1333">There are tons of interesting iterator adaptors. <code>take(n)</code> will return an iterator over the next <code>n</code> elements of the original iterator. Let’s try it out with an infinite iterator:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">).</span><span style="color:#62a35c;">take</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-1334">This will print</p>
<pre><span style="color:#323232;">1
2
3
4
5
</span></pre><p id = "para-1335"><code>filter()</code> is an adapter that takes a closure as an argument. This closure returns <code>true</code> or <code>false</code>. The new iterator <code>filter()</code> produces only the elements that the closure returns <code>true</code> for:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">100</span><span style="color:#323232;">).</span><span style="color:#62a35c;">filter</span><span style="color:#323232;">(|</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x| x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, i);
}
</span></pre><p id = "para-1336">This will print all of the even numbers between one and a hundred. (Note that, unlike <code>map</code>, the closure passed to <code>filter</code> is passed a reference to the element instead of the element itself. The filter predicate here uses the <code>&amp;x</code> pattern to extract the integer. The filter closure is passed a reference because it returns <code>true</code> or <code>false</code> instead of the element, so the <code>filter</code> implementation must retain ownership to put the elements into the newly constructed iterator.)</p>
<p id = "para-1337">You can chain all three things together: start with an iterator, adapt it a few times, and then consume the result. Check it out:</p>
<pre><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">)
    .</span><span style="color:#62a35c;">filter</span><span style="color:#323232;">(|</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x| x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0</span><span style="color:#323232;">)
    .</span><span style="color:#62a35c;">filter</span><span style="color:#323232;">(|</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">x| x </span><span style="font-weight:bold;color:#a71d5d;">% </span><span style="color:#0086b3;">3 </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0</span><span style="color:#323232;">)
    .</span><span style="color:#62a35c;">take</span><span style="color:#323232;">(</span><span style="color:#0086b3;">5</span><span style="color:#323232;">)
    .collect::&lt;Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;&gt;();
</span></pre><p id = "para-1338">This will give you a vector containing <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, and <code>30</code>.</p>
<p id = "para-1339">This is just a small taste of what iterators, iterator adaptors, and consumers can help you with. There are a number of really useful iterators, and you can write your own as well. Iterators provide a safe, efficient way to manipulate all kinds of lists. They’re a little unusual at first, but if you play with them, you’ll get hooked. For a full list of the different iterators and consumers, check out the <a href = "src/../../std/iter/index.html">iterator module documentation</a>.</p>

</div><div id = "chapter-51" class = "chapter">
  <h2 id = "link-274">Concurrency</h2>
<p id = "para-1340">Concurrency and parallelism are incredibly important topics in computer science, and are also a hot topic in industry today. Computers are gaining more and more cores, yet many programmers aren’t prepared to fully utilize them.</p>
<p id = "para-1341">Rust’s memory safety features also apply to its concurrency story. Even concurrent Rust programs must be memory safe, having no data races. Rust’s type system is up to the task, and gives you powerful ways to reason about concurrent code at compile time.</p>
<p id = "para-1342">Before we talk about the concurrency features that come with Rust, it’s important to understand something: Rust is low-level enough that the vast majority of this is provided by the standard library, not by the language. This means that if you don’t like some aspect of the way Rust handles concurrency, you can implement an alternative way of doing things. <a href = "https://github.com/carllerche/mio">mio</a> is a real-world example of this principle in action.</p>
<h3 id = "link-275">Background: <code>Send</code> and <code>Sync</code></h3>
<p id = "para-1343">Concurrency is difficult to reason about. In Rust, we have a strong, static type system to help us reason about our code. As such, Rust gives us two traits to help us make sense of code that can possibly be concurrent.</p>
<h4 id = "link-276"><code>Send</code></h4>
<p id = "para-1344">The first trait we’re going to talk about is <a href = "src/../../std/marker/trait.Send.html"><code>Send</code></a>. When a type <code>T</code> implements <code>Send</code>, it indicates that something of this type is able to have ownership transferred safely between threads.</p>
<p id = "para-1345">This is important to enforce certain restrictions. For example, if we have a channel connecting two threads, we would want to be able to send some data down the channel and to the other thread. Therefore, we’d ensure that <code>Send</code> was implemented for that type.</p>
<p id = "para-1346">In the opposite way, if we were wrapping a library with <a href = "#chapter-54">FFI</a> that isn’t thread-safe, we wouldn’t want to implement <code>Send</code>, and so the compiler will help us enforce that it can’t leave the current thread.</p>
<h4 id = "link-277"><code>Sync</code></h4>
<p id = "para-1347">The second of these traits is called <a href = "src/../../std/marker/trait.Sync.html"><code>Sync</code></a>. When a type <code>T</code> implements <code>Sync</code>, it indicates that something of this type has no possibility of introducing memory unsafety when used from multiple threads concurrently through shared references. This implies that types which don’t have <a href = "#chapter-18">interior mutability</a> are inherently <code>Sync</code>, which includes simple primitive types (like <code>u8</code>) and aggregate types containing them.</p>
<p id = "para-1348">For sharing references across threads, Rust provides a wrapper type called <code>Arc&lt;T&gt;</code>. <code>Arc&lt;T&gt;</code> implements <code>Send</code> and <code>Sync</code> if and only if <code>T</code> implements both <code>Send</code> and <code>Sync</code>. For example, an object of type <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> cannot be transferred across threads because <a href = "#chapter-53"><code>RefCell</code></a> does not implement <code>Sync</code>, consequently <code>Arc&lt;RefCell&lt;U&gt;&gt;</code> would not implement <code>Send</code>.</p>
<p id = "para-1349">These two traits allow you to use the type system to make strong guarantees about the properties of your code under concurrency. Before we demonstrate why, we need to learn how to create a concurrent Rust program in the first place!</p>
<h3 id = "link-278">Threads</h3>
<p id = "para-1350">Rust’s standard library provides a library for threads, which allow you to run Rust code in parallel. Here’s a basic example of using <code>std::thread</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    thread::spawn(|| {
        println!(</span><span style="color:#183691;">&quot;Hello from a thread!&quot;</span><span style="color:#323232;">);
    });
}
</span></pre><p id = "para-1351">The <code>thread::spawn()</code> method accepts a <a href = "#chapter-30">closure</a>, which is executed in a new thread. It returns a handle to the thread, that can be used to wait for the child thread to finish and extract its result:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> handle </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">thread::spawn(|| {
        </span><span style="color:#183691;">&quot;Hello from a thread!&quot;
    </span><span style="color:#323232;">});

    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, handle.</span><span style="color:#62a35c;">join</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">());
}
</span></pre><p id = "para-1352">As closures can capture variables from their environment, we can also try to bring some data into the other thread:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
    thread::spawn(|| {
        println!(</span><span style="color:#183691;">&quot;x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
    });
}
</span></pre><p id = "para-1353">However, this gives us an error:</p>
<pre><span style="color:#323232;">5:19: 7:6 error: closure may outlive the current function, but it
                 borrows `x`, which is owned by the current function
...
5:19: 7:6 help: to force the closure to take ownership of `x` (and any other referenced variables),
          use the `move` keyword, as shown:
      thread::spawn(move || {
          println!(&quot;x is {}&quot;, x);
      });
</span></pre><p id = "para-1354">This is because by default closures capture variables by reference, and thus the closure only captures a <em>reference to <code>x</code></em>. This is a problem, because the thread may outlive the scope of <code>x</code>, leading to a dangling pointer.</p>
<p id = "para-1355">To fix this, we use a <code>move</code> closure as mentioned in the error message. <code>move</code> closures are explained in depth <a href = "#chapter-30">here</a>; basically they move variables from their environment into themselves.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
    thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;x is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
    });
}
</span></pre><p id = "para-1356">Many languages have the ability to execute threads, but it’s wildly unsafe. There are entire books about how to prevent errors that occur from shared mutable state. Rust helps out with its type system here as well, by preventing data races at compile time. Let’s talk about how you actually share things between threads.</p>
<h3 id = "link-279">Safe Shared Mutable State</h3>
<p id = "para-1357">Due to Rust’s type system, we have a concept that sounds like a lie: “safe shared mutable state.” Many programmers agree that shared mutable state is very, very bad.</p>
<p id = "para-1358">Someone once said this:</p>
<blockquote><p id = "para-1359">Shared mutable state is the root of all evil. Most languages attempt to deal with this problem through the ‘mutable’ part, but Rust deals with it by solving the ‘shared’ part.</p>
</blockquote>
<p id = "para-1360">The same <a href = "#chapter-15">ownership system</a> that helps prevent using pointers incorrectly also helps rule out data races, one of the worst kinds of concurrency bugs.</p>
<p id = "para-1361">As an example, here is a Rust program that would have a data race in many languages. It will not compile:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::time::Duration;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">3 </span><span style="color:#323232;">{
        thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            data[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> i;
        });
    }

    thread::sleep(Duration::from_millis(</span><span style="color:#0086b3;">50</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1362">This gives us an error:</p>
<pre><span style="color:#323232;">8:17 error: capture of moved value: `data`
        data[0] += i;
        ^~~~
</span></pre><p id = "para-1363">Rust knows this wouldn’t be safe! If we had a reference to <code>data</code> in each thread, and the thread takes ownership of the reference, we’d have three owners! <code>data</code> gets moved out of <code>main</code> in the first call to <code>spawn()</code>, so subsequent calls in the loop cannot use this variable.</p>
<p id = "para-1364">So, we need some type that lets us have more than one owning reference to a value. Usually, we’d use <code>Rc&lt;T&gt;</code> for this, which is a reference counted type that provides shared ownership. It has some runtime bookkeeping that keeps track of the number of references to it, hence the “reference count” part of its name.</p>
<p id = "para-1365">Calling <code>clone()</code> on an <code>Rc&lt;T&gt;</code> will return a new owned reference and bump the internal reference count. We create one of these for each thread:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::time::Duration;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::rc::Rc;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Rc::new(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]);

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">3 </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Create a new owned reference:
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data_ref </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();

        </span><span style="font-style:italic;color:#969896;">// Use it in a thread:
        </span><span style="color:#323232;">thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            data_ref[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> i;
        });
    }

    thread::sleep(Duration::from_millis(</span><span style="color:#0086b3;">50</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1366">This won’t work, however, and will give us the error:</p>
<pre><span style="color:#323232;">13:9: 13:22 error: the trait bound `alloc::rc::Rc&lt;collections::vec::Vec&lt;i32&gt;&gt; : core::marker::Send`
            is not satisfied
...
13:9: 13:22 note: `alloc::rc::Rc&lt;collections::vec::Vec&lt;i32&gt;&gt;`
            cannot be sent between threads safely
</span></pre><p id = "para-1367">As the error message mentions, <code>Rc</code> cannot be sent between threads safely. This is because the internal reference count is not maintained in a thread-safe manner and can have a data race.</p>
<p id = "para-1368">To solve this, we’ll use <code>Arc&lt;T&gt;</code>, Rust’s standard atomic reference count type.</p>
<p id = "para-1369">The Atomic part means <code>Arc&lt;T&gt;</code> can safely be accessed from multiple threads. To do this the compiler guarantees that mutations of the internal count use indivisible operations which can’t have data races.</p>
<p id = "para-1370">In essence, <code>Arc&lt;T&gt;</code> is a type that lets us share ownership of data <em>across threads</em>.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::Arc;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::time::Duration;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Arc::new(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]);

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">3 </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
        thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            data[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> i;
        });
    }

    thread::sleep(Duration::from_millis(</span><span style="color:#0086b3;">50</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1371">Similarly to last time, we use <code>clone()</code> to create a new owned handle. This handle is then moved into the new thread.</p>
<p id = "para-1372">And... still gives us an error.</p>
<pre><span style="color:#323232;">&lt;anon&gt;:11:24 error: cannot borrow immutable borrowed content as mutable
&lt;anon&gt;:11                    data[0] += i;
                             ^~~~
</span></pre><p id = "para-1373"><code>Arc&lt;T&gt;</code> by default has immutable contents. It allows the <em>sharing</em> of data between threads, but shared mutable data is unsafe—and when threads are involved—can cause data races!</p>
<p id = "para-1374">Usually when we wish to make something in an immutable position mutable, we use <code>Cell&lt;T&gt;</code> or <code>RefCell&lt;T&gt;</code> which allow safe mutation via runtime checks or otherwise (see also: <a href = "#chapter-53">Choosing Your Guarantees</a>). However, similar to <code>Rc</code>, these are not thread-safe. If we try using these, we will get an error about these types not being <code>Sync</code>, and the code will fail to compile.</p>
<p id = "para-1375">It looks like we need some type that allows us to safely mutate a shared value across threads, for example a type that can ensure only one thread at a time is able to mutate the value inside it at any one time.</p>
<p id = "para-1376">For that, we can use the <code>Mutex&lt;T&gt;</code> type!</p>
<p id = "para-1377">Here’s the working version:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::{Arc, Mutex};
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::time::Duration;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Arc::new(Mutex::new(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]));

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">3 </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
        thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">lock</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
            data[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> i;
        });
    }

    thread::sleep(Duration::from_millis(</span><span style="color:#0086b3;">50</span><span style="color:#323232;">));
}
</span></pre><p id = "para-1378">Note that the value of <code>i</code> is bound (copied) to the closure and not shared among the threads.</p>
<p id = "para-1379">We’re “locking” the mutex here. A mutex (short for “mutual exclusion”), as mentioned, only allows one thread at a time to access a value. When we wish to access the value, we use <code>lock()</code> on it. This will “lock” the mutex, and no other thread will be able to lock it (and hence, do anything with the value) until we’re done with it. If a thread attempts to lock a mutex which is already locked, it will wait until the other thread releases the lock.</p>
<p id = "para-1380">The lock “release” here is implicit; when the result of the lock (in this case, <code>data</code>) goes out of scope, the lock is automatically released.</p>
<p id = "para-1381">Note that <a href = "src/../../std/sync/struct.Mutex.html#method.lock"><code>lock</code></a> method of <a href = "src/../../std/sync/struct.Mutex.html"><code>Mutex</code></a> has this signature:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">lock</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
</span></pre><p id = "para-1382">and because <code>Send</code> is not implemented for <code>MutexGuard&lt;T&gt;</code>, the guard cannot cross thread boundaries, ensuring thread-locality of lock acquire and release.</p>
<p id = "para-1383">Let’s examine the body of the thread more closely:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::sync::{Arc, Mutex};
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::time::Duration;
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;">#     let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Arc::new(Mutex::new(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">]));
</span><span style="font-weight:bold;color:#a71d5d;">#     for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">3 </span><span style="color:#323232;">{
</span><span style="font-weight:bold;color:#a71d5d;">#         let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();
thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">lock</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    data[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">+=</span><span style="color:#323232;"> i;
});
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">thread::sleep(Duration::from_millis(</span><span style="color:#0086b3;">50</span><span style="color:#323232;">));
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span></pre><p id = "para-1384">First, we call <code>lock()</code>, which acquires the mutex’s lock. Because this may fail, it returns a <code>Result&lt;T, E&gt;</code>, and because this is just an example, we <code>unwrap()</code> it to get a reference to the data. Real code would have more robust error handling here. We’re then free to mutate it, since we have the lock.</p>
<p id = "para-1385">Lastly, while the threads are running, we wait on a short timer. But this is not ideal: we may have picked a reasonable amount of time to wait but it’s more likely we’ll either be waiting longer than necessary or not long enough, depending on just how much time the threads actually take to finish computing when the program runs.</p>
<p id = "para-1386">A more precise alternative to the timer would be to use one of the mechanisms provided by the Rust standard library for synchronizing threads with each other. Let’s talk about one of them: channels.</p>
<h3 id = "link-280">Channels</h3>
<p id = "para-1387">Here’s a version of our code that uses channels for synchronization, rather than waiting for a specific time:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::{Arc, Mutex};
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::mpsc;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Arc::new(Mutex::new(</span><span style="color:#0086b3;">0</span><span style="color:#323232;">));

    </span><span style="font-style:italic;color:#969896;">// `tx` is the &quot;transmitter&quot; or &quot;sender&quot;.
    // `rx` is the &quot;receiver&quot;.
    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(tx, rx) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">mpsc::channel();

    </span><span style="font-weight:bold;color:#a71d5d;">for _ in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(data, tx) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(data.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">(), tx.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">());

        thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> data </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> data.</span><span style="color:#62a35c;">lock</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
            </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">data </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;

            tx.</span><span style="color:#62a35c;">send</span><span style="color:#323232;">(()).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
        });
    }

    </span><span style="font-weight:bold;color:#a71d5d;">for _ in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        rx.</span><span style="color:#62a35c;">recv</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    }
}
</span></pre><p id = "para-1388">We use the <code>mpsc::channel()</code> method to construct a new channel. We <code>send</code> a simple <code>()</code> down the channel, and then wait for ten of them to come back.</p>
<p id = "para-1389">While this channel is sending a generic signal, we can send any data that is <code>Send</code> over the channel!</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::sync::mpsc;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let </span><span style="color:#323232;">(tx, rx) </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">mpsc::channel();

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> tx </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> tx.</span><span style="color:#62a35c;">clone</span><span style="color:#323232;">();

        thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
            </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> answer </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> i;

            tx.</span><span style="color:#62a35c;">send</span><span style="color:#323232;">(answer).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
        });
    }

    </span><span style="font-weight:bold;color:#a71d5d;">for _ in </span><span style="color:#0086b3;">0</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, rx.</span><span style="color:#62a35c;">recv</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">());
    }
}
</span></pre><p id = "para-1390">Here we create 10 threads, asking each to calculate the square of a number (<code>i</code> at the time of <code>spawn()</code>), and then <code>send()</code> back the answer over the channel.</p>
<h3 id = "link-281">Panics</h3>
<p id = "para-1391">A <code>panic!</code> will crash the currently executing thread. You can use Rust’s threads as a simple isolation mechanism:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::thread;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> handle </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">thread::spawn(</span><span style="font-weight:bold;color:#a71d5d;">move || </span><span style="color:#323232;">{
    panic!(</span><span style="color:#183691;">&quot;oops!&quot;</span><span style="color:#323232;">);
});

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> result </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> handle.</span><span style="color:#62a35c;">join</span><span style="color:#323232;">();

assert!(result.</span><span style="color:#62a35c;">is_err</span><span style="color:#323232;">());
</span></pre><p id = "para-1392"><code>Thread.join()</code> gives us a <code>Result</code> back, which allows us to check if the thread has panicked or not.</p>

</div><div id = "chapter-52" class = "chapter">
  <h2 id = "link-282">Error Handling</h2>
<p id = "para-1393">Like most programming languages, Rust encourages the programmer to handle errors in a particular way. Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values.</p>
<p id = "para-1394">In this section, we intend to provide a comprehensive treatment of how to deal with errors in Rust. More than that, we will attempt to introduce error handling one piece at a time so that you’ll come away with a solid working knowledge of how everything fits together.</p>
<p id = "para-1395">When done naïvely, error handling in Rust can be verbose and annoying. This section will explore those stumbling blocks and demonstrate how to use the standard library to make error handling concise and ergonomic.</p>
<h2 id = "link-283">Table of Contents</h2>
<p id = "para-1396">This section is very long, mostly because we start at the very beginning with sum types and combinators, and try to motivate the way Rust does error handling incrementally. As such, programmers with experience in other expressive type systems may want to jump around.</p>
<ul>
<li><a href = "src/#the-basics">The Basics</a><ul>
<li><a href = "src/#unwrapping-explained">Unwrapping explained</a></li>
<li><a href = "src/#the-option-type">The <code>Option</code> type</a><ul>
<li><a href = "src/#composing-optiont-values">Composing <code>Option&lt;T&gt;</code> values</a></li>
</ul>
</li>
<li><a href = "src/#the-result-type">The <code>Result</code> type</a><ul>
<li><a href = "src/#parsing-integers">Parsing integers</a></li>
<li><a href = "src/#the-result-type-alias-idiom">The <code>Result</code> type alias idiom</a></li>
</ul>
</li>
<li><a href = "src/#a-brief-interlude-unwrapping-isnt-evil">A brief interlude: unwrapping isn’t evil</a></li>
</ul>
</li>
<li><a href = "src/#working-with-multiple-error-types">Working with multiple error types</a><ul>
<li><a href = "src/#composing-option-and-result">Composing <code>Option</code> and <code>Result</code></a></li>
<li><a href = "src/#the-limits-of-combinators">The limits of combinators</a></li>
<li><a href = "src/#early-returns">Early returns</a></li>
<li><a href = "src/#the-try-macro">The <code>try!</code> macro</a></li>
<li><a href = "src/#defining-your-own-error-type">Defining your own error type</a></li>
</ul>
</li>
<li><a href = "src/#standard-library-traits-used-for-error-handling">Standard library traits used for error handling</a><ul>
<li><a href = "src/#the-error-trait">The <code>Error</code> trait</a></li>
<li><a href = "src/#the-from-trait">The <code>From</code> trait</a></li>
<li><a href = "src/#the-real-try-macro">The real <code>try!</code> macro</a></li>
<li><a href = "src/#composing-custom-error-types">Composing custom error types</a></li>
<li><a href = "src/#advice-for-library-writers">Advice for library writers</a></li>
</ul>
</li>
<li><a href = "src/#case-study-a-program-to-read-population-data">Case study: A program to read population data</a><ul>
<li><a href = "src/#initial-setup">Initial setup</a></li>
<li><a href = "src/#argument-parsing">Argument parsing</a></li>
<li><a href = "src/#writing-the-logic">Writing the logic</a></li>
<li><a href = "src/#error-handling-with-boxerror">Error handling with <code>Box&lt;Error&gt;</code></a></li>
<li><a href = "src/#reading-from-stdin">Reading from stdin</a></li>
<li><a href = "src/#error-handling-with-a-custom-type">Error handling with a custom type</a></li>
<li><a href = "src/#adding-functionality">Adding functionality</a></li>
</ul>
</li>
<li><a href = "src/#the-short-story">The short story</a></li>
</ul>
<h2 id = "link-284">The Basics</h2>
<p id = "para-1397">You can think of error handling as using <em>case analysis</em> to determine whether a computation was successful or not. As you will see, the key to ergonomic error handling is reducing the amount of explicit case analysis the programmer has to do while keeping code composable.</p>
<p id = "para-1398">Keeping code composable is important, because without that requirement, we could <a href = "src/../../std/macro.panic.html"><code>panic</code></a> whenever we come across something unexpected. (<code>panic</code> causes the current task to unwind, and in most cases, the entire program aborts.) Here’s an example:</p>
<pre><span style="font-style:italic;color:#969896;">// Guess a number between 1 and 10.
// If it matches the number we had in mind, return `true`. Else, return `false`.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">guess</span><span style="color:#323232;">(n: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> n </span><span style="font-weight:bold;color:#a71d5d;">&lt; </span><span style="color:#0086b3;">1 </span><span style="font-weight:bold;color:#a71d5d;">||</span><span style="color:#323232;"> n </span><span style="font-weight:bold;color:#a71d5d;">&gt; </span><span style="color:#0086b3;">10 </span><span style="color:#323232;">{
        panic!(</span><span style="color:#183691;">&quot;Invalid number: {}&quot;</span><span style="color:#323232;">, n);
    }
    n </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">5
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="color:#62a35c;">guess</span><span style="color:#323232;">(</span><span style="color:#0086b3;">11</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1399">If you try running this code, the program will crash with a message like this:</p>
<pre><span style="color:#323232;">thread &#39;main&#39; panicked at &#39;Invalid number: 11&#39;, src/bin/panic-simple.rs:5
</span></pre><p id = "para-1400">Here’s another example that is slightly less contrived. A program that accepts an integer as an argument, doubles it and prints it.</p>
<p id = "para-1401"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::env;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> argv </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">env::args();
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> arg: </span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> argv.</span><span style="color:#62a35c;">nth</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 1
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> arg.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 2
    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n);
}
</span></pre><p id = "para-1402">If you give this program zero arguments (error 1) or if the first argument isn’t an integer (error 2), the program will panic just like in the first example.</p>
<p id = "para-1403">You can think of this style of error handling as similar to a bull running through a china shop. The bull will get to where it wants to go, but it will trample everything in the process.</p>
<h3 id = "link-285">Unwrapping explained</h3>
<p id = "para-1404">In the previous example, we claimed that the program would simply panic if it reached one of the two error conditions, yet, the program does not include an explicit call to <code>panic</code> like the first example. This is because the panic is embedded in the calls to <code>unwrap</code>.</p>
<p id = "para-1405">To “unwrap” something in Rust is to say, “Give me the result of the computation, and if there was an error, panic and stop the program.” It would be better if we showed the code for unwrapping because it is so simple, but to do that, we will first need to explore the <code>Option</code> and <code>Result</code> types. Both of these types have a method called <code>unwrap</code> defined on them.</p>
<h4 id = "link-286">The <code>Option</code> type</h4>
<p id = "para-1406">The <code>Option</code> type is <a href = "src/../../std/option/enum.Option.html">defined in the standard library</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Option&lt;T&gt; {
    </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(T),
}
</span></pre><p id = "para-1407">The <code>Option</code> type is a way to use Rust’s type system to express the <em>possibility of absence</em>. Encoding the possibility of absence into the type system is an important concept because it will cause the compiler to force the programmer to handle that absence. Let’s take a look at an example that tries to find a character in a string:</p>
<p id = "para-1408"></p>
<pre><span style="font-style:italic;color:#969896;">// Searches `haystack` for the Unicode character `needle`. If one is found, the
// byte offset of the character is returned. Otherwise, `None` is returned.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">find</span><span style="color:#323232;">(haystack: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, needle: </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">(offset, c) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> haystack.</span><span style="color:#62a35c;">char_indices</span><span style="color:#323232;">() {
        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> needle {
            </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(offset);
        }
    }
    </span><span style="color:#0086b3;">None
</span><span style="color:#323232;">}
</span></pre><p id = "para-1409">Notice that when this function finds a matching character, it doesn’t only return the <code>offset</code>. Instead, it returns <code>Some(offset)</code>. <code>Some</code> is a variant or a <em>value constructor</em> for the <code>Option</code> type. You can think of it as a function with the type <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>. Correspondingly, <code>None</code> is also a value constructor, except it has no arguments. You can think of <code>None</code> as a function with the type <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
<p id = "para-1410">This might seem like much ado about nothing, but this is only half of the story. The other half is <em>using</em> the <code>find</code> function we’ve written. Let’s try to use it to find the extension in a file name.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">find</span><span style="color:#323232;">(haystack: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, needle: </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">&gt; { haystack.</span><span style="color:#62a35c;">find</span><span style="color:#323232;">(needle) }
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> file_name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;foobar.rs&quot;</span><span style="color:#323232;">;
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">find</span><span style="color:#323232;">(file_name, </span><span style="color:#183691;">&#39;.&#39;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;No file extension found.&quot;</span><span style="color:#323232;">),
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(i) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;File extension: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">file_name[i</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]),
    }
}
</span></pre><p id = "para-1411">This code uses <a href = "#chapter-22">pattern matching</a> to do <em>case analysis</em> on the <code>Option&lt;usize&gt;</code> returned by the <code>find</code> function. In fact, case analysis is the only way to get at the value stored inside an <code>Option&lt;T&gt;</code>. This means that you, as the programmer, must handle the case when an <code>Option&lt;T&gt;</code> is <code>None</code> instead of <code>Some(t)</code>.</p>
<p id = "para-1412">But wait, what about <code>unwrap</code>, which we used <a href = "src/#code-unwrap-double">previously</a>? There was no case analysis there! Instead, the case analysis was put inside the <code>unwrap</code> method for you. You could define it yourself if you want:</p>
<p id = "para-1413"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Option&lt;T&gt; {
    </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
    </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(T),
}

</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T&gt; Option&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">unwrap</span><span style="color:#323232;">(self) -&gt; T {
        </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#323232;">self {
            </span><span style="color:#0086b3;">Option</span><span style="color:#323232;">::Some(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> val,
            </span><span style="color:#0086b3;">Option</span><span style="color:#323232;">::None </span><span style="font-weight:bold;color:#a71d5d;">=&gt;
              </span><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;called `Option::unwrap()` on a `None` value&quot;</span><span style="color:#323232;">),
        }
    }
}
</span></pre><p id = "para-1414">The <code>unwrap</code> method <em>abstracts away the case analysis</em>. This is precisely the thing that makes <code>unwrap</code> ergonomic to use. Unfortunately, that <code>panic!</code> means that <code>unwrap</code> is not composable: it is the bull in the china shop.</p>
<h4 id = "link-287">Composing <code>Option&lt;T&gt;</code> values</h4>
<p id = "para-1415">In an <a href = "src/#code-option-ex-string-find">example from before</a>, we saw how to use <code>find</code> to discover the extension in a file name. Of course, not all file names have a <code>.</code> in them, so it’s possible that the file name has no extension. This <em>possibility of absence</em> is encoded into the types using <code>Option&lt;T&gt;</code>. In other words, the compiler will force us to address the possibility that an extension does not exist. In our case, we only print out a message saying as such.</p>
<p id = "para-1416">Getting the extension of a file name is a pretty common operation, so it makes sense to put it into a function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">find</span><span style="color:#323232;">(haystack: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, needle: </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">&gt; { haystack.</span><span style="color:#62a35c;">find</span><span style="color:#323232;">(needle) }
</span><span style="font-style:italic;color:#969896;">// Returns the extension of the given file name, where the extension is defined
// as all characters following the first `.`.
// If `file_name` has no `.`, then `None` is returned.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">extension_explicit</span><span style="color:#323232;">(file_name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">find</span><span style="color:#323232;">(file_name, </span><span style="color:#183691;">&#39;.&#39;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(i) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">file_name[i</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]),
    }
}
</span></pre><p id = "para-1417">(Pro-tip: don’t use this code. Use the <a href = "src/../../std/path/struct.Path.html#method.extension"><code>extension</code></a> method in the standard library instead.)</p>
<p id = "para-1418">The code stays simple, but the important thing to notice is that the type of <code>find</code> forces us to consider the possibility of absence. This is a good thing because it means the compiler won’t let us accidentally forget about the case where a file name doesn’t have an extension. On the other hand, doing explicit case analysis like we’ve done in <code>extension_explicit</code> every time can get a bit tiresome.</p>
<p id = "para-1419">In fact, the case analysis in <code>extension_explicit</code> follows a very common pattern: <em>map</em> a function on to the value inside of an <code>Option&lt;T&gt;</code>, unless the option is <code>None</code>, in which case, return <code>None</code>.</p>
<p id = "para-1420">Rust has parametric polymorphism, so it is very easy to define a combinator that abstracts this pattern:</p>
<p id = "para-1421"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">map</span><span style="color:#323232;">&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> F: FnOnce(T) -&gt; A {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> option {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(value) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="color:#62a35c;">f</span><span style="color:#323232;">(value)),
    }
}
</span></pre><p id = "para-1422">Indeed, <code>map</code> is <a href = "src/../../std/option/enum.Option.html#method.map">defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library. As a method, it has a slightly different signature: methods take <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as their first argument.</p>
<p id = "para-1423">Armed with our new combinator, we can rewrite our <code>extension_explicit</code> method to get rid of the case analysis:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">find</span><span style="color:#323232;">(haystack: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, needle: </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">&gt; { haystack.</span><span style="color:#62a35c;">find</span><span style="color:#323232;">(needle) }
</span><span style="font-style:italic;color:#969896;">// Returns the extension of the given file name, where the extension is defined
// as all characters following the first `.`.
// If `file_name` has no `.`, then `None` is returned.
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">extension</span><span style="color:#323232;">(file_name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
    </span><span style="color:#62a35c;">find</span><span style="color:#323232;">(file_name, </span><span style="color:#183691;">&#39;.&#39;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|i| </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">file_name[i</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">])
}
</span></pre><p id = "para-1424">One other pattern we commonly find is assigning a default value to the case when an <code>Option</code> value is <code>None</code>. For example, maybe your program assumes that the extension of a file is <code>rs</code> even if none is present. As you might imagine, the case analysis for this is not specific to file extensions - it can work with any <code>Option&lt;T&gt;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">unwrap_or</span><span style="color:#323232;">&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> option {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> default,
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(value) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> value,
    }
}
</span></pre><p id = "para-1425">Like with <code>map</code> above, the standard library implementation is a method instead of a free function.</p>
<p id = "para-1426">The trick here is that the default value must have the same type as the value that might be inside the <code>Option&lt;T&gt;</code>. Using it is dead simple in our case:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">find</span><span style="color:#323232;">(haystack: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, needle: </span><span style="font-weight:bold;color:#a71d5d;">char</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">usize</span><span style="color:#323232;">&gt; {
</span><span style="font-weight:bold;color:#a71d5d;">#     for </span><span style="color:#323232;">(offset, c) </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> haystack.</span><span style="color:#62a35c;">char_indices</span><span style="color:#323232;">() {
</span><span style="font-weight:bold;color:#a71d5d;">#         if</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> needle {
</span><span style="font-weight:bold;color:#a71d5d;">#             return </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(offset);
</span><span style="font-weight:bold;color:#a71d5d;">#         </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#0086b3;">None
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">#
# fn </span><span style="font-weight:bold;color:#795da3;">extension</span><span style="color:#323232;">(file_name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
</span><span style="font-weight:bold;color:#a71d5d;">#     </span><span style="color:#62a35c;">find</span><span style="color:#323232;">(file_name, </span><span style="color:#183691;">&#39;.&#39;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|i| </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">file_name[i</span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">])
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    assert_eq!(</span><span style="color:#62a35c;">extension</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar.csv&quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">unwrap_or</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;rs&quot;</span><span style="color:#323232;">), </span><span style="color:#183691;">&quot;csv&quot;</span><span style="color:#323232;">);
    assert_eq!(</span><span style="color:#62a35c;">extension</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">unwrap_or</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;rs&quot;</span><span style="color:#323232;">), </span><span style="color:#183691;">&quot;rs&quot;</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1427">(Note that <code>unwrap_or</code> is <a href = "src/../../std/option/enum.Option.html#method.unwrap_or">defined as a method</a> on <code>Option&lt;T&gt;</code> in the standard library, so we use that here instead of the free-standing function we defined above. Don’t forget to check out the more general <a href = "src/../../std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a> method.)</p>
<p id = "para-1428">There is one more combinator that we think is worth paying special attention to: <code>and_then</code>. It makes it easy to compose distinct computations that admit the <em>possibility of absence</em>. For example, much of the code in this section is about finding an extension given a file name. In order to do this, you first need the file name which is typically extracted from a file <em>path</em>. While most file paths have a file name, not <em>all</em> of them do. For example, <code>.</code>, <code>..</code> or <code>/</code>.</p>
<p id = "para-1429">So, we are tasked with the challenge of finding an extension given a file <em>path</em>. Let’s start with explicit case analysis:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">extension</span><span style="color:#323232;">(file_name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; { </span><span style="color:#0086b3;">None </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_path_ext_explicit</span><span style="color:#323232;">(file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">file_name</span><span style="color:#323232;">(file_path) {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(name) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; match </span><span style="color:#62a35c;">extension</span><span style="color:#323232;">(name) {
            </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
            </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(ext) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(ext),
        }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_name</span><span style="color:#323232;">(file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
  </span><span style="font-style:italic;color:#969896;">// Implementation elided.
  </span><span style="color:#323232;">unimplemented!()
}
</span></pre><p id = "para-1430">You might think that we could use the <code>map</code> combinator to reduce the case analysis, but its type doesn’t quite fit...</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_path_ext</span><span style="color:#323232;">(file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
    </span><span style="color:#62a35c;">file_name</span><span style="color:#323232;">(file_path).</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|x| </span><span style="color:#62a35c;">extension</span><span style="color:#323232;">(x)) </span><span style="font-style:italic;color:#969896;">// This causes a compilation error.
</span><span style="color:#323232;">}
</span></pre><p id = "para-1431">The <code>map</code> function here wraps the value returned by the <code>extension</code> function inside an <code>Option&lt;_&gt;</code> and since the <code>extension</code> function itself returns an <code>Option&lt;&amp;str&gt;</code> the expression <code>file_name(file_path).map(|x| extension(x))</code> actually returns an <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>.</p>
<p id = "para-1432">But since <code>file_path_ext</code> just returns <code>Option&lt;&amp;str&gt;</code> (and not <code>Option&lt;Option&lt;&amp;str&gt;&gt;</code>) we get a compilation error.</p>
<p id = "para-1433">The result of the function taken by map as input is <em>always</em> <a href = "src/#code-option-map">rewrapped with <code>Some</code></a>. Instead, we need something like <code>map</code>, but which allows the caller to return a <code>Option&lt;_&gt;</code> directly without wrapping it in another <code>Option&lt;_&gt;</code>.</p>
<p id = "para-1434">Its generic implementation is even simpler than <code>map</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">and_then</span><span style="color:#323232;">&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> F: FnOnce(T) -&gt; Option&lt;A&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> option {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(value) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(value),
    }
}
</span></pre><p id = "para-1435">Now we can rewrite our <code>file_path_ext</code> function without explicit case analysis:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">extension</span><span style="color:#323232;">(file_name: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; { </span><span style="color:#0086b3;">None </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">file_name</span><span style="color:#323232;">(file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; { </span><span style="color:#0086b3;">None </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_path_ext</span><span style="color:#323232;">(file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">&gt; {
    </span><span style="color:#62a35c;">file_name</span><span style="color:#323232;">(file_path).</span><span style="color:#62a35c;">and_then</span><span style="color:#323232;">(extension)
}
</span></pre><p id = "para-1436">Side note: Since <code>and_then</code> essentially works like <code>map</code> but returns an <code>Option&lt;_&gt;</code> instead of an <code>Option&lt;Option&lt;_&gt;&gt;</code> it is known as <code>flatmap</code> in some other languages.</p>
<p id = "para-1437">The <code>Option</code> type has many other combinators <a href = "src/../../std/option/enum.Option.html">defined in the standard library</a>. It is a good idea to skim this list and familiarize yourself with what’s available—they can often reduce case analysis for you. Familiarizing yourself with these combinators will pay dividends because many of them are also defined (with similar semantics) for <code>Result</code>, which we will talk about next.</p>
<p id = "para-1438">Combinators make using types like <code>Option</code> ergonomic because they reduce explicit case analysis. They are also composable because they permit the caller to handle the possibility of absence in their own way. Methods like <code>unwrap</code> remove choices because they will panic if <code>Option&lt;T&gt;</code> is <code>None</code>.</p>
<h3 id = "link-288">The <code>Result</code> type</h3>
<p id = "para-1439">The <code>Result</code> type is also <a href = "src/../../std/result/index.html">defined in the standard library</a>:</p>
<p id = "para-1440"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">Result&lt;T, E&gt; {
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(T),
    </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(E),
}
</span></pre><p id = "para-1441">The <code>Result</code> type is a richer version of <code>Option</code>. Instead of expressing the possibility of <em>absence</em> like <code>Option</code> does, <code>Result</code> expresses the possibility of <em>error</em>. Usually, the <em>error</em> is used to explain why the execution of some computation failed. This is a strictly more general form of <code>Option</code>. Consider the following type alias, which is semantically equivalent to the real <code>Option&lt;T&gt;</code> in every way:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Option</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">T</span><span style="font-weight:bold;color:#a71d5d;">&gt; = </span><span style="color:#323232;">Result&lt;T, ()&gt;;
</span></pre><p id = "para-1442">This fixes the second type parameter of <code>Result</code> to always be <code>()</code> (pronounced “unit” or “empty tuple”). Exactly one value inhabits the <code>()</code> type: <code>()</code>. (Yup, the type and value level terms have the same notation!)</p>
<p id = "para-1443">The <code>Result</code> type is a way of representing one of two possible outcomes in a computation. By convention, one outcome is meant to be expected or “<code>Ok</code>” while the other outcome is meant to be unexpected or “<code>Err</code>”.</p>
<p id = "para-1444">Just like <code>Option</code>, the <code>Result</code> type also has an <a href = "src/../../std/result/enum.Result.html#method.unwrap"><code>unwrap</code> method defined</a> in the standard library. Let’s define it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">Result&lt;T, E&gt; { </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(T), </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(E) }
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">unwrap</span><span style="color:#323232;">(self) -&gt; T {
        </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#323232;">self {
            </span><span style="color:#0086b3;">Result</span><span style="color:#323232;">::Ok(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> val,
            </span><span style="color:#0086b3;">Result</span><span style="color:#323232;">::Err(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;
              </span><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;</span><span style="color:#323232;">, err),
        }
    }
}
</span></pre><p id = "para-1445">This is effectively the same as our <a href = "src/#code-option-def-unwrap">definition for <code>Option::unwrap</code></a>, except it includes the error value in the <code>panic!</code> message. This makes debugging easier, but it also requires us to add a <a href = "src/../../std/fmt/trait.Debug.html"><code>Debug</code></a> constraint on the <code>E</code> type parameter (which represents our error type). Since the vast majority of types should satisfy the <code>Debug</code> constraint, this tends to work out in practice. (<code>Debug</code> on a type simply means that there’s a reasonable way to print a human-readable description of values with that type.)</p>
<p id = "para-1446">OK, let’s move on to an example.</p>
<h4 id = "link-289">Parsing integers</h4>
<p id = "para-1447">The Rust standard library makes converting strings to integers dead simple. It’s so easy in fact, that it is very tempting to write something like the following:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double_number</span><span style="color:#323232;">(number_str: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> number_str.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">()
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#62a35c;">double_number</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;10&quot;</span><span style="color:#323232;">);
    assert_eq!(n, </span><span style="color:#0086b3;">20</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1448">At this point, you should be skeptical of calling <code>unwrap</code>. For example, if the string doesn’t parse as a number, you’ll get a panic:</p>
<pre><span style="color:#323232;">thread &#39;main&#39; panicked at &#39;called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }&#39;, /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</span></pre><p id = "para-1449">This is rather unsightly, and if this happened inside a library you’re using, you might be understandably annoyed. Instead, we should try to handle the error in our function and let the caller decide what to do. This means changing the return type of <code>double_number</code>. But to what? Well, that requires looking at the signature of the <a href = "src/../../std/primitive.str.html#method.parse"><code>parse</code> method</a> in the standard library:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">str {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">parse</span><span style="color:#323232;">&lt;F: FromStr&gt;(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Result&lt;F, </span><span style="font-weight:bold;color:#a71d5d;">F::</span><span style="color:#323232;">Err&gt;;
}
</span></pre><p id = "para-1450">Hmm. So we at least know that we need to use a <code>Result</code>. Certainly, it’s possible that this could have returned an <code>Option</code>. After all, a string either parses as a number or it doesn’t, right? That’s certainly a reasonable way to go, but the implementation internally distinguishes <em>why</em> the string didn’t parse as an integer. (Whether it’s an empty string, an invalid digit, too big or too small.) Therefore, using a <code>Result</code> makes sense because we want to provide more information than simply “absence.” We want to say <em>why</em> the parsing failed. You should try to emulate this line of reasoning when faced with a choice between <code>Option</code> and <code>Result</code>. If you can provide detailed error information, then you probably should. (We’ll see more on this later.)</p>
<p id = "para-1451">OK, but how do we write our return type? The <code>parse</code> method as defined above is generic over all the different number types defined in the standard library. We could (and probably should) also make our function generic, but let’s favor explicitness for the moment. We only care about <code>i32</code>, so we need to <a href = "src/../../std/primitive.i32.html">find its implementation of <code>FromStr</code></a> (do a <code>CTRL-F</code> in your browser for “FromStr”) and look at its <a href = "#chapter-37">associated type</a> <code>Err</code>. We did this so we can find the concrete error type. In this case, it’s <a href = "src/../../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>. Finally, we can rewrite our function:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num::ParseIntError;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double_number</span><span style="color:#323232;">(number_str: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, ParseIntError&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> number_str.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;() {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err),
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">double_number</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;10&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">assert_eq!(n, </span><span style="color:#0086b3;">20</span><span style="color:#323232;">),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1452">This is a little better, but now we’ve written much more code! The case analysis has once again bitten us.</p>
<p id = "para-1453">Combinators to the rescue! Just like <code>Option</code>, <code>Result</code> has lots of combinators defined as methods. There is a large intersection of common combinators between <code>Result</code> and <code>Option</code>. In particular, <code>map</code> is part of that intersection:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num::ParseIntError;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double_number</span><span style="color:#323232;">(number_str: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, ParseIntError&gt; {
    number_str.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|n| </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">double_number</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;10&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">assert_eq!(n, </span><span style="color:#0086b3;">20</span><span style="color:#323232;">),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1454">The usual suspects are all there for <code>Result</code>, including <a href = "src/../../std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> and <a href = "src/../../std/result/enum.Result.html#method.and_then"><code>and_then</code></a>. Additionally, since <code>Result</code> has a second type parameter, there are combinators that affect only the error type, such as <a href = "src/../../std/result/enum.Result.html#method.map_err"><code>map_err</code></a> (instead of <code>map</code>) and <a href = "src/../../std/result/enum.Result.html#method.or_else"><code>or_else</code></a> (instead of <code>and_then</code>).</p>
<h4 id = "link-290">The <code>Result</code> type alias idiom</h4>
<p id = "para-1455">In the standard library, you may frequently see types like <code>Result&lt;i32&gt;</code>. But wait, <a href = "src/#code-result-def">we defined <code>Result</code></a> to have two type parameters. How can we get away with only specifying one? The key is to define a <code>Result</code> type alias that <em>fixes</em> one of the type parameters to a particular type. Usually the fixed type is the error type. For example, our previous example parsing integers could be rewritten like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num::ParseIntError;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::result;

</span><span style="font-weight:bold;color:#a71d5d;">type </span><span style="color:#323232;">Result</span><span style="font-weight:bold;color:#a71d5d;">&lt;</span><span style="color:#323232;">T</span><span style="font-weight:bold;color:#a71d5d;">&gt; = </span><span style="color:#323232;">result::Result&lt;T, ParseIntError&gt;;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double_number</span><span style="color:#323232;">(number_str: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; {
    unimplemented!();
}
</span></pre><p id = "para-1456">Why would we do this? Well, if we have a lot of functions that could return <code>ParseIntError</code>, then it’s much more convenient to define an alias that always uses <code>ParseIntError</code> so that we don’t have to write it out all the time.</p>
<p id = "para-1457">The most prominent place this idiom is used in the standard library is with <a href = "src/../../std/io/type.Result.html"><code>io::Result</code></a>. Typically, one writes <code>io::Result&lt;T&gt;</code>, which makes it clear that you’re using the <code>io</code> module’s type alias instead of the plain definition from <code>std::result</code>. (This idiom is also used for <a href = "src/../../std/fmt/type.Result.html"><code>fmt::Result</code></a>.)</p>
<h3 id = "link-291">A brief interlude: unwrapping isn’t evil</h3>
<p id = "para-1458">If you’ve been following along, you might have noticed that I’ve taken a pretty hard line against calling methods like <code>unwrap</code> that could <code>panic</code> and abort your program. <em>Generally speaking</em>, this is good advice.</p>
<p id = "para-1459">However, <code>unwrap</code> can still be used judiciously. What exactly justifies use of <code>unwrap</code> is somewhat of a grey area and reasonable people can disagree. I’ll summarize some of my <em>opinions</em> on the matter.</p>
<ul>
<li><b>In examples and quick ‘n’ dirty code.</b> Sometimes you’re writing examples or a quick program, and error handling simply isn’t important. Beating the convenience of <code>unwrap</code> can be hard in such scenarios, so it is very appealing.</li>
<li><b>When panicking indicates a bug in the program.</b> When the invariants of your code should prevent a certain case from happening (like, say, popping from an empty stack), then panicking can be permissible. This is because it exposes a bug in your program. This can be explicit, like from an <code>assert!</code> failing, or it could be because your index into an array was out of bounds.</li>
</ul>
<p id = "para-1460">This is probably not an exhaustive list. Moreover, when using an <code>Option</code>, it is often better to use its <a href = "src/../../std/option/enum.Option.html#method.expect"><code>expect</code></a> method. <code>expect</code> does exactly the same thing as <code>unwrap</code>, except it prints a message you give to <code>expect</code>. This makes the resulting panic a bit nicer to deal with, since it will show your message instead of “called unwrap on a <code>None</code> value.”</p>
<p id = "para-1461">My advice boils down to this: use good judgment. There’s a reason why the words “never do X” or “Y is considered harmful” don’t appear in my writing. There are trade-offs to all things, and it is up to you as the programmer to determine what is acceptable for your use cases. My goal is only to help you evaluate trade-offs as accurately as possible.</p>
<p id = "para-1462">Now that we’ve covered the basics of error handling in Rust, and explained unwrapping, let’s start exploring more of the standard library.</p>
<h2 id = "link-292">Working with multiple error types</h2>
<p id = "para-1463">Thus far, we’ve looked at error handling where everything was either an <code>Option&lt;T&gt;</code> or a <code>Result&lt;T, SomeError&gt;</code>. But what happens when you have both an <code>Option</code> and a <code>Result</code>? Or what if you have a <code>Result&lt;T, Error1&gt;</code> and a <code>Result&lt;T, Error2&gt;</code>? Handling <em>composition of distinct error types</em> is the next challenge in front of us, and it will be the major theme throughout the rest of this section.</p>
<h3 id = "link-293">Composing <code>Option</code> and <code>Result</code></h3>
<p id = "para-1464">So far, I’ve talked about combinators defined for <code>Option</code> and combinators defined for <code>Result</code>. We can use these combinators to compose results of different computations without doing explicit case analysis.</p>
<p id = "para-1465">Of course, in real code, things aren’t always as clean. Sometimes you have a mix of <code>Option</code> and <code>Result</code> types. Must we resort to explicit case analysis, or can we continue using combinators?</p>
<p id = "para-1466">For now, let’s revisit one of the first examples in this section:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::env;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> argv </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">env::args();
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> arg: </span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> argv.</span><span style="color:#62a35c;">nth</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 1
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> arg.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 2
    </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n);
}
</span></pre><p id = "para-1467">Given our new found knowledge of <code>Option</code>, <code>Result</code> and their various combinators, we should try to rewrite this so that errors are handled properly and the program doesn’t panic if there’s an error.</p>
<p id = "para-1468">The tricky aspect here is that <code>argv.nth(1)</code> produces an <code>Option</code> while <code>arg.parse()</code> produces a <code>Result</code>. These aren’t directly composable. When faced with both an <code>Option</code> and a <code>Result</code>, the solution is <em>usually</em> to convert the <code>Option</code> to a <code>Result</code>. In our case, the absence of a command line parameter (from <code>env::args()</code>) means the user didn’t invoke the program correctly. We could use a <code>String</code> to describe the error. Let’s try:</p>
<p id = "para-1469"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::env;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">double_arg</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">argv: env::Args) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, String&gt; {
    argv.</span><span style="color:#62a35c;">nth</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">)
        .</span><span style="color:#62a35c;">ok_or</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Please give at least one argument&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_owned</span><span style="color:#323232;">())
        .</span><span style="color:#62a35c;">and_then</span><span style="color:#323232;">(|arg| arg.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|err| err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()))
        .</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|n| </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">double_arg</span><span style="color:#323232;">(env::args()) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1470">There are a couple new things in this example. The first is the use of the <a href = "src/../../std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a> combinator. This is one way to convert an <code>Option</code> into a <code>Result</code>. The conversion requires you to specify what error to use if <code>Option</code> is <code>None</code>. Like the other combinators we’ve seen, its definition is very simple:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">ok_or</span><span style="color:#323232;">&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> option {
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(val),
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err),
    }
}
</span></pre><p id = "para-1471">The other new combinator used here is <a href = "src/../../std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>. This is like <code>Result::map</code>, except it maps a function on to the <em>error</em> portion of a <code>Result</code> value. If the <code>Result</code> is an <code>Ok(...)</code> value, then it is returned unmodified.</p>
<p id = "para-1472">We use <code>map_err</code> here because it is necessary for the error types to remain the same (because of our use of <code>and_then</code>). Since we chose to convert the <code>Option&lt;String&gt;</code> (from <code>argv.nth(1)</code>) to a <code>Result&lt;String, String&gt;</code>, we must also convert the <code>ParseIntError</code> from <code>arg.parse()</code> to a <code>String</code>.</p>
<h3 id = "link-294">The limits of combinators</h3>
<p id = "para-1473">Doing IO and parsing input is a very common task, and it’s one that I personally have done a lot of in Rust. Therefore, we will use (and continue to use) IO and various parsing routines to exemplify error handling.</p>
<p id = "para-1474">Let’s start simple. We are tasked with opening a file, reading all of its contents and converting its contents to a number. Then we multiply it by <code>2</code> and print the output.</p>
<p id = "para-1475">Although I’ve tried to convince you not to use <code>unwrap</code>, it can be useful to first write your code using <code>unwrap</code>. It allows you to focus on your problem instead of the error handling, and it exposes the points where proper error handling need to occur. Let’s start there so we can get a handle on the code, and then refactor it to use better error handling.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">File::open(file_path).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 1
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 2
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 =</span><span style="color:#323232;"> contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// error 3
    </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> doubled </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">file_double</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">);
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, doubled);
}
</span></pre><p id = "para-1476">(N.B. The <code>AsRef&lt;Path&gt;</code> is used because those are the <a href = "src/../../std/fs/struct.File.html#method.open">same bounds used on <code>std::fs::File::open</code></a>. This makes it ergonomic to use any kind of string as a file path.)</p>
<p id = "para-1477">There are three different errors that can occur here:</p>
<ol>
<li>A problem opening the file.</li>
<li>A problem reading data from the file.</li>
<li>A problem parsing the data as a number.</li>
</ol>
<p id = "para-1478">The first two problems are described via the <a href = "src/../../std/io/struct.Error.html"><code>std::io::Error</code></a> type. We know this because of the return types of <a href = "src/../../std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> and <a href = "src/../../std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>. (Note that they both use the <a href = "src/#the-result-type-alias-idiom"><code>Result</code> type alias idiom</a> described previously. If you click on the <code>Result</code> type, you’ll <a href = "src/../../std/io/type.Result.html">see the type alias</a>, and consequently, the underlying <code>io::Error</code> type.) The third problem is described by the <a href = "src/../../std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a> type. The <code>io::Error</code> type in particular is <em>pervasive</em> throughout the standard library. You will see it again and again.</p>
<p id = "para-1479">Let’s start the process of refactoring the <code>file_double</code> function. To make this function composable with other components of the program, it should <em>not</em> panic if any of the above error conditions are met. Effectively, this means that the function should <em>return an error</em> if any of its operations fail. Our problem is that the return type of <code>file_double</code> is <code>i32</code>, which does not give us any useful way of reporting an error. Thus, we must start by changing the return type from <code>i32</code> to something else.</p>
<p id = "para-1480">The first thing we need to decide: should we use <code>Option</code> or <code>Result</code>? We certainly could use <code>Option</code> very easily. If any of the three errors occur, we could simply return <code>None</code>. This will work <em>and it is better than panicking</em>, but we can do much better. Instead, we should pass some detail about the error that occurred. Since we want to express the <em>possibility of error</em>, we should use <code>Result&lt;i32, E&gt;</code>. But what should <code>E</code> be? Since two <em>different</em> types of errors can occur, we need to convert them to a common type. One such type is <code>String</code>. Let’s see how that impacts our code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, String&gt; {
    File::open(file_path)
         .</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|err| err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">())
         .</span><span style="color:#62a35c;">and_then</span><span style="color:#323232;">(|</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">file| {
              </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
              file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents)
                  .</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|err| err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">())
                  .</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|_| contents)
         })
         .</span><span style="color:#62a35c;">and_then</span><span style="color:#323232;">(|contents| {
              contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;()
                      .</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|err| err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">())
         })
         .</span><span style="color:#62a35c;">map</span><span style="color:#323232;">(|n| </span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">file_double</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1481">This code looks a bit hairy. It can take quite a bit of practice before code like this becomes easy to write. The way we write it is by <em>following the types</em>. As soon as we changed the return type of <code>file_double</code> to <code>Result&lt;i32, String&gt;</code>, we had to start looking for the right combinators. In this case, we only used three different combinators: <code>and_then</code>, <code>map</code> and <code>map_err</code>.</p>
<p id = "para-1482"><code>and_then</code> is used to chain multiple computations where each computation could return an error. After opening the file, there are two more computations that could fail: reading from the file and parsing the contents as a number. Correspondingly, there are two calls to <code>and_then</code>.</p>
<p id = "para-1483"><code>map</code> is used to apply a function to the <code>Ok(...)</code> value of a <code>Result</code>. For example, the very last call to <code>map</code> multiplies the <code>Ok(...)</code> value (which is an <code>i32</code>) by <code>2</code>. If an error had occurred before that point, this operation would have been skipped because of how <code>map</code> is defined.</p>
<p id = "para-1484"><code>map_err</code> is the trick that makes all of this work. <code>map_err</code> is like <code>map</code>, except it applies a function to the <code>Err(...)</code> value of a <code>Result</code>. In this case, we want to convert all of our errors to one type: <code>String</code>. Since both <code>io::Error</code> and <code>num::ParseIntError</code> implement <code>ToString</code>, we can call the <code>to_string()</code> method to convert them.</p>
<p id = "para-1485">With all of that said, the code is still hairy. Mastering use of combinators is important, but they have their limits. Let’s try a different approach: early returns.</p>
<h3 id = "link-295">Early returns</h3>
<p id = "para-1486">I’d like to take the code from the previous section and rewrite it using <em>early returns</em>. Early returns let you exit the function early. We can’t return early in <code>file_double</code> from inside another closure, so we’ll need to revert back to explicit case analysis.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, String&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= match </span><span style="color:#323232;">File::open(file_path) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(file) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> file,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()),
    };
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    </span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents) {
        </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">());
    }
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 = match</span><span style="color:#323232;"> contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">() {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> n,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()),
    };
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">file_double</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1487">Reasonable people can disagree over whether this code is better than the code that uses combinators, but if you aren’t familiar with the combinator approach, this code looks simpler to read to me. It uses explicit case analysis with <code>match</code> and <code>if let</code>. If an error occurs, it simply stops executing the function and returns the error (by converting it to string).</p>
<p id = "para-1488">Isn’t this a step backwards though? Previously, we said that the key to ergonomic error handling is reducing explicit case analysis, yet we’ve reverted back to explicit case analysis here. It turns out, there are <em>multiple</em> ways to reduce explicit case analysis. Combinators aren’t the only way.</p>
<h3 id = "link-296">The <code>try!</code> macro</h3>
<p id = "para-1489">A cornerstone of error handling in Rust is the <code>try!</code> macro. The <code>try!</code> macro abstracts case analysis like combinators, but unlike combinators, it also abstracts <em>control flow</em>. Namely, it can abstract the <em>early return</em> pattern seen above.</p>
<p id = "para-1490">Here is a simplified definition of a <code>try!</code> macro:</p>
<p id = "para-1491"></p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">try {
    ($e:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#323232;">$e {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> val,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err),
    });
}
</span></pre><p id = "para-1492">(The <a href = "src/../../std/macro.try.html">real definition</a> is a bit more sophisticated. We will address that later.)</p>
<p id = "para-1493">Using the <code>try!</code> macro makes it very easy to simplify our last example. Since it does the case analysis and the early return for us, we get tighter code that is easier to read:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, String&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">file_double</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1494">The <code>map_err</code> calls are still necessary given <a href = "src/#code-try-def-simple">our definition of <code>try!</code></a>. This is because the error types still need to be converted to <code>String</code>. The good news is that we will soon learn how to remove those <code>map_err</code> calls! The bad news is that we will need to learn a bit more about a couple important traits in the standard library before we can remove the <code>map_err</code> calls.</p>
<h3 id = "link-297">Defining your own error type</h3>
<p id = "para-1495">Before we dive into some of the standard library error traits, I’d like to wrap up this section by removing the use of <code>String</code> as our error type in the previous examples.</p>
<p id = "para-1496">Using <code>String</code> as we did in our previous examples is convenient because it’s easy to convert errors to strings, or even make up your own errors as strings on the spot. However, using <code>String</code> for your errors has some downsides.</p>
<p id = "para-1497">The first downside is that the error messages tend to clutter your code. It’s possible to define the error messages elsewhere, but unless you’re unusually disciplined, it is very tempting to embed the error message into your code. Indeed, we did exactly this in a <a href = "src/#code-error-double-string">previous example</a>.</p>
<p id = "para-1498">The second and more important downside is that <code>String</code>s are <em>lossy</em>. That is, if all errors are converted to strings, then the errors we pass to the caller become completely opaque. The only reasonable thing the caller can do with a <code>String</code> error is show it to the user. Certainly, inspecting the string to determine the type of error is not robust. (Admittedly, this downside is far more important inside of a library as opposed to, say, an application.)</p>
<p id = "para-1499">For example, the <code>io::Error</code> type embeds an <a href = "src/../../std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>, which is <em>structured data</em> that represents what went wrong during an IO operation. This is important because you might want to react differently depending on the error. (e.g., A <code>BrokenPipe</code> error might mean quitting your program gracefully while a <code>NotFound</code> error might mean exiting with an error code and showing an error to the user.) With <code>io::ErrorKind</code>, the caller can examine the type of an error with case analysis, which is strictly superior to trying to tease out the details of an error inside of a <code>String</code>.</p>
<p id = "para-1500">Instead of using a <code>String</code> as an error type in our previous example of reading an integer from a file, we can define our own error type that represents errors with <em>structured data</em>. We endeavor to not drop information from underlying errors in case the caller wants to inspect the details.</p>
<p id = "para-1501">The ideal way to represent <em>one of many possibilities</em> is to define our own sum type using <code>enum</code>. In our case, an error is either an <code>io::Error</code> or a <code>num::ParseIntError</code>, so a natural definition arises:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-style:italic;color:#969896;">// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human-readable description of `CliError` values.
</span><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</span></pre><p id = "para-1502">Tweaking our code is very easy. Instead of converting errors to strings, we simply convert them to our <code>CliError</code> type using the corresponding value constructor:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, CliError&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Io));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Io));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Parse));
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">file_double</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;foobar&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(n) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, n),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;Error: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
    }
}
</span></pre><p id = "para-1503">The only change here is switching <code>map_err(|e| e.to_string())</code> (which converts errors to strings) to <code>map_err(CliError::Io)</code> or <code>map_err(CliError::Parse)</code>. The <em>caller</em> gets to decide the level of detail to report to the user. In effect, using a <code>String</code> as an error type removes choices from the caller while using a custom <code>enum</code> error type like <code>CliError</code> gives the caller all of the conveniences as before in addition to <em>structured data</em> describing the error.</p>
<p id = "para-1504">A rule of thumb is to define your own error type, but a <code>String</code> error type will do in a pinch, particularly if you’re writing an application. If you’re writing a library, defining your own error type should be strongly preferred so that you don’t remove choices from the caller unnecessarily.</p>
<h2 id = "link-298">Standard library traits used for error handling</h2>
<p id = "para-1505">The standard library defines two integral traits for error handling: <a href = "src/../../std/error/trait.Error.html"><code>std::error::Error</code></a> and <a href = "src/../../std/convert/trait.From.html"><code>std::convert::From</code></a>. While <code>Error</code> is designed specifically for generically describing errors, the <code>From</code> trait serves a more general role for converting values between two distinct types.</p>
<h3 id = "link-299">The <code>Error</code> trait</h3>
<p id = "para-1506">The <code>Error</code> trait is <a href = "src/../../std/error/trait.Error.html">defined in the standard library</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::{Debug, Display};

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">Error: Debug + Display {
  </span><span style="font-style:italic;color:#969896;">/// The lower level cause of this error, if any.
  </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">cause</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Error&gt; { </span><span style="color:#0086b3;">None </span><span style="color:#323232;">}
}
</span></pre><p id = "para-1507">This trait is super generic because it is meant to be implemented for <em>all</em> types that represent errors. This will prove useful for writing composable code as we’ll see later. Otherwise, the trait allows you to do at least the following things:</p>
<ul>
<li>Obtain a <code>Debug</code> representation of the error.</li>
<li>Obtain a user-facing <code>Display</code> representation of the error.</li>
<li>Inspect the causal chain of an error, if one exists (via the <code>cause</code> method).</li>
</ul>
<p id = "para-1508">The first two are a result of <code>Error</code> requiring impls for both <code>Debug</code> and <code>Display</code>. The latter two are from the two methods defined on <code>Error</code>. The power of <code>Error</code> comes from the fact that all error types impl <code>Error</code>, which means errors can be existentially quantified as a <a href = "#chapter-29">trait object</a>. This manifests as either <code>Box&lt;Error&gt;</code> or <code>&amp;Error</code>. Indeed, the <code>cause</code> method returns an <code>&amp;Error</code>, which is itself a trait object. We’ll revisit the <code>Error</code> trait’s utility as a trait object later.</p>
<p id = "para-1509">For now, it suffices to show an example implementing the <code>Error</code> trait. Let’s use the error type we defined in the <a href = "src/#defining-your-own-error-type">previous section</a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-style:italic;color:#969896;">// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human-readable description of `CliError` values.
</span><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
</span></pre><p id = "para-1510">This particular error type represents the possibility of two types of errors occurring: an error dealing with I/O or an error converting a string to a number. The error could represent as many error types as you want by adding new variants to the <code>enum</code> definition.</p>
<p id = "para-1511">Implementing <code>Error</code> is pretty straight-forward. It’s mostly going to be a lot explicit case analysis.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::error;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">fmt::Display </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">fmt</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">fmt::Formatter) -&gt; fmt::Result {
        </span><span style="font-weight:bold;color:#a71d5d;">match *</span><span style="color:#323232;">self {
            </span><span style="font-style:italic;color:#969896;">// Both underlying errors already impl `Display`, so we defer to
            // their implementations.
            </span><span style="color:#323232;">CliError::Io(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">write!(f, </span><span style="color:#183691;">&quot;IO error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
            CliError::Parse(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">write!(f, </span><span style="color:#183691;">&quot;Parse error: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err),
        }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">error::Error </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">cause</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">error::Error&gt; {
        </span><span style="font-weight:bold;color:#a71d5d;">match *</span><span style="color:#323232;">self {
            </span><span style="font-style:italic;color:#969896;">// N.B. Both of these implicitly cast `err` from their concrete
            // types (either `&amp;io::Error` or `&amp;num::ParseIntError`)
            // to a trait object `&amp;Error`. This works because both error types
            // implement `Error`.
            </span><span style="color:#323232;">CliError::Io(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(err),
            CliError::Parse(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(err),
        }
    }
}
</span></pre><p id = "para-1512">We note that this is a very typical implementation of <code>Error</code>: match on your different error types and satisfy the contracts defined for <code>cause</code>.</p>
<h3 id = "link-300">The <code>From</code> trait</h3>
<p id = "para-1513">The <code>std::convert::From</code> trait is <a href = "src/../../std/convert/trait.From.html">defined in the standard library</a>:</p>
<p id = "para-1514"></p>
<pre><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">From&lt;T&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(T) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">Self</span><span style="color:#323232;">;
}
</span></pre><p id = "para-1515">Deliciously simple, yes? <code>From</code> is very useful because it gives us a generic way to talk about conversion <em>from</em> a particular type <code>T</code> to some other type (in this case, “some other type” is the subject of the impl, or <code>Self</code>). The crux of <code>From</code> is the <a href = "src/../../std/convert/trait.From.html">set of implementations provided by the standard library</a>.</p>
<p id = "para-1516">Here are a few simple examples demonstrating how <code>From</code> works:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> string: </span><span style="color:#0086b3;">String </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> bytes: Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> cow: ::std::borrow::Cow&lt;</span><span style="font-weight:bold;color:#a71d5d;">str</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;foo&quot;</span><span style="color:#323232;">);
</span></pre><p id = "para-1517">OK, so <code>From</code> is useful for converting between strings. But what about errors? It turns out, there is one critical impl:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">, E: Error </span><span style="font-weight:bold;color:#a71d5d;">+ &#39;a</span><span style="color:#323232;">&gt; From&lt;E&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Box&lt;Error </span><span style="font-weight:bold;color:#a71d5d;">+ &#39;a</span><span style="color:#323232;">&gt;
</span></pre><p id = "para-1518">This impl says that for <em>any</em> type that impls <code>Error</code>, we can convert it to a trait object <code>Box&lt;Error&gt;</code>. This may not seem terribly surprising, but it is useful in a generic context.</p>
<p id = "para-1519">Remember the two errors we were dealing with previously? Specifically, <code>io::Error</code> and <code>num::ParseIntError</code>. Since both impl <code>Error</code>, they work with <code>From</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::error::Error;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-style:italic;color:#969896;">// We have to jump through some hoops to actually get error values:
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> io_err: io::Error </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">io::Error::last_os_error();
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> parse_err: num::ParseIntError </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;not a number&quot;</span><span style="color:#323232;">.parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">unwrap_err</span><span style="color:#323232;">();

</span><span style="font-style:italic;color:#969896;">// OK, here are the conversions:
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> err1: Box&lt;Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(io_err);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> err2: Box&lt;Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(parse_err);
</span></pre><p id = "para-1520">There is a really important pattern to recognize here. Both <code>err1</code> and <code>err2</code> have the <em>same type</em>. This is because they are existentially quantified types, or trait objects. In particular, their underlying type is <em>erased</em> from the compiler’s knowledge, so it truly sees <code>err1</code> and <code>err2</code> as exactly the same. Additionally, we constructed <code>err1</code> and <code>err2</code> using precisely the same function call: <code>From::from</code>. This is because <code>From::from</code> is overloaded on both its argument and its return type.</p>
<p id = "para-1521">This pattern is important because it solves a problem we had earlier: it gives us a way to reliably convert errors to the same type using the same function.</p>
<p id = "para-1522">Time to revisit an old friend; the <code>try!</code> macro.</p>
<h3 id = "link-301">The real <code>try!</code> macro</h3>
<p id = "para-1523">Previously, we presented this definition of <code>try!</code>:</p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">try {
    ($e:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#323232;">$e {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> val,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err),
    });
}
</span></pre><p id = "para-1524">This is not its real definition. Its real definition is <a href = "src/../../std/macro.try.html">in the standard library</a>:</p>
<p id = "para-1525"></p>
<pre><span style="color:#62a35c;">macro_rules! </span><span style="color:#323232;">try {
    ($e:</span><span style="font-weight:bold;color:#a71d5d;">expr</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#323232;">$e {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(val) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> val,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; return </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(::std::convert::From::from(err)),
    });
}
</span></pre><p id = "para-1526">There’s one tiny but powerful change: the error value is passed through <code>From::from</code>. This makes the <code>try!</code> macro much more powerful because it gives you automatic type conversion for free.</p>
<p id = "para-1527">Armed with our more powerful <code>try!</code> macro, let’s take a look at code we wrote previously to read a file and convert its contents to an integer:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, String&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;().</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(|e| e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()));
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}
</span></pre><p id = "para-1528">Earlier, we promised that we could get rid of the <code>map_err</code> calls. Indeed, all we have to do is pick a type that <code>From</code> works with. As we saw in the previous section, <code>From</code> has an impl that lets it convert any error type into a <code>Box&lt;Error&gt;</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::error::Error;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, Box&lt;Error&gt;&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().parse::&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt;());
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}
</span></pre><p id = "para-1529">We are getting very close to ideal error handling. Our code has very little overhead as a result from error handling because the <code>try!</code> macro encapsulates three things simultaneously:</p>
<ol>
<li>Case analysis.</li>
<li>Control flow.</li>
<li>Error type conversion.</li>
</ol>
<p id = "para-1530">When all three things are combined, we get code that is unencumbered by combinators, calls to <code>unwrap</code> or case analysis.</p>
<p id = "para-1531">There’s one little nit left: the <code>Box&lt;Error&gt;</code> type is <em>opaque</em>. If we return a <code>Box&lt;Error&gt;</code> to the caller, the caller can’t (easily) inspect underlying error type. The situation is certainly better than <code>String</code> because the caller can call methods like <a href = "src/../../std/error/trait.Error.html#method.cause"><code>cause</code></a>, but the limitation remains: <code>Box&lt;Error&gt;</code> is opaque. (N.B. This isn’t entirely true because Rust does have runtime reflection, which is useful in some scenarios that are <a href = "https://crates.io/crates/error">beyond the scope of this section</a>.)</p>
<p id = "para-1532">It’s time to revisit our custom <code>CliError</code> type and tie everything together.</p>
<h3 id = "link-302">Composing custom error types</h3>
<p id = "para-1533">In the last section, we looked at the real <code>try!</code> macro and how it does automatic type conversion for us by calling <code>From::from</code> on the error value. In particular, we converted errors to <code>Box&lt;Error&gt;</code>, which works, but the type is opaque to callers.</p>
<p id = "para-1534">To fix this, we use the same remedy that we’re already familiar with: a custom error type. Once again, here is the code that reads the contents of a file and converts it to an integer:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::{self, Read};
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-style:italic;color:#969896;">// We derive `Debug` because all types should probably derive `Debug`.
// This gives us a reasonable human-readable description of `CliError` values.
</span><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double_verbose</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, CliError&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Io));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents).</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Io));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">map_err</span><span style="color:#323232;">(CliError::Parse));
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}
</span></pre><p id = "para-1535">Notice that we still have the calls to <code>map_err</code>. Why? Well, recall the definitions of <a href = "src/#code-try-def"><code>try!</code></a> and <a href = "src/#code-from-def"><code>From</code></a>. The problem is that there is no <code>From</code> impl that allows us to convert from error types like <code>io::Error</code> and <code>num::ParseIntError</code> to our own custom <code>CliError</code>. Of course, it is easy to fix this! Since we defined <code>CliError</code>, we can impl <code>From</code> with it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">CliError { Io(io::Error), Parse(num::ParseIntError) }
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">From&lt;io::Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">From&lt;num::ParseIntError&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
</span></pre><p id = "para-1536">All these impls are doing is teaching <code>From</code> how to create a <code>CliError</code> from other error types. In our case, construction is as simple as invoking the corresponding value constructor. Indeed, it is <em>typically</em> this easy.</p>
<p id = "para-1537">We can finally rewrite <code>file_double</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">std::num;
</span><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">From&lt;io::Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: io::Error) -&gt; CliError { CliError::Io(err) }
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># impl </span><span style="color:#323232;">From&lt;num::ParseIntError&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
</span><span style="font-weight:bold;color:#a71d5d;">#     fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io::Read;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">file_double</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, CliError&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> contents </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">String</span><span style="color:#323232;">::new();
    try!(file.</span><span style="color:#62a35c;">read_to_string</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> contents));
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> n: </span><span style="font-weight:bold;color:#a71d5d;">i32 = </span><span style="color:#323232;">try!(contents.</span><span style="color:#62a35c;">trim</span><span style="color:#323232;">().</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">());
    </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2 </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> n)
}
</span></pre><p id = "para-1538">The only thing we did here was remove the calls to <code>map_err</code>. They are no longer needed because the <code>try!</code> macro invokes <code>From::from</code> on the error value. This works because we’ve provided <code>From</code> impls for all the error types that could appear.</p>
<p id = "para-1539">If we modified our <code>file_double</code> function to perform some other operation, say, convert a string to a float, then we’d need to add a new variant to our error type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
</span></pre><p id = "para-1540">And add a new <code>From</code> impl:</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># enum </span><span style="color:#323232;">CliError {
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">     Io(::std::io::Error),
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">     ParseInt(num::ParseIntError),
</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">     ParseFloat(num::ParseFloatError),
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::num;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">From&lt;num::ParseFloatError&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
</span></pre><p id = "para-1541">And that’s it!</p>
<h3 id = "link-303">Advice for library writers</h3>
<p id = "para-1542">If your library needs to report custom errors, then you should probably define your own error type. It’s up to you whether or not to expose its representation (like <a href = "src/../../std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>) or keep it hidden (like <a href = "src/../../std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>). Regardless of how you do it, it’s usually good practice to at least provide some information about the error beyond its <code>String</code> representation. But certainly, this will vary depending on use cases.</p>
<p id = "para-1543">At a minimum, you should probably implement the <a href = "src/../../std/error/trait.Error.html"><code>Error</code></a> trait. This will give users of your library some minimum flexibility for <a href = "src/#the-real-try-macro">composing errors</a>. Implementing the <code>Error</code> trait also means that users are guaranteed the ability to obtain a string representation of an error (because it requires impls for both <code>fmt::Debug</code> and <code>fmt::Display</code>).</p>
<p id = "para-1544">Beyond that, it can also be useful to provide implementations of <code>From</code> on your error types. This allows you (the library author) and your users to <a href = "src/#composing-custom-error-types">compose more detailed errors</a>. For example, <a href = "http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> provides <code>From</code> impls for both <code>io::Error</code> and <code>byteorder::Error</code>.</p>
<p id = "para-1545">Finally, depending on your tastes, you may also want to define a <a href = "src/#the-result-type-alias-idiom"><code>Result</code> type alias</a>, particularly if your library defines a single error type. This is used in the standard library for <a href = "src/../../std/io/type.Result.html"><code>io::Result</code></a> and <a href = "src/../../std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>
<h2 id = "link-304">Case study: A program to read population data</h2>
<p id = "para-1546">This section was long, and depending on your background, it might be rather dense. While there is plenty of example code to go along with the prose, most of it was specifically designed to be pedagogical. So, we’re going to do something new: a case study.</p>
<p id = "para-1547">For this, we’re going to build up a command line program that lets you query world population data. The objective is simple: you give it a location and it will tell you the population. Despite the simplicity, there is a lot that can go wrong!</p>
<p id = "para-1548">The data we’ll be using comes from the <a href = "https://github.com/petewarden/dstkdata">Data Science Toolkit</a>. I’ve prepared some data from it for this exercise. You can either grab the <a href = "http://burntsushi.net/stuff/worldcitiespop.csv.gz">world population data</a> (41MB gzip compressed, 145MB uncompressed) or only the <a href = "http://burntsushi.net/stuff/uscitiespop.csv.gz">US population data</a> (2.2MB gzip compressed, 7.2MB uncompressed).</p>
<p id = "para-1549">Up until now, we’ve kept the code limited to Rust’s standard library. For a real task like this though, we’ll want to at least use something to parse CSV data, parse the program arguments and decode that stuff into Rust types automatically. For that, we’ll use the <a href = "https://crates.io/crates/csv"><code>csv</code></a>, and <a href = "https://crates.io/crates/rustc-serialize"><code>rustc-serialize</code></a> crates.</p>
<h3 id = "link-305">Initial setup</h3>
<p id = "para-1550">We’re not going to spend a lot of time on setting up a project with Cargo because it is already covered well in <a href = "#chapter-3">the Cargo section</a> and <a href = "http://doc.crates.io/guide.html">Cargo’s documentation</a>.</p>
<p id = "para-1551">To get started from scratch, run <code>cargo new --bin city-pop</code> and make sure your <code>Cargo.toml</code> looks something like this:</p>
<pre><span style="color:#323232;">[package]
name = &quot;city-pop&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Andrew Gallant &lt;jamslam@gmail.com&gt;&quot;]

[[bin]]
name = &quot;city-pop&quot;

[dependencies]
csv = &quot;0.*&quot;
rustc-serialize = &quot;0.*&quot;
getopts = &quot;0.*&quot;
</span></pre><p id = "para-1552">You should already be able to run:</p>
<pre><span style="color:#323232;">cargo build --release
./target/release/city-pop
# Outputs: Hello, world!
</span></pre><h3 id = "link-306">Argument parsing</h3>
<p id = "para-1553">Let’s get argument parsing out of the way. We won’t go into too much detail on Getopts, but there is <a href = "http://doc.rust-lang.org/getopts/getopts/index.html">some good documentation</a> describing it. The short story is that Getopts generates an argument parser and a help message from a vector of options (The fact that it is a vector is hidden behind a struct and a set of methods). Once the parsing is done, the parser returns a struct that records matches for defined options, and remaining “free” arguments. From there, we can get information about the flags, for instance, whether they were passed in, and what arguments they had. Here’s our program with the appropriate <code>extern crate</code> statements, and the basic argument setup for Getopts:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> getopts;
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> rustc_serialize;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">getopts::Options;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::env;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_usage</span><span style="color:#323232;">(program: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, opts: Options) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, opts.</span><span style="color:#62a35c;">usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">format!(</span><span style="color:#183691;">&quot;Usage: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> [options] &lt;data-path&gt; &lt;city&gt;&quot;</span><span style="color:#323232;">, program)));
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> args: Vec&lt;String&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">env::args().</span><span style="color:#62a35c;">collect</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> program </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> opts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Options::new();
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;help&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Show this usage message.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> matches </span><span style="font-weight:bold;color:#a71d5d;">= match</span><span style="color:#323232;"> opts.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(m)  </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ m }
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(e) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ panic!(e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()) }
    };
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> matches.</span><span style="color:#62a35c;">opt_present</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#62a35c;">print_usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">program, opts);
        </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
    }
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data_path </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str = &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">];

    </span><span style="font-style:italic;color:#969896;">// Do stuff with information.
</span><span style="color:#323232;">}
</span></pre><p id = "para-1554">First, we get a vector of the arguments passed into our program. We then store the first one, knowing that it is our program’s name. Once that’s done, we set up our argument flags, in this case a simplistic help message flag. Once we have the argument flags set up, we use <code>Options.parse</code> to parse the argument vector (starting from index one, because index 0 is the program name). If this was successful, we assign matches to the parsed object, if not, we panic. Once past that, we test if the user passed in the help flag, and if so print the usage message. The option help messages are constructed by Getopts, so all we have to do to print the usage message is tell it what we want it to print for the program name and template. If the user has not passed in the help flag, we assign the proper variables to their corresponding arguments.</p>
<h3 id = "link-307">Writing the logic</h3>
<p id = "para-1555">We all write code differently, but error handling is usually the last thing we want to think about. This isn’t great for the overall design of a program, but it can be useful for rapid prototyping. Because Rust forces us to be explicit about error handling (by making us call <code>unwrap</code>), it is easy to see which parts of our program can cause errors.</p>
<p id = "para-1556">In this case study, the logic is really simple. All we need to do is parse the CSV data given to us and print out a field in matching rows. Let’s do it. (Make sure to add <code>extern crate csv;</code> to the top of your file.)</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fs::File;

</span><span style="font-style:italic;color:#969896;">// This struct represents the data in each row of the CSV file.
// Type based decoding absolves us of a lot of the nitty-gritty error
// handling, like parsing strings as integers or floats.
</span><span style="color:#323232;">#[derive(Debug, RustcDecodable)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Row {
    country: String,
    city: String,
    accent_city: String,
    region: String,

    </span><span style="font-style:italic;color:#969896;">// Not every row has data for the population, latitude or longitude!
    // So we express them as `Option` types, which admits the possibility of
    // absence. The CSV parser will fill in the correct value for us.
    </span><span style="color:#323232;">population: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">u64</span><span style="color:#323232;">&gt;,
    latitude: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">&gt;,
    longitude: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">f64</span><span style="color:#323232;">&gt;,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_usage</span><span style="color:#323232;">(program: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, opts: Options) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, opts.</span><span style="color:#62a35c;">usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">format!(</span><span style="color:#183691;">&quot;Usage: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> [options] &lt;data-path&gt; &lt;city&gt;&quot;</span><span style="color:#323232;">, program)));
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> args: Vec&lt;String&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">env::args().</span><span style="color:#62a35c;">collect</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> program </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> opts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Options::new();
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;help&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Show this usage message.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> matches </span><span style="font-weight:bold;color:#a71d5d;">= match</span><span style="color:#323232;"> opts.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(m)  </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ m }
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(e) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ panic!(e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()) }
    };

    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> matches.</span><span style="color:#62a35c;">opt_present</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#62a35c;">print_usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">program, opts);
        </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
    }

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data_path </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str = &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">File::open(data_path).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rdr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">csv::Reader::from_reader(file);

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> rdr.decode::&lt;Row&gt;() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> row.</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();

        </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> row.city </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> city {
            println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">,
                row.city, row.country,
                row.population.</span><span style="color:#62a35c;">expect</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;population count&quot;</span><span style="color:#323232;">));
        }
    }
}
</span></pre><p id = "para-1557">Let’s outline the errors. We can start with the obvious: the three places that <code>unwrap</code> is called:</p>
<ol>
<li><a href = "src/../../std/fs/struct.File.html#method.open"><code>File::open</code></a> can return an <a href = "src/../../std/io/struct.Error.html"><code>io::Error</code></a>.</li>
<li><a href = "http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.decode"><code>csv::Reader::decode</code></a> decodes one record at a time, and <a href = "http://burntsushi.net/rustdoc/csv/struct.DecodedRecords.html">decoding a record</a> (look at the <code>Item</code> associated type on the <code>Iterator</code> impl) can produce a <a href = "http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a>.</li>
<li>If <code>row.population</code> is <code>None</code>, then calling <code>expect</code> will panic.</li>
</ol>
<p id = "para-1558">Are there any others? What if we can’t find a matching city? Tools like <code>grep</code> will return an error code, so we probably should too. So we have logic errors specific to our problem, IO errors and CSV parsing errors. We’re going to explore two different ways to approach handling these errors.</p>
<p id = "para-1559">I’d like to start with <code>Box&lt;Error&gt;</code>. Later, we’ll see how defining our own error type can be useful.</p>
<h3 id = "link-308">Error handling with <code>Box&lt;Error&gt;</code></h3>
<p id = "para-1560"><code>Box&lt;Error&gt;</code> is nice because it <em>just works</em>. You don’t need to define your own error types and you don’t need any <code>From</code> implementations. The downside is that since <code>Box&lt;Error&gt;</code> is a trait object, it <em>erases the type</em>, which means the compiler can no longer reason about its underlying type.</p>
<p id = "para-1561"><a href = "src/#the-limits-of-combinators">Previously</a> we started refactoring our code by changing the type of our function from <code>T</code> to <code>Result&lt;T, OurErrorType&gt;</code>. In this case, <code>OurErrorType</code> is only <code>Box&lt;Error&gt;</code>. But what’s <code>T</code>? And can we add a return type to <code>main</code>?</p>
<p id = "para-1562">The answer to the second question is no, we can’t. That means we’ll need to write a new function. But what is <code>T</code>? The simplest thing we can do is to return a list of matching <code>Row</code> values as a <code>Vec&lt;Row&gt;</code>. (Better code would return an iterator, but that is left as an exercise to the reader.)</p>
<p id = "para-1563">Let’s refactor our code into its own function, but keep the calls to <code>unwrap</code>. Note that we opt to handle the possibility of a missing population count by simply ignoring that row.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::path::Path;

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Row {
    </span><span style="font-style:italic;color:#969896;">// This struct remains unchanged.
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">PopulationCount {
    city: String,
    country: String,
    </span><span style="font-style:italic;color:#969896;">// This is no longer an `Option` because values of this type are only
    // constructed if they have a population count.
    </span><span style="color:#323232;">count: </span><span style="font-weight:bold;color:#a71d5d;">u64</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_usage</span><span style="color:#323232;">(program: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, opts: Options) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, opts.</span><span style="color:#62a35c;">usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">format!(</span><span style="color:#183691;">&quot;Usage: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> [options] &lt;data-path&gt; &lt;city&gt;&quot;</span><span style="color:#323232;">, program)));
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">search</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P, city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">) -&gt; Vec&lt;PopulationCount&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> found </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">File::open(file_path).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rdr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">csv::Reader::from_reader(file);
    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> rdr.decode::&lt;Row&gt;() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> row.</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> row.population {
            </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ } </span><span style="font-style:italic;color:#969896;">// Skip it.
            </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(count) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; if</span><span style="color:#323232;"> row.city </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> city {
                found.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    found
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> args: Vec&lt;String&gt; </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">env::args().</span><span style="color:#62a35c;">collect</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> program </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> opts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Options::new();
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;help&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Show this usage message.&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> matches </span><span style="font-weight:bold;color:#a71d5d;">= match</span><span style="color:#323232;"> opts.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">args[</span><span style="color:#0086b3;">1</span><span style="font-weight:bold;color:#a71d5d;">..</span><span style="color:#323232;">]) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(m)  </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ m }
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(e) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ panic!(e.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">()) }
    };

    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> matches.</span><span style="color:#62a35c;">opt_present</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">) {
        </span><span style="color:#62a35c;">print_usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">program, opts);
        </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
    }

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> data_path </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str = &amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">1</span><span style="color:#323232;">];

    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> pop </span><span style="font-weight:bold;color:#a71d5d;">in </span><span style="color:#62a35c;">search</span><span style="color:#323232;">(data_path, city) {
        println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, pop.city, pop.country, pop.count);
    }
}

</span></pre><p id = "para-1564">While we got rid of one use of <code>expect</code> (which is a nicer variant of <code>unwrap</code>), we still should handle the absence of any search results.</p>
<p id = "para-1565">To convert this to proper error handling, we need to do the following:</p>
<ol>
<li>Change the return type of <code>search</code> to be <code>Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt;</code>.</li>
<li>Use the <a href = "src/#code-try-def"><code>try!</code> macro</a> so that errors are returned to the caller instead of panicking the program.</li>
<li>Handle the error in <code>main</code>.</li>
</ol>
<p id = "para-1566">Let’s try it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::error::Error;

</span><span style="font-style:italic;color:#969896;">// The rest of the code before this is unchanged.

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">search</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: P, city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> found </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> file </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(File::open(file_path));
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rdr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">csv::Reader::from_reader(file);
    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> rdr.decode::&lt;Row&gt;() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(row);
        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> row.population {
            </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ } </span><span style="font-style:italic;color:#969896;">// Skip it.
            </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(count) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; if</span><span style="color:#323232;"> row.city </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> city {
                found.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> found.</span><span style="color:#62a35c;">is_empty</span><span style="color:#323232;">() {
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="color:#0086b3;">From</span><span style="color:#323232;">::from(</span><span style="color:#183691;">&quot;No matching cities with a population were found.&quot;</span><span style="color:#323232;">))
    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(found)
    }
}
</span></pre><p id = "para-1567">Instead of <code>x.unwrap()</code>, we now have <code>try!(x)</code>. Since our function returns a <code>Result&lt;T, E&gt;</code>, the <code>try!</code> macro will return early from the function if an error occurs.</p>
<p id = "para-1568">At the end of <code>search</code> we also convert a plain string to an error type by using the <a href = "src/../../std/convert/trait.From.html">corresponding <code>From</code> impls</a>:</p>
<pre><span style="font-style:italic;color:#969896;">// We are making use of this impl in the code above, since we call `From::from`
// on a `&amp;&#39;static str`.
</span><span style="font-weight:bold;color:#a71d5d;">impl</span><span style="color:#323232;">&lt;</span><span style="font-weight:bold;color:#a71d5d;">&#39;a</span><span style="color:#323232;">&gt; From&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;a str</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Box&lt;Error&gt;

</span><span style="font-style:italic;color:#969896;">// But this is also useful when you need to allocate a new string for an
// error message, usually with `format!`.
</span><span style="color:#323232;">impl From&lt;String&gt; for Box&lt;Error&gt;
</span></pre><p id = "para-1569">Since <code>search</code> now returns a <code>Result&lt;T, E&gt;</code>, <code>main</code> should use case analysis when calling <code>search</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">...
    match </span><span style="color:#62a35c;">search</span><span style="color:#323232;">(data_path, city) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(pops) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> pop </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> pops {
                println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, pop.city, pop.country, pop.count);
            }
        }
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err)
    }
</span><span style="font-weight:bold;color:#a71d5d;">...
</span></pre><p id = "para-1570">Now that we’ve seen how to do proper error handling with <code>Box&lt;Error&gt;</code>, let’s try a different approach with our own custom error type. But first, let’s take a quick break from error handling and add support for reading from <code>stdin</code>.</p>
<h3 id = "link-309">Reading from stdin</h3>
<p id = "para-1571">In our program, we accept a single file for input and do one pass over the data. This means we probably should be able to accept input on stdin. But maybe we like the current format too—so let’s have both!</p>
<p id = "para-1572">Adding support for stdin is actually quite easy. There are only three things we have to do:</p>
<ol>
<li>Tweak the program arguments so that a single parameter—the city—can be accepted while the population data is read from stdin.</li>
<li>Modify the program so that an option <code>-f</code> can take the file, if it is not passed into stdin.</li>
<li>Modify the <code>search</code> function to take an <em>optional</em> file path. When <code>None</code>, it should know to read from stdin.</li>
</ol>
<p id = "para-1573">First, here’s the new usage:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">print_usage</span><span style="color:#323232;">(program: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">, opts: Options) {
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, opts.</span><span style="color:#62a35c;">usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">format!(</span><span style="color:#183691;">&quot;Usage: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> [options] &lt;city&gt;&quot;</span><span style="color:#323232;">, program)));
}
</span></pre><p id = "para-1574">Of course we need to adapt the argument handling code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">...
    let mut</span><span style="color:#323232;"> opts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Options::new();
    opts.</span><span style="color:#62a35c;">optopt</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;f&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;file&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Choose an input file, instead of using STDIN.&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;NAME&quot;</span><span style="color:#323232;">);
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;help&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Show this usage message.&quot;</span><span style="color:#323232;">);
    </span><span style="font-weight:bold;color:#a71d5d;">...
    let</span><span style="color:#323232;"> data_path </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> matches.</span><span style="color:#62a35c;">opt_str</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;f&quot;</span><span style="color:#323232;">);

    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> city </span><span style="font-weight:bold;color:#a71d5d;">= if !</span><span style="color:#323232;">matches.free.</span><span style="color:#62a35c;">is_empty</span><span style="color:#323232;">() {
        </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">matches.free[</span><span style="color:#0086b3;">0</span><span style="color:#323232;">]
    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">print_usage</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">program, opts);
        </span><span style="font-weight:bold;color:#a71d5d;">return</span><span style="color:#323232;">;
    };

    </span><span style="font-weight:bold;color:#a71d5d;">match </span><span style="color:#62a35c;">search</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">data_path, city) {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(pops) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{
            </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> pop </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> pops {
                println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, pop.city, pop.country, pop.count);
            }
        }
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, err)
    }
</span><span style="font-weight:bold;color:#a71d5d;">...
</span></pre><p id = "para-1575">We’ve made the user experience a bit nicer by showing the usage message, instead of a panic from an out-of-bounds index, when <code>city</code>, the remaining free argument, is not present.</p>
<p id = "para-1576">Modifying <code>search</code> is slightly trickier. The <code>csv</code> crate can build a parser out of <a href = "http://burntsushi.net/rustdoc/csv/struct.Reader.html#method.from_reader">any type that implements <code>io::Read</code></a>. But how can we use the same code over both types? There’s actually a couple ways we could go about this. One way is to write <code>search</code> such that it is generic on some type parameter <code>R</code> that satisfies <code>io::Read</code>. Another way is to use trait objects:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::io;

</span><span style="font-style:italic;color:#969896;">// The rest of the code before this is unchanged.

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">search</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Option&lt;P&gt;, city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, Box&lt;Error&gt;&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> found </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> input: Box&lt;io::Read&gt; </span><span style="font-weight:bold;color:#a71d5d;">= match *</span><span style="color:#323232;">file_path {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(io::stdin()),
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> file_path) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(try!(File::open(file_path))),
    };
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rdr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">csv::Reader::from_reader(input);
    </span><span style="font-style:italic;color:#969896;">// The rest remains unchanged!
</span><span style="color:#323232;">}
</span></pre><h3 id = "link-310">Error handling with a custom type</h3>
<p id = "para-1577">Previously, we learned how to <a href = "src/#composing-custom-error-types">compose errors using a custom error type</a>. We did this by defining our error type as an <code>enum</code> and implementing <code>Error</code> and <code>From</code>.</p>
<p id = "para-1578">Since we have three distinct errors (IO, CSV parsing and not found), let’s define an <code>enum</code> with three variants:</p>
<pre><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">enum </span><span style="color:#323232;">CliError {
    Io(io::Error),
    Csv(csv::Error),
    NotFound,
}
</span></pre><p id = "para-1579">And now for impls on <code>Display</code> and <code>Error</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">fmt::Display </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">fmt</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">fmt::Formatter) -&gt; fmt::Result {
        </span><span style="font-weight:bold;color:#a71d5d;">match *</span><span style="color:#323232;">self {
            CliError::Io(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> err.</span><span style="color:#62a35c;">fmt</span><span style="color:#323232;">(f),
            CliError::Csv(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> err.</span><span style="color:#62a35c;">fmt</span><span style="color:#323232;">(f),
            CliError::NotFound </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">write!(f, </span><span style="color:#183691;">&quot;No matching cities with a \
                                             population were found.&quot;</span><span style="color:#323232;">),
        }
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">Error </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">cause</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Error&gt; {
        </span><span style="font-weight:bold;color:#a71d5d;">match *</span><span style="color:#323232;">self {
            CliError::Io(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(err),
            CliError::Csv(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(err),
            </span><span style="font-style:italic;color:#969896;">// Our custom error doesn&#39;t have an underlying cause,
            // but we could modify it so that it does.
            </span><span style="color:#323232;">CliError::NotFound </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">None</span><span style="color:#323232;">,
        }
    }
}
</span></pre><p id = "para-1580">Before we can use our <code>CliError</code> type in our <code>search</code> function, we need to provide a couple <code>From</code> impls. How do we know which impls to provide? Well, we’ll need to convert from both <code>io::Error</code> and <code>csv::Error</code> to <code>CliError</code>. Those are the only external errors, so we’ll only need two <code>From</code> impls for now:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">From&lt;io::Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">From&lt;csv::Error&gt; </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">CliError {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">from</span><span style="color:#323232;">(err: csv::Error) -&gt; CliError {
        CliError::Csv(err)
    }
}
</span></pre><p id = "para-1581">The <code>From</code> impls are important because of how <a href = "src/#code-try-def"><code>try!</code> is defined</a>. In particular, if an error occurs, <code>From::from</code> is called on the error, which in this case, will convert it to our own error type <code>CliError</code>.</p>
<p id = "para-1582">With the <code>From</code> impls done, we only need to make two small tweaks to our <code>search</code> function: the return type and the “not found” error. Here it is in full:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">search</span><span style="color:#323232;">&lt;P: AsRef&lt;Path&gt;&gt;
         (file_path: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Option&lt;P&gt;, city: </span><span style="font-weight:bold;color:#a71d5d;">&amp;str</span><span style="color:#323232;">)
         -&gt; Result&lt;Vec&lt;PopulationCount&gt;, CliError&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> found </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> input: Box&lt;io::Read&gt; </span><span style="font-weight:bold;color:#a71d5d;">= match *</span><span style="color:#323232;">file_path {
        </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(io::stdin()),
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">ref</span><span style="color:#323232;"> file_path) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(try!(File::open(file_path))),
    };
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rdr </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">csv::Reader::from_reader(input);
    </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> rdr.decode::&lt;Row&gt;() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> row </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">try!(row);
        </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> row.population {
            </span><span style="color:#0086b3;">None </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">{ } </span><span style="font-style:italic;color:#969896;">// Skip it.
            </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(count) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; if</span><span style="color:#323232;"> row.city </span><span style="font-weight:bold;color:#a71d5d;">==</span><span style="color:#323232;"> city {
                found.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(PopulationCount {
                    city: row.city,
                    country: row.country,
                    count: count,
                });
            },
        }
    }
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> found.</span><span style="color:#62a35c;">is_empty</span><span style="color:#323232;">() {
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(CliError::NotFound)
    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(found)
    }
}
</span></pre><p id = "para-1583">No other changes are necessary.</p>
<h3 id = "link-311">Adding functionality</h3>
<p id = "para-1584">Writing generic code is great, because generalizing stuff is cool, and it can then be useful later. But sometimes, the juice isn’t worth the squeeze. Look at what we just did in the previous step:</p>
<ol>
<li>Defined a new error type.</li>
<li>Added impls for <code>Error</code>, <code>Display</code> and two for <code>From</code>.</li>
</ol>
<p id = "para-1585">The big downside here is that our program didn’t improve a whole lot. There is quite a bit of overhead to representing errors with <code>enum</code>s, especially in short programs like this.</p>
<p id = "para-1586"><em>One</em> useful aspect of using a custom error type like we’ve done here is that the <code>main</code> function can now choose to handle errors differently. Previously, with <code>Box&lt;Error&gt;</code>, it didn’t have much of a choice: just print the message. We’re still doing that here, but what if we wanted to, say, add a <code>--quiet</code> flag? The <code>--quiet</code> flag should silence any verbose output.</p>
<p id = "para-1587">Right now, if the program doesn’t find a match, it will output a message saying so. This can be a little clumsy, especially if you intend for the program to be used in shell scripts.</p>
<p id = "para-1588">So let’s start by adding the flags. Like before, we need to tweak the usage string and add a flag to the Option variable. Once we’ve done that, Getopts does the rest:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">...
    let mut</span><span style="color:#323232;"> opts </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Options::new();
    opts.</span><span style="color:#62a35c;">optopt</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;f&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;file&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Choose an input file, instead of using STDIN.&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;NAME&quot;</span><span style="color:#323232;">);
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;h&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;help&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Show this usage message.&quot;</span><span style="color:#323232;">);
    opts.</span><span style="color:#62a35c;">optflag</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;q&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;quiet&quot;</span><span style="color:#323232;">, </span><span style="color:#183691;">&quot;Silences errors and warnings.&quot;</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">...
</span></pre><p id = "para-1589">Now we only need to implement our “quiet” functionality. This requires us to tweak the case analysis in <code>main</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::process;
</span><span style="font-weight:bold;color:#a71d5d;">...
    match </span><span style="color:#62a35c;">search</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">data_path, city) {
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(CliError::NotFound) </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> matches.</span><span style="color:#62a35c;">opt_present</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;q&quot;</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">process::exit(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">),
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(err) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;{}&quot;</span><span style="color:#323232;">, err),
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(pops) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; for</span><span style="color:#323232;"> pop </span><span style="font-weight:bold;color:#a71d5d;">in</span><span style="color:#323232;"> pops {
            println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">: </span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, pop.city, pop.country, pop.count);
        }
    }
</span><span style="font-weight:bold;color:#a71d5d;">...
</span></pre><p id = "para-1590">Certainly, we don’t want to be quiet if there was an IO error or if the data failed to parse. Therefore, we use case analysis to check if the error type is <code>NotFound</code> <em>and</em> if <code>--quiet</code> has been enabled. If the search failed, we still quit with an exit code (following <code>grep</code>’s convention).</p>
<p id = "para-1591">If we had stuck with <code>Box&lt;Error&gt;</code>, then it would be pretty tricky to implement the <code>--quiet</code> functionality.</p>
<p id = "para-1592">This pretty much sums up our case study. From here, you should be ready to go out into the world and write your own programs and libraries with proper error handling.</p>
<h2 id = "link-312">The Short Story</h2>
<p id = "para-1593">Since this section is long, it is useful to have a quick summary for error handling in Rust. These are some good “rules of thumb." They are emphatically <em>not</em> commandments. There are probably good reasons to break every one of these heuristics!</p>
<ul>
<li>If you’re writing short example code that would be overburdened by error handling, it’s probably fine to use <code>unwrap</code> (whether that’s <a href = "src/../../std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>, <a href = "src/../../std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> or preferably <a href = "src/../../std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>). Consumers of your code should know to use proper error handling. (If they don’t, send them here!)</li>
<li>If you’re writing a quick ‘n’ dirty program, don’t feel ashamed if you use <code>unwrap</code>. Be warned: if it winds up in someone else’s hands, don’t be surprised if they are agitated by poor error messages!</li>
<li>If you’re writing a quick ‘n’ dirty program and feel ashamed about panicking anyway, then use either a <code>String</code> or a <code>Box&lt;Error&gt;</code> for your error type.</li>
<li>Otherwise, in a program, define your own error types with appropriate <a href = "src/../../std/convert/trait.From.html"><code>From</code></a> and <a href = "src/../../std/error/trait.Error.html"><code>Error</code></a> impls to make the <a href = "src/../../std/macro.try.html"><code>try!</code></a> macro more ergonomic.</li>
<li>If you’re writing a library and your code can produce errors, define your own error type and implement the <a href = "src/../../std/error/trait.Error.html"><code>std::error::Error</code></a> trait. Where appropriate, implement <a href = "src/../../std/convert/trait.From.html"><code>From</code></a> to make both your library code and the caller’s code easier to write. (Because of Rust’s coherence rules, callers will not be able to impl <code>From</code> on your error type, so your library should do it.)</li>
<li>Learn the combinators defined on <a href = "src/../../std/option/enum.Option.html"><code>Option</code></a> and <a href = "src/../../std/result/enum.Result.html"><code>Result</code></a>. Using them exclusively can be a bit tiring at times, but I’ve personally found a healthy mix of <code>try!</code> and combinators to be quite appealing. <code>and_then</code>, <code>map</code> and <code>unwrap_or</code> are my favorites.</li>
</ul>

</div><div id = "chapter-53" class = "chapter">
  <h2 id = "link-313">Choosing your Guarantees</h2>
<p id = "para-1594">One important feature of Rust is that it lets us control the costs and guarantees of a program.</p>
<p id = "para-1595">There are various “wrapper type” abstractions in the Rust standard library which embody a multitude of trade-offs between cost, ergonomics, and guarantees. Many let one choose between run-time and compile-time enforcement. This section will explain a few selected abstractions in detail.</p>
<p id = "para-1596">Before proceeding, it is highly recommended that one reads about <a href = "#chapter-15">ownership</a> and <a href = "#chapter-16">borrowing</a> in Rust.</p>
<h2 id = "link-314">Basic pointer types</h2>
<h3 id = "link-315"><code>Box&lt;T&gt;</code></h3>
<p id = "para-1597"><a href = "src/../../std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> is an “owned” pointer, or a “box”. While it can hand out references to the contained data, it is the only owner of the data. In particular, consider the following:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x;
</span><span style="font-style:italic;color:#969896;">// `x` is no longer accessible here.
</span></pre><p id = "para-1598">Here, the box was <em>moved</em> into <code>y</code>. As <code>x</code> no longer owns it, the compiler will no longer allow the programmer to use <code>x</code> after this. A box can similarly be moved <em>out</em> of a function by returning it.</p>
<p id = "para-1599">When a box (that hasn’t been moved) goes out of scope, destructors are run. These destructors take care of deallocating the inner data.</p>
<p id = "para-1600">This is a zero-cost abstraction for dynamic allocation. If you want to allocate some memory on the heap and safely pass around a pointer to that memory, this is ideal. Note that you will only be allowed to share references to this by the regular borrowing rules, checked at compile time.</p>
<h3 id = "link-316"><code>&amp;T</code> and <code>&amp;mut T</code></h3>
<p id = "para-1601">These are immutable and mutable references respectively. They follow the “read-write lock” pattern, such that one may either have only one mutable reference to some data, or any number of immutable ones, but not both. This guarantee is enforced at compile time, and has no visible cost at runtime. In most cases these two pointer types suffice for sharing cheap references between sections of code.</p>
<p id = "para-1602">These pointers cannot be copied in such a way that they outlive the lifetime associated with them.</p>
<h3 id = "link-317"><code>*const T</code> and <code>*mut T</code></h3>
<p id = "para-1603">These are C-like raw pointers with no lifetime or ownership attached to them. They point to some location in memory with no other restrictions. The only guarantee that these provide is that they cannot be dereferenced except in code marked <code>unsafe</code>.</p>
<p id = "para-1604">These are useful when building safe, low cost abstractions like <code>Vec&lt;T&gt;</code>, but should be avoided in safe code.</p>
<h3 id = "link-318"><code>Rc&lt;T&gt;</code></h3>
<p id = "para-1605">This is the first wrapper we will cover that has a runtime cost.</p>
<p id = "para-1606"><a href = "src/../../std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> is a reference counted pointer. In other words, this lets us have multiple “owning” pointers to the same data, and the data will be dropped (destructors will be run) when all pointers are out of scope.</p>
<p id = "para-1607">Internally, it contains a shared “reference count” (also called “refcount”), which is incremented each time the <code>Rc</code> is cloned, and decremented each time one of the <code>Rc</code>s goes out of scope. The main responsibility of <code>Rc&lt;T&gt;</code> is to ensure that destructors are called for shared data.</p>
<p id = "para-1608">The internal data here is immutable, and if a cycle of references is created, the data will be leaked. If we want data that doesn’t leak when there are cycles, we need a garbage collector.</p>
<h5 id = "link-319">Guarantees</h5>
<p id = "para-1609">The main guarantee provided here is that the data will not be destroyed until all references to it are out of scope.</p>
<p id = "para-1610">This should be used when we wish to dynamically allocate and share some data (read-only) between various portions of your program, where it is not certain which portion will finish using the pointer last. It’s a viable alternative to <code>&amp;T</code> when <code>&amp;T</code> is either impossible to statically check for correctness, or creates extremely unergonomic code where the programmer does not wish to spend the development cost of working with.</p>
<p id = "para-1611">This pointer is <em>not</em> thread-safe, and Rust will not let it be sent or shared with other threads. This lets one avoid the cost of atomics in situations where they are unnecessary.</p>
<p id = "para-1612">There is a sister smart pointer to this one, <code>Weak&lt;T&gt;</code>. This is a non-owning, but also non-borrowed, smart pointer. It is also similar to <code>&amp;T</code>, but it is not restricted in lifetime—a <code>Weak&lt;T&gt;</code> can be held on to forever. However, it is possible that an attempt to access the inner data may fail and return <code>None</code>, since this can outlive the owned <code>Rc</code>s. This is useful for cyclic data structures and other things.</p>
<h5 id = "link-320">Cost</h5>
<p id = "para-1613">As far as memory goes, <code>Rc&lt;T&gt;</code> is a single allocation, though it will allocate two extra words (i.e. two <code>usize</code> values) as compared to a regular <code>Box&lt;T&gt;</code> (for “strong” and “weak” refcounts).</p>
<p id = "para-1614"><code>Rc&lt;T&gt;</code> has the computational cost of incrementing/decrementing the refcount whenever it is cloned or goes out of scope respectively. Note that a clone will not do a deep copy, rather it will simply increment the inner reference count and return a copy of the <code>Rc&lt;T&gt;</code>.</p>
<h2 id = "link-321">Cell types</h2>
<p id = "para-1615"><code>Cell</code>s provide interior mutability. In other words, they contain data which can be manipulated even if the type cannot be obtained in a mutable form (for example, when it is behind an <code>&amp;</code>-ptr or <code>Rc&lt;T&gt;</code>).</p>
<p id = "para-1616"><a href = "src/../../std/cell/index.html">The documentation for the <code>cell</code> module has a pretty good explanation for these</a>.</p>
<p id = "para-1617">These types are <em>generally</em> found in struct fields, but they may be found elsewhere too.</p>
<h3 id = "link-322"><code>Cell&lt;T&gt;</code></h3>
<p id = "para-1618"><a href = "src/../../std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> is a type that provides zero-cost interior mutability by moving data in and out of the cell. Since the compiler knows that all the data owned by the contained value is on the stack, there’s no worry of leaking any data behind references (or worse!) by simply replacing the data.</p>
<p id = "para-1619">It is still possible to violate your own invariants using this wrapper, so be careful when using it. If a field is wrapped in <code>Cell</code>, it’s a nice indicator that the chunk of data is mutable and may not stay the same between the time you first read it and when you intend to use it.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cell::Cell;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">Cell::new(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">x;
x.</span><span style="color:#62a35c;">set</span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">);
y.</span><span style="color:#62a35c;">set</span><span style="color:#323232;">(</span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
z.</span><span style="color:#62a35c;">set</span><span style="color:#323232;">(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">);
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x.</span><span style="color:#62a35c;">get</span><span style="color:#323232;">());
</span></pre><p id = "para-1620">Note that here we were able to mutate the same value from various immutable references.</p>
<p id = "para-1621">This has the same runtime cost as the following:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= &amp;mut</span><span style="color:#323232;"> x;
x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">2</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">3</span><span style="color:#323232;">;
</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">z </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">4</span><span style="color:#323232;">;
println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
</span></pre><p id = "para-1622">but it has the added benefit of actually compiling successfully.</p>
<h5 id = "link-323">Guarantees</h5>
<p id = "para-1623">This relaxes the “no aliasing with mutability” restriction in places where it’s unnecessary. However, this also relaxes the guarantees that the restriction provides; so if your invariants depend on data stored within <code>Cell</code>, you should be careful.</p>
<p id = "para-1624">This is useful for mutating primitives and other types when there is no easy way of doing it in line with the static rules of <code>&amp;</code> and <code>&amp;mut</code>.</p>
<p id = "para-1625"><code>Cell</code> does not let you obtain interior references to the data, which makes it safe to freely mutate.</p>
<h5 id = "link-324">Cost</h5>
<p id = "para-1626">There is no runtime cost to using <code>Cell&lt;T&gt;</code>, however if you are using it to wrap larger structs, it might be worthwhile to instead wrap individual fields in <code>Cell&lt;T&gt;</code> since each write is otherwise a full copy of the struct.</p>
<h3 id = "link-325"><code>RefCell&lt;T&gt;</code></h3>
<p id = "para-1627"><a href = "src/../../std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> also provides interior mutability, but doesn’t move data in and out of the cell.</p>
<p id = "para-1628">However, it has a runtime cost. <code>RefCell&lt;T&gt;</code> enforces the read-write lock pattern at runtime (it’s like a single-threaded mutex), unlike <code>&amp;T</code>/<code>&amp;mut T</code> which do so at compile time. This is done by the <code>borrow()</code> and <code>borrow_mut()</code> functions, which modify an internal reference count and return smart pointers which can be dereferenced immutably and mutably respectively. The refcount is restored when the smart pointers go out of scope. With this system, we can dynamically ensure that there are never any other borrows active when a mutable borrow is active. If the programmer attempts to make such a borrow, the thread will panic.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::cell::RefCell;

</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">RefCell::new(vec![</span><span style="color:#0086b3;">1</span><span style="color:#323232;">,</span><span style="color:#0086b3;">2</span><span style="color:#323232;">,</span><span style="color:#0086b3;">3</span><span style="color:#323232;">,</span><span style="color:#0086b3;">4</span><span style="color:#323232;">]);
{
    println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">x.</span><span style="color:#62a35c;">borrow</span><span style="color:#323232;">())
}

{
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> my_ref </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> x.</span><span style="color:#62a35c;">borrow_mut</span><span style="color:#323232;">();
    my_ref.</span><span style="color:#62a35c;">push</span><span style="color:#323232;">(</span><span style="color:#0086b3;">1</span><span style="color:#323232;">);
}
</span></pre><p id = "para-1629">Similar to <code>Cell</code>, this is mainly useful for situations where it’s hard or impossible to satisfy the borrow checker. Generally we know that such mutations won’t happen in a nested form, but it’s good to check.</p>
<p id = "para-1630">For large, complicated programs, it becomes useful to put some things in <code>RefCell</code>s to make things simpler. For example, a lot of the maps in the <code>ctxt</code> struct in the Rust compiler internals are inside this wrapper. These are only modified once (during creation, which is not right after initialization) or a couple of times in well-separated places. However, since this struct is pervasively used everywhere, juggling mutable and immutable pointers would be hard (perhaps impossible) and probably form a soup of <code>&amp;</code>-ptrs which would be hard to extend. On the other hand, the <code>RefCell</code> provides a cheap (not zero-cost) way of safely accessing these. In the future, if someone adds some code that attempts to modify the cell when it’s already borrowed, it will cause a (usually deterministic) panic which can be traced back to the offending borrow.</p>
<p id = "para-1631">Similarly, in Servo’s DOM there is a lot of mutation, most of which is local to a DOM type, but some of which crisscrosses the DOM and modifies various things. Using <code>RefCell</code> and <code>Cell</code> to guard all mutation lets us avoid worrying about mutability everywhere, and it simultaneously highlights the places where mutation is <em>actually</em> happening.</p>
<p id = "para-1632">Note that <code>RefCell</code> should be avoided if a mostly simple solution is possible with <code>&amp;</code> pointers.</p>
<h5 id = "link-326">Guarantees</h5>
<p id = "para-1633"><code>RefCell</code> relaxes the <em>static</em> restrictions preventing aliased mutation, and replaces them with <em>dynamic</em> ones. As such the guarantees have not changed.</p>
<h5 id = "link-327">Cost</h5>
<p id = "para-1634"><code>RefCell</code> does not allocate, but it contains an additional “borrow state” indicator (one word in size) along with the data.</p>
<p id = "para-1635">At runtime each borrow causes a modification/check of the refcount.</p>
<h2 id = "link-328">Synchronous types</h2>
<p id = "para-1636">Many of the types above cannot be used in a threadsafe manner. Particularly, <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>, which both use non-atomic reference counts (<em>atomic</em> reference counts are those which can be incremented from multiple threads without causing a data race), cannot be used this way. This makes them cheaper to use, but we need thread-safe versions of these too. They exist, in the form of <code>Arc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>RwLock&lt;T&gt;</code></p>
<p id = "para-1637">Note that the non-threadsafe types <em>cannot</em> be sent between threads, and this is checked at compile time.</p>
<p id = "para-1638">There are many useful wrappers for concurrent programming in the <a href = "src/../../std/sync/index.html">sync</a> module, but only the major ones will be covered below.</p>
<h3 id = "link-329"><code>Arc&lt;T&gt;</code></h3>
<p id = "para-1639"><a href = "src/../../std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> is a version of <code>Rc&lt;T&gt;</code> that uses an atomic reference count (hence, “Arc”). This can be sent freely between threads.</p>
<p id = "para-1641">C++’s <code>shared_ptr</code> is similar to <code>Arc</code>, however in the case of C++ the inner data is always mutable. For semantics similar to that from C++, we should use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, or <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code><a href = "#note-dest-4"><sup id = "note-source-4">[4]</sup></a> (<code>UnsafeCell&lt;T&gt;</code> is a cell type that can be used to hold any data and has no runtime cost, but accessing it requires <code>unsafe</code> blocks). The last one should only be used if we are certain that the usage won’t cause any memory unsafety. Remember that writing to a struct is not an atomic operation, and many functions like <code>vec.push()</code> can reallocate internally and cause unsafe behavior, so even monotonicity may not be enough to justify <code>UnsafeCell</code>.</p>
 <h5 id = "link-330">Guarantees</h5>
<p id = "para-1642">Like <code>Rc</code>, this provides the (thread-safe) guarantee that the destructor for the internal data will be run when the last <code>Arc</code> goes out of scope (barring any cycles).</p>
<h5 id = "link-331">Cost</h5>
<p id = "para-1643">This has the added cost of using atomics for changing the refcount (which will happen whenever it is cloned or goes out of scope). When sharing data from an <code>Arc</code> in a single thread, it is preferable to share <code>&amp;</code> pointers whenever possible.</p>
<h3 id = "link-332"><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></h3>
<p id = "para-1644"><a href = "src/../../std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> and <a href = "src/../../std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> provide mutual-exclusion via RAII guards (guards are objects which maintain some state, like a lock, until their destructor is called). For both of these, the mutex is opaque until we call <code>lock()</code> on it, at which point the thread will block until a lock can be acquired, and then a guard will be returned. This guard can be used to access the inner data (mutably), and the lock will be released when the guard goes out of scope.</p>
<pre><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> guard </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> mutex.</span><span style="color:#62a35c;">lock</span><span style="color:#323232;">();
    </span><span style="font-style:italic;color:#969896;">// `guard` dereferences mutably to the inner type.
    </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">guard </span><span style="font-weight:bold;color:#a71d5d;">+= </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
} </span><span style="font-style:italic;color:#969896;">// Lock is released when destructor runs.
</span></pre><p id = "para-1645"><code>RwLock</code> has the added benefit of being efficient for multiple reads. It is always safe to have multiple readers to shared data as long as there are no writers; and <code>RwLock</code> lets readers acquire a “read lock”. Such locks can be acquired concurrently and are kept track of via a reference count. Writers must obtain a “write lock” which can only be obtained when all readers have gone out of scope.</p>
<h5 id = "link-333">Guarantees</h5>
<p id = "para-1646">Both of these provide safe shared mutability across threads, however they are prone to deadlocks. Some level of additional protocol safety can be obtained via the type system.</p>
<h5 id = "link-334">Costs</h5>
<p id = "para-1647">These use internal atomic-like types to maintain the locks, which are pretty costly (they can block all memory reads across processors till they’re done). Waiting on these locks can also be slow when there’s a lot of concurrent access happening.</p>
<h2 id = "link-335">Composition</h2>
<p id = "para-1648">A common gripe when reading Rust code is with types like <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (or even more complicated compositions of such types). It’s not always clear what the composition does, or why the author chose one like this (and when one should be using such a composition in one’s own code)</p>
<p id = "para-1649">Usually, it’s a case of composing together the guarantees that you need, without paying for stuff that is unnecessary.</p>
<p id = "para-1650">For example, <code>Rc&lt;RefCell&lt;T&gt;&gt;</code> is one such composition. <code>Rc&lt;T&gt;</code> itself can’t be dereferenced mutably; because <code>Rc&lt;T&gt;</code> provides sharing and shared mutability can lead to unsafe behavior, so we put <code>RefCell&lt;T&gt;</code> inside to get dynamically verified shared mutability. Now we have shared mutable data, but it’s shared in a way that there can only be one mutator (and no readers) or multiple readers.</p>
<p id = "para-1651">Now, we can take this a step further, and have <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> or <code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. These are both shareable, mutable vectors, but they’re not the same.</p>
<p id = "para-1652">With the former, the <code>RefCell&lt;T&gt;</code> is wrapping the <code>Vec&lt;T&gt;</code>, so the <code>Vec&lt;T&gt;</code> in its entirety is mutable. At the same time, there can only be one mutable borrow of the whole <code>Vec</code> at a given time. This means that your code cannot simultaneously work on different elements of the vector from different <code>Rc</code> handles. However, we are able to push and pop from the <code>Vec&lt;T&gt;</code> at will. This is similar to a <code>&amp;mut Vec&lt;T&gt;</code> with the borrow checking done at runtime.</p>
<p id = "para-1654">With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus, we can independently borrow separate elements, but we cannot push or pop from the vector. This is similar to a <code>&amp;mut [T]</code><a href = "#note-dest-5"><sup id = "note-source-5">[5]</sup></a>, but, again, the borrow checking is at runtime.</p>
<p id = "para-1655">In concurrent programs, we have a similar situation with <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, which provides shared mutability and ownership.</p>
<p id = "para-1656">When reading code that uses these, go in step by step and look at the guarantees/costs provided.</p>
<p id = "para-1657">When choosing a composed type, we must do the reverse; figure out which guarantees we want, and at which point of the composition we need them. For example, if there is a choice between <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> and <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, we should figure out the trade-offs as done above and pick one.</p>
 
</div><div id = "chapter-54" class = "chapter">
  <h2 id = "link-336">Foreign Function Interface</h2>
<h2 id = "link-337">Introduction</h2>
<p id = "para-1658">This guide will use the <a href = "https://github.com/google/snappy">snappy</a> compression/decompression library as an introduction to writing bindings for foreign code. Rust is currently unable to call directly into a C++ library, but snappy includes a C interface (documented in <a href = "https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
<h3 id = "link-338">A note about libc</h3>
<p id = "para-1659">Many of these examples use <a href = "https://crates.io/crates/libc">the <code>libc</code> crate</a>, which provides various type definitions for C types, among other things. If you’re trying these examples yourself, you’ll need to add <code>libc</code> to your <code>Cargo.toml</code>:</p>
<pre><span style="color:#323232;">[dependencies]
libc = &quot;0.2.0&quot;
</span></pre><p id = "para-1660">and add <code>extern crate libc;</code> to your crate root.</p>
<h3 id = "link-339">Calling foreign functions</h3>
<p id = "para-1661">The following is a minimal example of calling a foreign function which will compile if snappy is installed:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">libc::</span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">;

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;snappy&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_max_compressed_length</span><span style="color:#323232;">(source_length: size_t) -&gt; size_t;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= unsafe </span><span style="color:#323232;">{ </span><span style="color:#62a35c;">snappy_max_compressed_length</span><span style="color:#323232;">(</span><span style="color:#0086b3;">100</span><span style="color:#323232;">) };
    println!(</span><span style="color:#183691;">&quot;max compressed length of a 100 byte buffer: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, x);
}
</span></pre><p id = "para-1662">The <code>extern</code> block is a list of function signatures in a foreign library, in this case with the platform’s C ABI. The <code>#[link(...)]</code> attribute is used to instruct the linker to link against the snappy library so the symbols are resolved.</p>
<p id = "para-1663">Foreign functions are assumed to be unsafe so calls to them need to be wrapped with <code>unsafe {}</code> as a promise to the compiler that everything contained within truly is safe. C libraries often expose interfaces that aren’t thread-safe, and almost any function that takes a pointer argument isn’t valid for all possible inputs since the pointer could be dangling, and raw pointers fall outside of Rust’s safe memory model.</p>
<p id = "para-1664">When declaring the argument types to a foreign function, the Rust compiler cannot check if the declaration is correct, so specifying it correctly is part of keeping the binding correct at runtime.</p>
<p id = "para-1665">The <code>extern</code> block can be extended to cover the entire snappy API:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">libc::{</span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">};

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;snappy&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_compress</span><span style="color:#323232;">(input: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
                       input_length: size_t,
                       compressed: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
                       compressed_length: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompress</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
                         compressed_length: size_t,
                         uncompressed: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
                         uncompressed_length: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_max_compressed_length</span><span style="color:#323232;">(source_length: size_t) -&gt; size_t;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompressed_length</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
                                  compressed_length: size_t,
                                  result: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int;
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">snappy_validate_compressed_buffer</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
                                         compressed_length: size_t) -&gt; c_int;
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><h2 id = "link-340">Creating a safe interface</h2>
<p id = "para-1666">The raw C API needs to be wrapped to provide memory safety and make use of higher-level concepts like vectors. A library can choose to expose only the safe, high-level interface and hide the unsafe internal details.</p>
<p id = "para-1667">Wrapping the functions which expect buffers involves using the <code>slice::raw</code> module to manipulate Rust vectors as pointers to memory. Rust’s vectors are guaranteed to be a contiguous block of memory. The length is the number of elements currently contained, and the capacity is the total size in elements of the allocated memory. The length is less than or equal to the capacity.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">libc::{</span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_validate_compressed_buffer</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">: size_t) -&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">validate_compressed_buffer</span><span style="color:#323232;">(src: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">]) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">bool </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">snappy_validate_compressed_buffer</span><span style="color:#323232;">(src.</span><span style="color:#62a35c;">as_ptr</span><span style="color:#323232;">(), src.</span><span style="color:#62a35c;">len</span><span style="color:#323232;">() </span><span style="font-weight:bold;color:#a71d5d;">as size_t</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0
    </span><span style="color:#323232;">}
}
</span></pre><p id = "para-1668">The <code>validate_compressed_buffer</code> wrapper above makes use of an <code>unsafe</code> block, but it makes the guarantee that calling it is safe for all inputs by leaving off <code>unsafe</code> from the function signature.</p>
<p id = "para-1669">The <code>snappy_compress</code> and <code>snappy_uncompress</code> functions are more complex, since a buffer has to be allocated to hold the output too.</p>
<p id = "para-1670">The <code>snappy_max_compressed_length</code> function can be used to allocate a vector with the maximum required capacity to hold the compressed output. The vector can then be passed to the <code>snappy_compress</code> function as an output parameter. An output parameter is also passed to retrieve the true length after compression for setting the length.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">libc::{</span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_compress</span><span style="color:#323232;">(a: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, b: size_t, c: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
#                           d: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_max_compressed_length</span><span style="color:#323232;">(a: size_t) -&gt; size_t { a }
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">compress</span><span style="color:#323232;">(src: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">]) -&gt; Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> srclen </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> src.</span><span style="color:#62a35c;">len</span><span style="color:#323232;">() </span><span style="font-weight:bold;color:#a71d5d;">as size_t</span><span style="color:#323232;">;
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> psrc </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> src.</span><span style="color:#62a35c;">as_ptr</span><span style="color:#323232;">();

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> dstlen </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">snappy_max_compressed_length</span><span style="color:#323232;">(srclen);
        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> dst </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::with_capacity(dstlen </span><span style="font-weight:bold;color:#a71d5d;">as usize</span><span style="color:#323232;">);
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> pdst </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> dst.</span><span style="color:#62a35c;">as_mut_ptr</span><span style="color:#323232;">();

        </span><span style="color:#62a35c;">snappy_compress</span><span style="color:#323232;">(psrc, srclen, pdst, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> dstlen);
        dst.</span><span style="color:#62a35c;">set_len</span><span style="color:#323232;">(dstlen </span><span style="font-weight:bold;color:#a71d5d;">as usize</span><span style="color:#323232;">);
        dst
    }
}
</span></pre><p id = "para-1671">Decompression is similar, because snappy stores the uncompressed size as part of the compression format and <code>snappy_uncompressed_length</code> will retrieve the exact buffer size required.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">libc::{</span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompress</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                             compressed_length: size_t,
#                             uncompressed: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
#                             uncompressed_length: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompressed_length</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                                      compressed_length: size_t,
#                                      result: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t) -&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">uncompress</span><span style="color:#323232;">(src: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">]) -&gt; Option&lt;Vec&lt;</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">&gt;&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> srclen </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> src.</span><span style="color:#62a35c;">len</span><span style="color:#323232;">() </span><span style="font-weight:bold;color:#a71d5d;">as size_t</span><span style="color:#323232;">;
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> psrc </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> src.</span><span style="color:#62a35c;">as_ptr</span><span style="color:#323232;">();

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> dstlen: </span><span style="font-weight:bold;color:#a71d5d;">size_t = </span><span style="color:#0086b3;">0</span><span style="color:#323232;">;
        </span><span style="color:#62a35c;">snappy_uncompressed_length</span><span style="color:#323232;">(psrc, srclen, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> dstlen);

        </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> dst </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Vec</span><span style="color:#323232;">::with_capacity(dstlen </span><span style="font-weight:bold;color:#a71d5d;">as usize</span><span style="color:#323232;">);
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> pdst </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> dst.</span><span style="color:#62a35c;">as_mut_ptr</span><span style="color:#323232;">();

        </span><span style="font-weight:bold;color:#a71d5d;">if </span><span style="color:#62a35c;">snappy_uncompress</span><span style="color:#323232;">(psrc, srclen, pdst, </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> dstlen) </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">{
            dst.</span><span style="color:#62a35c;">set_len</span><span style="color:#323232;">(dstlen </span><span style="font-weight:bold;color:#a71d5d;">as usize</span><span style="color:#323232;">);
            </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(dst)
        } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
            </span><span style="color:#0086b3;">None </span><span style="font-style:italic;color:#969896;">// SNAPPY_INVALID_INPUT
        </span><span style="color:#323232;">}
    }
}
</span></pre><p id = "para-1672">Then, we can add some tests to show how to use them.</p>
<pre><span style="font-weight:bold;color:#a71d5d;"># extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;"># use </span><span style="color:#323232;">libc::{</span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">, </span><span style="font-weight:bold;color:#a71d5d;">size_t</span><span style="color:#323232;">};
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_compress</span><span style="color:#323232;">(input: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                           input_length: size_t,
#                           compressed: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
#                           compressed_length: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t)
</span><span style="font-weight:bold;color:#a71d5d;">#                           </span><span style="color:#323232;">-&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompress</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                             compressed_length: size_t,
#                             uncompressed: *</span><span style="font-weight:bold;color:#a71d5d;">mut u8</span><span style="color:#323232;">,
#                             uncompressed_length: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t)
</span><span style="font-weight:bold;color:#a71d5d;">#                             </span><span style="color:#323232;">-&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_max_compressed_length</span><span style="color:#323232;">(source_length: size_t) -&gt; size_t { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_uncompressed_length</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                                      compressed_length: size_t,
#                                      result: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> size_t)
</span><span style="font-weight:bold;color:#a71d5d;">#                                      </span><span style="color:#323232;">-&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">snappy_validate_compressed_buffer</span><span style="color:#323232;">(compressed: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">,
#                                             compressed_length: size_t)
</span><span style="font-weight:bold;color:#a71d5d;">#                                             </span><span style="color:#323232;">-&gt; c_int { </span><span style="color:#0086b3;">0 </span><span style="color:#323232;">}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() { }

#[cfg(test)]
</span><span style="font-weight:bold;color:#a71d5d;">mod </span><span style="color:#323232;">tests {
    </span><span style="font-weight:bold;color:#a71d5d;">use super</span><span style="color:#323232;">::</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">;

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">valid</span><span style="color:#323232;">() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> d </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">0xde</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0xad</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0xd0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0x0d</span><span style="color:#323232;">];
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">[</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">] </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#62a35c;">compress</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d);
        assert!(</span><span style="color:#62a35c;">validate_compressed_buffer</span><span style="color:#323232;">(c));
        assert!(</span><span style="color:#62a35c;">uncompress</span><span style="color:#323232;">(c) </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(d));
    }

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">invalid</span><span style="color:#323232;">() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> d </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![</span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">, </span><span style="color:#0086b3;">0</span><span style="color:#323232;">];
        assert!(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#62a35c;">validate_compressed_buffer</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d));
        assert!(</span><span style="color:#62a35c;">uncompress</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d).</span><span style="color:#62a35c;">is_none</span><span style="color:#323232;">());
    }

    #[test]
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">empty</span><span style="color:#323232;">() {
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> d </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">vec![];
        assert!(</span><span style="font-weight:bold;color:#a71d5d;">!</span><span style="color:#62a35c;">validate_compressed_buffer</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d));
        assert!(</span><span style="color:#62a35c;">uncompress</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d).</span><span style="color:#62a35c;">is_none</span><span style="color:#323232;">());
        </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> c </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">compress</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">d);
        assert!(</span><span style="color:#62a35c;">validate_compressed_buffer</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">c));
        assert!(</span><span style="color:#62a35c;">uncompress</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">c) </span><span style="font-weight:bold;color:#a71d5d;">== </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(d));
    }
}
</span></pre><h2 id = "link-341">Destructors</h2>
<p id = "para-1673">Foreign libraries often hand off ownership of resources to the calling code. When this occurs, we must use Rust’s destructors to provide safety and guarantee the release of these resources (especially in the case of panic).</p>
<p id = "para-1674">For more about destructors, see the <a href = "src/../../std/ops/trait.Drop.html">Drop trait</a>.</p>
<h2 id = "link-342">Callbacks from C code to Rust functions</h2>
<p id = "para-1675">Some external libraries require the usage of callbacks to report back their current state or intermediate data to the caller. It is possible to pass functions defined in Rust to an external library. The requirement for this is that the callback function is marked as <code>extern</code> with the correct calling convention to make it callable from C code.</p>
<p id = "para-1676">The callback function can then be sent through a registration call to the C library and afterwards be invoked from there.</p>
<p id = "para-1677">A basic example is:</p>
<p id = "para-1678">Rust code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern fn </span><span style="font-weight:bold;color:#795da3;">callback</span><span style="color:#323232;">(a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;I&#39;m called from C with value </span><span style="color:#0086b3;">{0}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a);
}

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;extlib&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
   </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">register_callback</span><span style="color:#323232;">(cb: extern </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">)) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;
   </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">trigger_callback</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">register_callback</span><span style="color:#323232;">(callback);
        </span><span style="color:#62a35c;">trigger_callback</span><span style="color:#323232;">(); </span><span style="font-style:italic;color:#969896;">// Triggers the callback.
    </span><span style="color:#323232;">}
}
</span></pre><p id = "para-1679">C code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">typedef void </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">rust_callback)(</span><span style="color:#0086b3;">int32_t</span><span style="color:#323232;">);
rust_callback cb;

</span><span style="color:#0086b3;">int32_t </span><span style="font-weight:bold;color:#795da3;">register_callback</span><span style="color:#323232;">(rust_callback callback) {
    cb </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> callback;
    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">trigger_callback</span><span style="color:#323232;">() {
  cb(</span><span style="color:#0086b3;">7</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// Will call callback(7) in Rust.
</span><span style="color:#323232;">}
</span></pre><p id = "para-1680">In this example Rust’s <code>main()</code> will call <code>trigger_callback()</code> in C, which would, in turn, call back to <code>callback()</code> in Rust.</p>
<h3 id = "link-343">Targeting callbacks to Rust objects</h3>
<p id = "para-1681">The former example showed how a global function can be called from C code. However it is often desired that the callback is targeted to a special Rust object. This could be the object that represents the wrapper for the respective C object.</p>
<p id = "para-1682">This can be achieved by passing a raw pointer to the object down to the C library. The C library can then include the pointer to the Rust object in the notification. This will allow the callback to unsafely access the referenced Rust object.</p>
<p id = "para-1683">Rust code:</p>
<pre><span style="color:#323232;">#[repr(C)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">RustObject {
    a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    </span><span style="font-style:italic;color:#969896;">// Other members...
</span><span style="color:#323232;">}

</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">callback</span><span style="color:#323232;">(target: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> RustObject, a: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) {
    println!(</span><span style="color:#183691;">&quot;I&#39;m called from C with value </span><span style="color:#0086b3;">{0}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a);
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Update the value in RustObject with the value received from the callback:
        </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">target).a </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> a;
    }
}

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;extlib&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
   </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">register_callback</span><span style="color:#323232;">(target: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> RustObject,
                        cb: extern </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(*</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> RustObject, </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">)) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">;
   </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">trigger_callback</span><span style="color:#323232;">();
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-style:italic;color:#969896;">// Create the object that will be referenced in the callback:
    </span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> rust_object </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">Box</span><span style="color:#323232;">::new(RustObject { a: </span><span style="color:#0086b3;">5 </span><span style="color:#323232;">});

    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">register_callback</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut *</span><span style="color:#323232;">rust_object, callback);
        </span><span style="color:#62a35c;">trigger_callback</span><span style="color:#323232;">();
    }
}
</span></pre><p id = "para-1684">C code:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">typedef void </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">rust_callback)(</span><span style="font-weight:bold;color:#a71d5d;">void*</span><span style="color:#323232;">, </span><span style="color:#0086b3;">int32_t</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">void*</span><span style="color:#323232;"> cb_target;
rust_callback cb;

</span><span style="color:#0086b3;">int32_t </span><span style="font-weight:bold;color:#795da3;">register_callback</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">void* </span><span style="color:#323232;">callback_target, rust_callback callback) {
    cb_target </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> callback_target;
    cb </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> callback;
    </span><span style="font-weight:bold;color:#a71d5d;">return </span><span style="color:#0086b3;">1</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">trigger_callback</span><span style="color:#323232;">() {
  cb(cb_target, </span><span style="color:#0086b3;">7</span><span style="color:#323232;">); </span><span style="font-style:italic;color:#969896;">// Will call callback(&amp;rustObject, 7) in Rust.
</span><span style="color:#323232;">}
</span></pre><h3 id = "link-344">Asynchronous callbacks</h3>
<p id = "para-1685">In the previously given examples the callbacks are invoked as a direct reaction to a function call to the external C library. The control over the current thread is switched from Rust to C to Rust for the execution of the callback, but in the end the callback is executed on the same thread that called the function which triggered the callback.</p>
<p id = "para-1686">Things get more complicated when the external library spawns its own threads and invokes callbacks from there. In these cases access to Rust data structures inside the callbacks is especially unsafe and proper synchronization mechanisms must be used. Besides classical synchronization mechanisms like mutexes, one possibility in Rust is to use channels (in <code>std::sync::mpsc</code>) to forward data from the C thread that invoked the callback into a Rust thread.</p>
<p id = "para-1687">If an asynchronous callback targets a special object in the Rust address space it is also absolutely necessary that no more callbacks are performed by the C library after the respective Rust object gets destroyed. This can be achieved by unregistering the callback in the object’s destructor and designing the library in a way that guarantees that no callback will be performed after deregistration.</p>
<h2 id = "link-345">Linking</h2>
<p id = "para-1688">The <code>link</code> attribute on <code>extern</code> blocks provides the basic building block for instructing rustc how it will link to native libraries. There are two accepted forms of the link attribute today:</p>
<ul>
<li><code>#[link(name = “foo”)]</code></li>
<li><code>#[link(name = “foo”, kind = “bar”)]</code></li>
</ul>
<p id = "para-1689">In both of these cases, <code>foo</code> is the name of the native library that we’re linking to, and in the second case <code>bar</code> is the type of native library that the compiler is linking to. There are currently three known types of native libraries:</p>
<ul>
<li>Dynamic - <code>#[link(name = “readline”)]</code></li>
<li>Static - <code>#[link(name = “my_build_dependency”, kind = “static”)]</code></li>
<li>Frameworks - <code>#[link(name = “CoreFoundation”, kind = “framework”)]</code></li>
</ul>
<p id = "para-1690">Note that frameworks are only available on macOS targets.</p>
<p id = "para-1691">The different <code>kind</code> values are meant to differentiate how the native library participates in linkage. From a linkage perspective, the Rust compiler creates two flavors of artifacts: partial (rlib/staticlib) and final (dylib/binary). Native dynamic library and framework dependencies are propagated to the final artifact boundary, while static library dependencies are not propagated at all, because the static libraries are integrated directly into the subsequent artifact.</p>
<p id = "para-1692">A few examples of how this model can be used are:</p>
<ul>
<li><p id = "para-1693">A native build dependency. Sometimes some C/C++ glue is needed when writing some Rust code, but distribution of the C/C++ code in a library format is a burden. In this case, the code will be archived into <code>libfoo.a</code> and then the Rust crate would declare a dependency via <code>#[link(name = “foo”, kind = “static”)]</code>.</p>
<p id = "para-1694">Regardless of the flavor of output for the crate, the native static library will be included in the output, meaning that distribution of the native static library is not necessary.</p>
</li>
<li><p id = "para-1695">A normal dynamic dependency. Common system libraries (like <code>readline</code>) are available on a large number of systems, and often a static copy of these libraries cannot be found. When this dependency is included in a Rust crate, partial targets (like rlibs) will not link to the library, but when the rlib is included in a final target (like a binary), the native library will be linked in.</p>
</li>
</ul>
<p id = "para-1696">On macOS, frameworks behave with the same semantics as a dynamic library.</p>
<h2 id = "link-346">Unsafe blocks</h2>
<p id = "para-1697">Some operations, like dereferencing raw pointers or calling functions that have been marked unsafe are only allowed inside unsafe blocks. Unsafe blocks isolate unsafety and are a promise to the compiler that the unsafety does not leak out of the block.</p>
<p id = "para-1698">Unsafe functions, on the other hand, advertise it to the world. An unsafe function is written like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">unsafe fn </span><span style="font-weight:bold;color:#795da3;">kaboom</span><span style="color:#323232;">(ptr: *const </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{ </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">ptr }
</span></pre><p id = "para-1699">This function can only be called from an <code>unsafe</code> block or another <code>unsafe</code> function.</p>
<h2 id = "link-347">Accessing foreign globals</h2>
<p id = "para-1700">Foreign APIs often export a global variable which could do something like track global state. In order to access these variables, you declare them in <code>extern</code> blocks with the <code>static</code> keyword:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;readline&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">static</span><span style="color:#323232;"> rl_readline_version: libc::</span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    println!(</span><span style="color:#183691;">&quot;You have readline version </span><span style="color:#0086b3;">{}</span><span style="color:#183691;"> installed.&quot;</span><span style="color:#323232;">,
             </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{ rl_readline_version </span><span style="font-weight:bold;color:#a71d5d;">as i32 </span><span style="color:#323232;">});
}
</span></pre><p id = "para-1701">Alternatively, you may need to alter global state provided by a foreign interface. To do this, statics can be declared with <code>mut</code> so we can mutate them.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::ffi::CString;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::ptr;

#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;readline&quot;</span><span style="color:#323232;">)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">static mut</span><span style="color:#323232;"> rl_prompt: </span><span style="font-weight:bold;color:#a71d5d;">*const </span><span style="color:#323232;">libc::</span><span style="font-weight:bold;color:#a71d5d;">c_char</span><span style="color:#323232;">;
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> prompt </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">CString::new(</span><span style="color:#183691;">&quot;[my-awesome-shell] $&quot;</span><span style="color:#323232;">).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        rl_prompt </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> prompt.</span><span style="color:#62a35c;">as_ptr</span><span style="color:#323232;">();

        println!(</span><span style="color:#183691;">&quot;</span><span style="color:#0086b3;">{:?}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, rl_prompt);

        rl_prompt </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">ptr::null();
    }
}
</span></pre><p id = "para-1702">Note that all interaction with a <code>static mut</code> is unsafe, both reading and writing. Dealing with global mutable state requires a great deal of care.</p>
<h2 id = "link-348">Foreign calling conventions</h2>
<p id = "para-1703">Most foreign code exposes a C ABI, and Rust uses the platform’s C calling convention by default when calling foreign functions. Some foreign functions, most notably the Windows API, use other calling conventions. Rust provides a way to tell the compiler which convention to use:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;

#[cfg(all(target_os </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;win32&quot;</span><span style="color:#323232;">, target_arch </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;x86&quot;</span><span style="color:#323232;">))]
#[link(name </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;kernel32&quot;</span><span style="color:#323232;">)]
#[allow(non_snake_case)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;stdcall&quot; </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">SetEnvironmentVariableA</span><span style="color:#323232;">(n: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">, v: *const </span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">) -&gt; libc::c_int;
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() { }
</span></pre><p id = "para-1704">This applies to the entire <code>extern</code> block. The list of supported ABI constraints are:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>vectorcall</code> This is currently hidden behind the <code>abi_vectorcall</code> gate and is subject to change.</li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
<li><code>sysv64</code></li>
</ul>
<p id = "para-1705">Most of the ABIs in this list are self-explanatory, but the <code>system</code> ABI may seem a little odd. This constraint selects whatever the appropriate ABI is for interoperating with the target’s libraries. For example, on win32 with a x86 architecture, this means that the ABI used would be <code>stdcall</code>. On x86_64, however, windows uses the <code>C</code> calling convention, so <code>C</code> would be used. This means that in our previous example, we could have used <code>extern “system” { ... }</code> to define a block for all windows systems, not only x86 ones.</p>
<h2 id = "link-349">Interoperability with foreign code</h2>
<p id = "para-1706">Rust guarantees that the layout of a <code>struct</code> is compatible with the platform’s representation in C only if the <code>#[repr(C)]</code> attribute is applied to it. <code>#[repr(C, packed)]</code> can be used to lay out struct members without padding. <code>#[repr(C)]</code> can also be applied to an enum.</p>
<p id = "para-1707">Rust’s owned boxes (<code>Box&lt;T&gt;</code>) use non-nullable pointers as handles which point to the contained object. However, they should not be manually created because they are managed by internal allocators. References can safely be assumed to be non-nullable pointers directly to the type. However, breaking the borrow checking or mutability rules is not guaranteed to be safe, so prefer using raw pointers (<code>*</code>) if that’s needed because the compiler can’t make as many assumptions about them.</p>
<p id = "para-1708">Vectors and strings share the same basic memory layout, and utilities are available in the <code>vec</code> and <code>str</code> modules for working with C APIs. However, strings are not terminated with <code>\0</code>. If you need a NUL-terminated string for interoperability with C, you should use the <code>CString</code> type in the <code>std::ffi</code> module.</p>
<p id = "para-1709">The <a href = "https://crates.io/crates/libc"><code>libc</code> crate on crates.io</a> includes type aliases and function definitions for the C standard library in the <code>libc</code> module, and Rust links against <code>libc</code> and <code>libm</code> by default.</p>
<h2 id = "link-350">Variadic functions</h2>
<p id = "para-1710">In C, functions can be ‘variadic’, meaning they accept a variable number of arguments. This can be achieved in Rust by specifying <code>...</code> within the argument list of a foreign function declaration:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, ...);
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="color:#0086b3;">10</span><span style="color:#323232;">, </span><span style="color:#0086b3;">20</span><span style="color:#323232;">, </span><span style="color:#0086b3;">30</span><span style="color:#323232;">, </span><span style="color:#0086b3;">40</span><span style="color:#323232;">, </span><span style="color:#0086b3;">50</span><span style="color:#323232;">);
    }
}
</span></pre><p id = "para-1711">Normal Rust functions can <em>not</em> be variadic:</p>
<pre><span style="font-style:italic;color:#969896;">// This will not compile

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">, ...) { }
</span></pre><h2 id = "link-351">The “nullable pointer optimization”</h2>
<p id = "para-1712">Certain Rust types are defined to never be <code>null</code>. This includes references (<code>&amp;T</code>, <code>&amp;mut T</code>), boxes (<code>Box&lt;T&gt;</code>), and function pointers (<code>extern “abi” fn()</code>). When interfacing with C, pointers that might be <code>null</code> are often used, which would seem to require some messy <code>transmute</code>s and/or unsafe code to handle conversions to/from Rust types. However, the language provides a workaround.</p>
<p id = "para-1713">As a special case, an <code>enum</code> is eligible for the “nullable pointer optimization” if it contains exactly two variants, one of which contains no data and the other contains a field of one of the non-nullable types listed above. This means no extra space is required for a discriminant; rather, the empty variant is represented by putting a <code>null</code> value into the non-nullable field. This is called an “optimization”, but unlike other optimizations it is guaranteed to apply to eligible types.</p>
<p id = "para-1714">The most common type that takes advantage of the nullable pointer optimization is <code>Option&lt;T&gt;</code>, where <code>None</code> corresponds to <code>null</code>. So <code>Option&lt;extern “C” fn(c_int) -&gt; c_int&gt;</code> is a correct way to represent a nullable function pointer using the C ABI (corresponding to the C type <code>int (*)(int)</code>).</p>
<p id = "para-1715">Here is a contrived example. Let’s say some C library has a facility for registering a callback, which gets called in certain situations. The callback is passed a function pointer and an integer and it is supposed to run the function with the integer as a parameter. So we have function pointers flying across the FFI boundary in both directions.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">libc::</span><span style="font-weight:bold;color:#a71d5d;">c_int</span><span style="color:#323232;">;

</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">#[cfg(hidden)]
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="color:#323232;">{
    </span><span style="font-style:italic;color:#969896;">/// Registers the callback.
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">register</span><span style="color:#323232;">(cb: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(c_int) -&gt; c_int&gt;, c_int) -&gt; c_int&gt;);
}
</span><span style="font-weight:bold;color:#a71d5d;"># unsafe fn </span><span style="font-weight:bold;color:#795da3;">register</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(c_int) -&gt; c_int&gt;,
#                                            c_int) -&gt; c_int&gt;)
</span><span style="font-weight:bold;color:#a71d5d;"># </span><span style="color:#323232;">{}

</span><span style="font-style:italic;color:#969896;">/// This fairly useless function receives a function pointer and an integer
/// from C, and returns the result of calling the function with the integer.
/// In case no function is provided, it squares the integer by default.
</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">apply</span><span style="color:#323232;">(process: Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="font-weight:bold;color:#a71d5d;">fn</span><span style="color:#323232;">(c_int) -&gt; c_int&gt;, int: c_int) -&gt; c_int {
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> process {
        </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(f) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#62a35c;">f</span><span style="color:#323232;">(int),
        </span><span style="color:#0086b3;">None    </span><span style="font-weight:bold;color:#a71d5d;">=&gt;</span><span style="color:#323232;"> int </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;"> int
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    </span><span style="font-weight:bold;color:#a71d5d;">unsafe </span><span style="color:#323232;">{
        </span><span style="color:#62a35c;">register</span><span style="color:#323232;">(</span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(apply));
    }
}
</span></pre><p id = "para-1716">And the code on the C side looks like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">void register</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">f)(</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">)(</span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;">), </span><span style="font-weight:bold;color:#a71d5d;">int</span><span style="color:#323232;">)) {
    </span><span style="font-weight:bold;color:#a71d5d;">...
</span><span style="color:#323232;">}
</span></pre><p id = "para-1717">No <code>transmute</code> required!</p>
<h2 id = "link-352">Calling Rust code from C</h2>
<p id = "para-1718">You may wish to compile Rust code in a way so that it can be called from C. This is fairly easy, but requires a few things:</p>
<pre><span style="color:#323232;">#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub extern fn </span><span style="font-weight:bold;color:#795da3;">hello_rust</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">*const u8 </span><span style="color:#323232;">{
    </span><span style="color:#183691;">&quot;Hello, world!</span><span style="color:#0086b3;">\0</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">as_ptr</span><span style="color:#323232;">()
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1719">The <code>extern</code> makes this function adhere to the C calling convention, as discussed above in "<a href = "#chapter-54">Foreign Calling Conventions</a>“. The <code>no_mangle</code> attribute turns off Rust’s name mangling, so that it is easier to link to.</p>
<h2 id = "link-353">FFI and panics</h2>
<p id = "para-1720">It’s important to be mindful of <code>panic!</code>s when working with FFI. A <code>panic!</code> across an FFI boundary is undefined behavior. If you’re writing code that may panic, you should run it in a closure with <a href = "src/../../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::panic::catch_unwind;

#[no_mangle]
</span><span style="font-weight:bold;color:#a71d5d;">pub extern fn </span><span style="font-weight:bold;color:#795da3;">oh_no</span><span style="color:#323232;">() -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> result </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">catch_unwind</span><span style="color:#323232;">(|| {
        panic!(</span><span style="color:#183691;">&quot;Oops!&quot;</span><span style="color:#323232;">);
    });
    </span><span style="font-weight:bold;color:#a71d5d;">match</span><span style="color:#323232;"> result {
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">0</span><span style="color:#323232;">,
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=&gt; </span><span style="color:#0086b3;">1</span><span style="color:#323232;">,
    }
}

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1721">Please note that <a href = "src/../../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> will only catch unwinding panics, not those who abort the process. See the documentation of <a href = "src/../../std/panic/fn.catch_unwind.html"><code>catch_unwind</code></a> for more information.</p>
<h2 id = "link-354">Representing opaque structs</h2>
<p id = "para-1722">Sometimes, a C library wants to provide a pointer to something, but not let you know the internal details of the thing it wants. The simplest way is to use a <code>void *</code> argument:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">void *</span><span style="color:#323232;">arg);
</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">void *</span><span style="color:#323232;">arg);
</span></pre><p id = "para-1723">We can represent this in Rust with the <code>c_void</code> type:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> libc;

</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(arg: *</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">libc::c_void);
    </span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">(arg: *</span><span style="font-weight:bold;color:#a71d5d;">mut </span><span style="color:#323232;">libc::c_void);
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1724">This is a perfectly valid way of handling the situation. However, we can do a bit better. To solve this, some C libraries will instead create a <code>struct</code>, where the details and memory layout of the struct are private. This gives some amount of type safety. These structures are called ‘opaque’. Here’s an example, in C:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Foo; </span><span style="font-style:italic;color:#969896;">/* Foo is a structure, but its contents are not part of the public interface */
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Bar;
</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> Foo </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">arg);
</span><span style="font-weight:bold;color:#a71d5d;">void </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">struct</span><span style="color:#323232;"> Bar </span><span style="font-weight:bold;color:#a71d5d;">*</span><span style="color:#323232;">arg);
</span></pre><p id = "para-1725">To do this in Rust, let’s create our own opaque types:</p>
<pre><span style="color:#323232;">#[repr(C)] </span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span style="color:#323232;">Foo { private: [</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">; 0] }
#[repr(C)] </span><span style="font-weight:bold;color:#a71d5d;">pub struct </span><span style="color:#323232;">Bar { private: [</span><span style="font-weight:bold;color:#a71d5d;">u8</span><span style="color:#323232;">; 0] }

</span><span style="font-weight:bold;color:#a71d5d;">extern </span><span style="color:#183691;">&quot;C&quot; </span><span style="color:#323232;">{
    </span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">(arg: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> Foo);
    </span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">bar</span><span style="color:#323232;">(arg: *</span><span style="font-weight:bold;color:#a71d5d;">mut</span><span style="color:#323232;"> Bar);
}
</span><span style="font-weight:bold;color:#a71d5d;"># fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {}
</span></pre><p id = "para-1726">By including a private field and no constructor, we create an opaque type that we can’t instantiate outside of this module. An empty array is both zero-size and compatible with <code>#[repr(C)]</code>. But because our <code>Foo</code> and <code>Bar</code> types are different, we’ll get type safety between the two of them, so we cannot accidentally pass a pointer to <code>Foo</code> to <code>bar()</code>.</p>

</div><div id = "chapter-55" class = "chapter">
  <h2 id = "link-355">Borrow and AsRef</h2>
<p id = "para-1727">The <a href = "src/../../std/borrow/trait.Borrow.html"><code>Borrow</code></a> and <a href = "src/../../std/convert/trait.AsRef.html"><code>AsRef</code></a> traits are very similar, but different. Here’s a quick refresher on what these two traits mean.</p>
<h2 id = "link-356">Borrow</h2>
<p id = "para-1728">The <code>Borrow</code> trait is used when you’re writing a data structure, and you want to use either an owned or borrowed type as synonymous for some purpose.</p>
<p id = "para-1729">For example, <a href = "src/../../std/collections/struct.HashMap.html"><code>HashMap</code></a> has a <a href = "src/../../std/collections/struct.HashMap.html#method.get"><code>get</code> method</a> which uses <code>Borrow</code>:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">get</span><span style="color:#323232;">&lt;Q: </span><span style="font-weight:bold;color:#b52a1d;">?</span><span style="color:#0086b3;">Sized</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, k: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">Q) -&gt; Option&lt;</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">V&gt;
    </span><span style="font-weight:bold;color:#a71d5d;">where</span><span style="color:#323232;"> K: Borrow&lt;Q&gt;,
          Q: Hash </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">Eq
</span></pre><p id = "para-1730">This signature is pretty complicated. The <code>K</code> parameter is what we’re interested in here. It refers to a parameter of the <code>HashMap</code> itself:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">HashMap&lt;K, V, S = RandomState&gt; {
</span></pre><p id = "para-1731">The <code>K</code> parameter is the type of <em>key</em> the <code>HashMap</code> uses. So, looking at the signature of <code>get()</code> again, we can use <code>get()</code> when the key implements <code>Borrow&lt;Q&gt;</code>. That way, we can make a <code>HashMap</code> which uses <code>String</code> keys, but use <code>&amp;str</code>s when we’re searching:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::collections::HashMap;

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> map </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">HashMap::new();
map.</span><span style="color:#62a35c;">insert</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Foo&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">(), </span><span style="color:#0086b3;">42</span><span style="color:#323232;">);

assert_eq!(map.</span><span style="color:#62a35c;">get</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;Foo&quot;</span><span style="color:#323232;">), </span><span style="color:#0086b3;">Some</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#0086b3;">42</span><span style="color:#323232;">));
</span></pre><p id = "para-1732">This is because the standard library has <code>impl Borrow&lt;str&gt; for String</code>.</p>
<p id = "para-1733">For most types, when you want to take an owned or borrowed type, a <code>&amp;T</code> is enough. But one area where <code>Borrow</code> is effective is when there’s more than one kind of borrowed value. This is especially true of references and slices: you can have both an <code>&amp;T</code> or a <code>&amp;mut T</code>. If we wanted to accept both of these types, <code>Borrow</code> is up for it:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::borrow::Borrow;
</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt::Display;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: Borrow&lt;</span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">&gt; </span><span style="font-weight:bold;color:#a71d5d;">+</span><span style="color:#323232;"> Display&gt;(a: T) {
    println!(</span><span style="color:#183691;">&quot;a is borrowed: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, a);
}

</span><span style="font-weight:bold;color:#a71d5d;">let mut</span><span style="color:#323232;"> i </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#0086b3;">5</span><span style="color:#323232;">;

</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">i);
</span><span style="color:#62a35c;">foo</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;mut</span><span style="color:#323232;"> i);
</span></pre><p id = "para-1734">This will print out <code>a is borrowed: 5</code> twice.</p>
<h2 id = "link-357">AsRef</h2>
<p id = "para-1735">The <code>AsRef</code> trait is a conversion trait. It’s used for converting some value to a reference in generic code. Like this:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;Hello&quot;</span><span style="color:#323232;">.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">foo</span><span style="color:#323232;">&lt;T: AsRef&lt;</span><span style="font-weight:bold;color:#a71d5d;">str</span><span style="color:#323232;">&gt;&gt;(s: T) {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> slice </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> s.</span><span style="color:#62a35c;">as_ref</span><span style="color:#323232;">();
}
</span></pre><h2 id = "link-358">Which should I use?</h2>
<p id = "para-1736">We can see how they’re kind of the same: they both deal with owned and borrowed versions of some type. However, they’re a bit different.</p>
<p id = "para-1737">Choose <code>Borrow</code> when you want to abstract over different kinds of borrowing, or when you’re building a data structure that treats owned and borrowed values in equivalent ways, such as hashing and comparison.</p>
<p id = "para-1738">Choose <code>AsRef</code> when you want to convert something to a reference directly, and you’re writing generic code.</p>

</div><div id = "chapter-56" class = "chapter">
  <h2 id = "link-359">Release Channels</h2>
<p id = "para-1739">The Rust project uses a concept called ‘release channels’ to manage releases. It’s important to understand this process to choose which version of Rust your project should use.</p>
<h2 id = "link-360">Overview</h2>
<p id = "para-1740">There are three channels for Rust releases:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p id = "para-1741">New nightly releases are created once a day. Every six weeks, the latest nightly release is promoted to ‘Beta’. At that point, it will only receive patches to fix serious errors. Six weeks later, the beta is promoted to ‘Stable’, and becomes the next release of <code>1.x</code>.</p>
<p id = "para-1742">This process happens in parallel. So every six weeks, on the same day, nightly goes to beta, beta goes to stable. When <code>1.x</code> is released, at the same time, <code>1.(x + 1)-beta</code> is released, and the nightly becomes the first version of <code>1.(x + 2)-nightly</code>.</p>
<h2 id = "link-361">Choosing a version</h2>
<p id = "para-1743">Generally speaking, unless you have a specific reason, you should be using the stable release channel. These releases are intended for a general audience.</p>
<p id = "para-1744">However, depending on your interest in Rust, you may choose to use nightly instead. The basic trade-off is this: in the nightly channel, you can use unstable, new Rust features. However, unstable features are subject to change, and so any new nightly release may break your code. If you use the stable release, you cannot use experimental features, but the next release of Rust will not cause significant issues through breaking changes.</p>
<h2 id = "link-362">Helping the ecosystem through CI</h2>
<p id = "para-1745">What about beta? We encourage all Rust users who use the stable release channel to also test against the beta channel in their continuous integration systems. This will help alert the team in case there’s an accidental regression.</p>
<p id = "para-1746">Additionally, testing against nightly can catch regressions even sooner, and so if you don’t mind a third build, we’d appreciate testing against all channels.</p>
<p id = "para-1747">As an example, many Rust programmers use <a href = "https://travis-ci.org/">Travis</a> to test their crates, which is free for open source projects. Travis <a href = "http://docs.travis-ci.com/user/languages/rust/">supports Rust directly</a>, and you can use a <code>.travis.yml</code> file like this to test on all channels:</p>
<pre><span style="color:#63a35c;">language</span><span style="color:#323232;">: </span><span style="color:#63a35c;">rust
rust</span><span style="color:#323232;">:
  - </span><span style="color:#63a35c;">nightly
  </span><span style="color:#323232;">- </span><span style="color:#63a35c;">beta
  </span><span style="color:#323232;">- </span><span style="color:#63a35c;">stable

matrix</span><span style="color:#323232;">:
  </span><span style="color:#63a35c;">allow_failures</span><span style="color:#323232;">:
    - </span><span style="color:#63a35c;">rust</span><span style="color:#323232;">: </span><span style="color:#183691;">nightly
</span></pre><p id = "para-1748">With this configuration, Travis will test all three channels, but if something breaks on nightly, it won’t fail your build. A similar configuration is recommended for any CI system, check the documentation of the one you’re using for more details.</p>

</div><div id = "chapter-57" class = "chapter">
  <h2 id = "link-363">Using Rust Without the Standard Library</h2>
<p id = "para-1749">Rust’s standard library provides a lot of useful functionality, but assumes support for various features of its host system: threads, networking, heap allocation, and others. There are systems that do not have these features, however, and Rust can work with those too! To do so, we tell Rust that we don’t want to use the standard library via an attribute: <code>#![no_std]</code>.</p>
<blockquote><p id = "para-1750">Note: This feature is technically stable, but there are some caveats. For one, you can build a <code>#![no_std]</code> <em>library</em> on stable, but not a <em>binary</em>. For details on binaries without the standard library, see <a href = "src/../../unstable-book/language-features/lang-items.html#using-libc">the nightly chapter on ‘lang items’</a></p>
</blockquote>
<p id = "para-1751">To use <code>#![no_std]</code>, add it to your crate root:</p>
<pre><span style="color:#323232;">#![no_std]

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">plus_one</span><span style="color:#323232;">(x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">) -&gt; </span><span style="font-weight:bold;color:#a71d5d;">i32 </span><span style="color:#323232;">{
    x </span><span style="font-weight:bold;color:#a71d5d;">+ </span><span style="color:#0086b3;">1
</span><span style="color:#323232;">}
</span></pre><p id = "para-1752">Much of the functionality that’s exposed in the standard library is also available via the <a href = "src/../../core/index.html"><code>core</code> crate</a>. When we’re using the standard library, Rust automatically brings <code>std</code> into scope, allowing you to use its features without an explicit import. By the same token, when using <code>#![no_std]</code>, Rust will bring <code>core</code> into scope for you, as well as <a href = "src/../../core/prelude/v1/index.html">its prelude</a>. This means that a lot of code will Just Work:</p>
<pre><span style="color:#323232;">#![no_std]

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">may_fail</span><span style="color:#323232;">(failure: </span><span style="font-weight:bold;color:#a71d5d;">bool</span><span style="color:#323232;">) -&gt; Result&lt;(), </span><span style="font-weight:bold;color:#a71d5d;">&amp;&#39;static str</span><span style="color:#323232;">&gt; {
    </span><span style="font-weight:bold;color:#a71d5d;">if</span><span style="color:#323232;"> failure {
        </span><span style="color:#0086b3;">Err</span><span style="color:#323232;">(</span><span style="color:#183691;">&quot;this didn’t work!&quot;</span><span style="color:#323232;">)
    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
        </span><span style="color:#0086b3;">Ok</span><span style="color:#323232;">(())
    }
}
</span></pre>
</div><div id = "chapter-58" class = "chapter">
  <h2 id = "link-364">Procedural Macros (and custom Derive)</h2>
<p id = "para-1753">As you’ve seen throughout the rest of the book, Rust provides a mechanism called “derive” that lets you implement traits easily. For example,</p>
<pre><span style="color:#323232;">#[derive(Debug)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}
</span></pre><p id = "para-1754">is a lot simpler than</p>
<pre><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Point {
    x: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
    y: </span><span style="font-weight:bold;color:#a71d5d;">i32</span><span style="color:#323232;">,
}

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">std::fmt;

</span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">fmt::Debug </span><span style="font-weight:bold;color:#a71d5d;">for </span><span style="color:#323232;">Point {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">fmt</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">self, f: </span><span style="font-weight:bold;color:#a71d5d;">&amp;mut </span><span style="color:#323232;">fmt::Formatter) -&gt; fmt::Result {
        write!(f, </span><span style="color:#183691;">&quot;Point </span><span style="color:#0086b3;">{{</span><span style="color:#183691;"> x: </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">, y: </span><span style="color:#0086b3;">{} }}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, self.x, self.y)
    }
}
</span></pre><p id = "para-1755">Rust includes several traits that you can derive, but it also lets you define your own. We can accomplish this task through a feature of Rust called “procedural macros.” Eventually, procedural macros will allow for all sorts of advanced metaprogramming in Rust, but today, they’re only for custom derive.</p>
<p id = "para-1756">Let’s build a very simple trait, and derive it with custom derive.</p>
<h3 id = "link-365">Hello World</h3>
<p id = "para-1757">So the first thing we need to do is start a new crate for our project.</p>
<pre><span style="color:#323232;">$ cargo new --bin hello-world
</span></pre><p id = "para-1758">All we want is to be able to call <code>hello_world()</code> on a derived type. Something like this:</p>
<pre><span style="color:#323232;">#[derive(HelloWorld)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Pancakes;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    Pancakes::hello_world();
}
</span></pre><p id = "para-1759">With some kind of nice output, like <code>Hello, World! My name is Pancakes.</code>.</p>
<p id = "para-1760">Let’s go ahead and write up what we think our macro will look like from a user perspective. In <code>src/main.rs</code> we write:</p>
<pre><span style="color:#323232;">#[macro_use]
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> hello_world_derive;

</span><span style="font-weight:bold;color:#a71d5d;">trait </span><span style="color:#323232;">HelloWorld {
    </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">hello_world</span><span style="color:#323232;">();
}

#[derive(HelloWorld)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">FrenchToast;

#[derive(HelloWorld)]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Waffles;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    FrenchToast::hello_world();
    Waffles::hello_world();
}
</span></pre><p id = "para-1761">Great. So now we just need to actually write the procedural macro. At the moment, procedural macros need to be in their own crate. Eventually, this restriction may be lifted, but for now, it’s required. As such, there’s a convention; for a crate named <code>foo</code>, a custom derive procedural macro is called <code>foo-derive</code>. Let’s start a new crate called <code>hello-world-derive</code> inside our <code>hello-world</code> project.</p>
<pre><span style="color:#323232;">$ cargo new hello-world-derive
</span></pre><p id = "para-1762">To make sure that our <code>hello-world</code> crate is able to find this new crate we’ve created, we’ll add it to our toml:</p>
<pre><span style="color:#323232;">[dependencies]
hello-world-derive = { path = &quot;hello-world-derive&quot; }
</span></pre><p id = "para-1763">As for the source of our <code>hello-world-derive</code> crate, here’s an example:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> proc_macro;
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> syn;
#[macro_use]
</span><span style="font-weight:bold;color:#a71d5d;">extern crate</span><span style="color:#323232;"> quote;

</span><span style="font-weight:bold;color:#a71d5d;">use </span><span style="color:#323232;">proc_macro::TokenStream;

#[proc_macro_derive(HelloWorld)]
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">hello_world</span><span style="color:#323232;">(input: TokenStream) -&gt; TokenStream {
    </span><span style="font-style:italic;color:#969896;">// Construct a string representation of the type definition
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> s </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> input.</span><span style="color:#62a35c;">to_string</span><span style="color:#323232;">();
    
    </span><span style="font-style:italic;color:#969896;">// Parse the string representation
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> ast </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">syn::parse_derive_input(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">s).</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">();

    </span><span style="font-style:italic;color:#969896;">// Build the impl
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> gen </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#62a35c;">impl_hello_world</span><span style="color:#323232;">(</span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">ast);
    
    </span><span style="font-style:italic;color:#969896;">// Return the generated impl
</span><span style="color:#323232;">    gen.</span><span style="color:#62a35c;">parse</span><span style="color:#323232;">().</span><span style="color:#62a35c;">unwrap</span><span style="color:#323232;">()
}
</span></pre><p id = "para-1764">So there is a lot going on here. We have introduced two new crates: <a href = "https://crates.io/crates/syn"><code>syn</code></a> and <a href = "https://crates.io/crates/quote"><code>quote</code></a>. As you may have noticed, <code>input: TokenSteam</code> is immediately converted to a <code>String</code>. This <code>String</code> is a string representation of the Rust code for which we are deriving <code>HelloWorld</code>. At the moment, the only thing you can do with a <code>TokenStream</code> is convert it to a string. A richer API will exist in the future.</p>
<p id = "para-1765">So what we really need is to be able to <em>parse</em> Rust code into something usable. This is where <code>syn</code> comes to play. <code>syn</code> is a crate for parsing Rust code. The other crate we’ve introduced is <code>quote</code>. It’s essentially the dual of <code>syn</code> as it will make generating Rust code really easy. We could write this stuff on our own, but it’s much simpler to use these libraries. Writing a full parser for Rust code is no simple task.</p>
<p id = "para-1766">The comments seem to give us a pretty good idea of our overall strategy. We are going to take a <code>String</code> of the Rust code for the type we are deriving, parse it using <code>syn</code>, construct the implementation of <code>hello_world</code> (using <code>quote</code>), then pass it back to Rust compiler.</p>
<p id = "para-1767">One last note: you’ll see some <code>unwrap()</code>s there. If you want to provide an error for a procedural macro, then you should <code>panic!</code> with the error message. In this case, we’re keeping it as simple as possible.</p>
<p id = "para-1768">Great, so let’s write <code>impl_hello_world(&amp;ast)</code>.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">impl_hello_world</span><span style="color:#323232;">(ast: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">syn::DeriveInput) -&gt; quote::Tokens {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> name </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">ast.ident;
    quote! {
        </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HelloWorld </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> #name {
            </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">hello_world</span><span style="color:#323232;">() {
                println!(</span><span style="color:#183691;">&quot;Hello, World! My name is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, stringify!(</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">name));
            }
        }
    }
}
</span></pre><p id = "para-1769">So this is where quotes comes in. The <code>ast</code> argument is a struct that gives us a representation of our type (which can be either a <code>struct</code> or an <code>enum</code>). Check out the <a href = "https://docs.rs/syn/0.11.11/syn/struct.DeriveInput.html">docs</a>, there is some useful information there. We are able to get the name of the type using <code>ast.ident</code>. The <code>quote!</code> macro lets us write up the Rust code that we wish to return and convert it into <code>Tokens</code>. <code>quote!</code> lets us use some really cool templating mechanics; we simply write <code>#name</code> and <code>quote!</code> will replace it with the variable named <code>name</code>. You can even do some repetition similar to regular macros work. You should check out the <a href = "https://docs.rs/quote">docs</a> for a good introduction.</p>
<p id = "para-1770">So I think that’s it. Oh, well, we do need to add dependencies for <code>syn</code> and <code>quote</code> in the <code>Cargo.toml</code> for <code>hello-world-derive</code>.</p>
<pre><span style="color:#323232;">[dependencies]
syn = &quot;0.11.11&quot;
quote = &quot;0.3.15&quot;
</span></pre><p id = "para-1771">That should be it. Let’s try to compile <code>hello-world</code>.</p>
<pre><span style="color:#323232;">error: the `#[proc_macro_derive]` attribute is only usable with crates of the `proc-macro` crate type
 --</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> hello-world-derive/src/lib.rs:8:3
  </span><span style="font-weight:bold;color:#a71d5d;">|
</span><span style="color:#323232;">8 </span><span style="font-weight:bold;color:#a71d5d;">| </span><span style="font-style:italic;color:#969896;">#[proc_macro_derive(HelloWorld)]
  </span><span style="font-weight:bold;color:#a71d5d;">|   </span><span style="color:#323232;">^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></pre><p id = "para-1772">Oh, so it appears that we need to declare that our <code>hello-world-derive</code> crate is a <code>proc-macro</code> crate type. How do we do this? Like this:</p>
<pre><span style="color:#323232;">[lib]
proc-macro = true
</span></pre><p id = "para-1773">Ok so now, let’s compile <code>hello-world</code>. Executing <code>cargo run</code> now yields:</p>
<pre><span style="color:#323232;">Hello, World! My name is FrenchToast
Hello, World! My name is Waffles
</span></pre><p id = "para-1774">We’ve done it!</p>
<h3 id = "link-366">Custom Attributes</h3>
<p id = "para-1775">In some cases it might make sense to allow users some kind of configuration. For example, the user might want to overwrite the name that is printed in the <code>hello_world()</code> method.</p>
<p id = "para-1776">This can be achieved with custom attributes:</p>
<pre><span style="color:#323232;">#[derive(HelloWorld)]
#[HelloWorldName </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#183691;">&quot;the best Pancakes&quot;</span><span style="color:#323232;">]
</span><span style="font-weight:bold;color:#a71d5d;">struct </span><span style="color:#323232;">Pancakes;

</span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">main</span><span style="color:#323232;">() {
    Pancakes::hello_world();
}
</span></pre><p id = "para-1777">If we try to compile this though, the compiler will respond with an error:</p>
<pre><span style="color:#323232;">error: The attribute `HelloWorldName` is currently unknown to the compiler and may have meaning added to it in the future (see issue </span><span style="font-style:italic;color:#969896;">#29642)
</span></pre><p id = "para-1778">The compiler needs to know that we’re handling this attribute and to not respond with an error. This is done in the <code>hello-world-derive</code> crate by adding <code>attributes</code> to the <code>proc_macro_derive</code> attribute:</p>
<pre><span style="color:#323232;">#[proc_macro_derive(HelloWorld, attributes(HelloWorldName))]
</span><span style="font-weight:bold;color:#a71d5d;">pub fn </span><span style="font-weight:bold;color:#795da3;">hello_world</span><span style="color:#323232;">(input: TokenStream) -&gt; TokenStream 
</span></pre><p id = "para-1779">Multiple attributes can be specified that way.</p>
<h3 id = "link-367">Raising Errors</h3>
<p id = "para-1780">Let’s assume that we do not want to accept enums as input to our custom derive method.</p>
<p id = "para-1781">This condition can be easily checked with the help of <code>syn</code>. But how do we tell the user, that we do not accept enums? The idiomatic way to report errors in procedural macros is to panic:</p>
<pre><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">impl_hello_world</span><span style="color:#323232;">(ast: </span><span style="font-weight:bold;color:#a71d5d;">&amp;</span><span style="color:#323232;">syn::DeriveInput) -&gt; quote::Tokens {
    </span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> name </span><span style="font-weight:bold;color:#a71d5d;">= &amp;</span><span style="color:#323232;">ast.ident;
    </span><span style="font-style:italic;color:#969896;">// Check if derive(HelloWorld) was specified for a struct
    </span><span style="font-weight:bold;color:#a71d5d;">if let </span><span style="color:#323232;">syn::Body::Struct(</span><span style="font-weight:bold;color:#a71d5d;">_</span><span style="color:#323232;">) </span><span style="font-weight:bold;color:#a71d5d;">=</span><span style="color:#323232;"> ast.body {
        </span><span style="font-style:italic;color:#969896;">// Yes, this is a struct
        </span><span style="color:#323232;">quote! {
            </span><span style="font-weight:bold;color:#a71d5d;">impl </span><span style="color:#323232;">HelloWorld </span><span style="font-weight:bold;color:#a71d5d;">for</span><span style="color:#323232;"> #name {
                </span><span style="font-weight:bold;color:#a71d5d;">fn </span><span style="font-weight:bold;color:#795da3;">hello_world</span><span style="color:#323232;">() {
                    println!(</span><span style="color:#183691;">&quot;Hello, World! My name is </span><span style="color:#0086b3;">{}</span><span style="color:#183691;">&quot;</span><span style="color:#323232;">, stringify!(</span><span style="font-weight:bold;color:#a71d5d;">#</span><span style="color:#323232;">name));
                }
            }
        }
    } </span><span style="font-weight:bold;color:#a71d5d;">else </span><span style="color:#323232;">{
        </span><span style="font-style:italic;color:#969896;">// Nope. This is an Enum. We cannot handle these!
        </span><span style="color:#323232;">panic!(</span><span style="color:#183691;">&quot;#[derive(HelloWorld)] is only defined for structs, not for enums!&quot;</span><span style="color:#323232;">);
    }
}
</span></pre><p id = "para-1782">If a user now tries to derive <code>HelloWorld</code> from an enum they will be greeted with following, hopefully helpful, error:</p>
<pre><span style="color:#323232;">error: custom derive attribute panicked
  --</span><span style="font-weight:bold;color:#a71d5d;">&gt;</span><span style="color:#323232;"> src/main.rs
   </span><span style="font-weight:bold;color:#a71d5d;">|
   | </span><span style="font-style:italic;color:#969896;">#[derive(HelloWorld)]
   </span><span style="font-weight:bold;color:#a71d5d;">|          </span><span style="color:#323232;">^^^^^^^^^^
   </span><span style="font-weight:bold;color:#a71d5d;">|
   = </span><span style="color:#323232;">help: message: </span><span style="font-style:italic;color:#969896;">#[derive(HelloWorld)] is only defined for structs, not for enums!
</span></pre>
</div><div id = "chapter-59" class = "chapter">
  <h2 class = 'part'>Part VI</h2> <h1 id = 'link-368' class = 'part'>Appendix</h1>
</div><div id = "chapter-60" class = "chapter">
  <h1 id = 'link-369'><span class = 'chapter-header'>Chapter 1</span><br />Glossary</h1><p id = "para-1783">Not every Rustacean has a background in systems programming, nor in computer science, so we’ve added explanations of terms that might be unfamiliar.</p>
<h3 id = "link-370">Abstract Syntax Tree</h3>
<p id = "para-1784">When a compiler is compiling your program, it does a number of different things. One of the things that it does is turn the text of your program into an ‘abstract syntax tree’, or ‘AST’. This tree is a representation of the structure of your program. For example, <code>2 + 3</code> can be turned into a tree:</p>
<pre><span style="color:#323232;">  +
 / \
2   3
</span></pre><p id = "para-1785">And <code>2 + (3 * 4)</code> would look like this:</p>
<pre><span style="color:#323232;">  +
 / \
2   *
   / \
  3   4
</span></pre><h3 id = "link-371">Arity</h3>
<p id = "para-1786">Arity refers to the number of arguments a function or operation takes.</p>
<pre><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> x </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">3</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> y </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">4</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">);
</span><span style="font-weight:bold;color:#a71d5d;">let</span><span style="color:#323232;"> z </span><span style="font-weight:bold;color:#a71d5d;">= </span><span style="color:#323232;">(</span><span style="color:#0086b3;">8</span><span style="color:#323232;">, </span><span style="color:#0086b3;">2</span><span style="color:#323232;">, </span><span style="color:#0086b3;">6</span><span style="color:#323232;">);
</span></pre><p id = "para-1787">In the example above <code>x</code> and <code>y</code> have arity 2. <code>z</code> has arity 3.</p>
<h3 id = "link-372">Bounds</h3>
<p id = "para-1788">Bounds are constraints on a type or <a href = "#chapter-26">trait</a>. For example, if a bound is placed on the argument a function takes, types passed to that function must abide by that constraint.</p>
<h3 id = "link-373">Combinators</h3>
<p id = "para-1789">Combinators are higher-order functions that apply only functions and earlier defined combinators to provide a result from its arguments. They can be used to manage control flow in a modular fashion.</p>
<h3 id = "link-374">DST (Dynamically Sized Type)</h3>
<p id = "para-1790">A type without a statically known size or alignment. (<a href = "src/../../nomicon/exotic-sizes.html#dynamically-sized-types-dsts">more info</a>)</p>
<h3 id = "link-375">Expression</h3>
<p id = "para-1791">In computer programming, an expression is a combination of values, constants, variables, operators and functions that evaluate to a single value. For example, <code>2 + (3 * 4)</code> is an expression that returns the value 14. It is worth noting that expressions can have side-effects. For example, a function included in an expression might perform actions other than simply returning a value.</p>
<h3 id = "link-376">Expression-Oriented Language</h3>
<p id = "para-1792">In early programming languages, <a href = "#chapter-60">expressions</a> and <a href = "#chapter-60">statements</a> were two separate syntactic categories: expressions had a value and statements did things. However, later languages blurred this distinction, allowing expressions to do things and statements to have a value. In an expression-oriented language, (nearly) every statement is an expression and therefore returns a value. Consequently, these expression statements can themselves form part of larger expressions.</p>
<h3 id = "link-377">Statement</h3>
<p id = "para-1793">In computer programming, a statement is the smallest standalone element of a programming language that commands a computer to perform an action.</p>

</div><div id = "chapter-61" class = "chapter">
  <h1 id = 'link-378'><span class = 'chapter-header'>Chapter 2</span><br />Syntax Index</h1><h2 id = "link-379">Keywords</h2>
<ul>
<li><code>as</code>: primitive casting, or disambiguating the specific trait containing an item. See <a href = "#chapter-36">Casting Between Types (<code>as</code>)</a>, <a href = "#chapter-31">Universal Function Call Syntax (Angle-bracket Form)</a>, <a href = "#chapter-37">Associated Types</a>.</li>
<li><code>break</code>: break out of loop. See <a href = "#chapter-13">Loops (Ending Iteration Early)</a>.</li>
<li><code>const</code>: constant items and constant raw pointers. See <a href = "#chapter-33"><code>const</code> and <code>static</code></a>, <a href = "#chapter-42">Raw Pointers</a>.</li>
<li><code>continue</code>: continue to next loop iteration. See <a href = "#chapter-13">Loops (Ending Iteration Early)</a>.</li>
<li><code>crate</code>: external crate linkage. See <a href = "#chapter-32">Crates and Modules (Importing External Crates)</a>.</li>
<li><code>else</code>: fallback for <code>if</code> and <code>if let</code> constructs. See <a href = "#chapter-12"><code>if</code></a>, <a href = "#chapter-28"><code>if let</code></a>.</li>
<li><code>enum</code>: defining enumeration. See <a href = "#chapter-20">Enums</a>.</li>
<li><code>extern</code>: external crate, function, and variable linkage. See <a href = "#chapter-32">Crates and Modules (Importing External Crates)</a>, <a href = "#chapter-54">Foreign Function Interface</a>.</li>
<li><code>false</code>: boolean false literal. See <a href = "#chapter-10">Primitive Types (Booleans)</a>.</li>
<li><code>fn</code>: function definition and function pointer types. See <a href = "#chapter-9">Functions</a>.</li>
<li><code>for</code>: iterator loop, part of trait <code>impl</code> syntax, and higher-ranked lifetime syntax. See <a href = "#chapter-13">Loops (<code>for</code>)</a>, <a href = "#chapter-23">Method Syntax</a>.</li>
<li><code>if</code>: conditional branching. See <a href = "#chapter-12"><code>if</code></a>, <a href = "#chapter-28"><code>if let</code></a>.</li>
<li><code>impl</code>: inherent and trait implementation blocks. See <a href = "#chapter-23">Method Syntax</a>.</li>
<li><code>in</code>: part of <code>for</code> loop syntax. See <a href = "#chapter-13">Loops (<code>for</code>)</a>.</li>
<li><code>let</code>: variable binding. See <a href = "#chapter-8">Variable Bindings</a>.</li>
<li><code>loop</code>: unconditional, infinite loop. See <a href = "#chapter-13">Loops (<code>loop</code>)</a>.</li>
<li><code>match</code>: pattern matching. See <a href = "#chapter-21">Match</a>.</li>
<li><code>mod</code>: module declaration. See <a href = "#chapter-32">Crates and Modules (Defining Modules)</a>.</li>
<li><code>move</code>: part of closure syntax. See <a href = "#chapter-30">Closures (<code>move</code> closures)</a>.</li>
<li><code>mut</code>: denotes mutability in pointer types and pattern bindings. See <a href = "#chapter-18">Mutability</a>.</li>
<li><code>pub</code>: denotes public visibility in <code>struct</code> fields, <code>impl</code> blocks, and modules. See <a href = "#chapter-32">Crates and Modules (Exporting a Public Interface)</a>.</li>
<li><code>ref</code>: by-reference binding. See <a href = "#chapter-22">Patterns (<code>ref</code> and <code>ref mut</code>)</a>.</li>
<li><code>return</code>: return from function. See <a href = "#chapter-9">Functions (Early Returns)</a>.</li>
<li><code>Self</code>: implementor type alias. See <a href = "#chapter-26">Traits</a>.</li>
<li><code>self</code>: method subject. See <a href = "#chapter-23">Method Syntax (Method Calls)</a>.</li>
<li><code>static</code>: global variable. See <a href = "#chapter-33"><code>const</code> and <code>static</code> (<code>static</code>)</a>.</li>
<li><code>struct</code>: structure definition. See <a href = "#chapter-19">Structs</a>.</li>
<li><code>trait</code>: trait definition. See <a href = "#chapter-26">Traits</a>.</li>
<li><code>true</code>: boolean true literal. See <a href = "#chapter-10">Primitive Types (Booleans)</a>.</li>
<li><code>type</code>: type alias, and associated type definition. See <a href = "#chapter-35"><code>type</code> Aliases</a>, <a href = "#chapter-37">Associated Types</a>.</li>
<li><code>unsafe</code>: denotes unsafe code, functions, traits, and implementations. See <a href = "#chapter-43">Unsafe</a>.</li>
<li><code>use</code>: import symbols into scope. See <a href = "#chapter-32">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>where</code>: type constraint clauses. See <a href = "#chapter-26">Traits (<code>where</code> clause)</a>.</li>
<li><code>while</code>: conditional loop. See <a href = "#chapter-13">Loops (<code>while</code>)</a>.</li>
</ul>
<h2 id = "link-380">Operators and Symbols</h2>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion. See <a href = "#chapter-41">Macros</a>.</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement. Overloadable (<code>Not</code>).</li>
<li><code>!=</code> (<code>var != expr</code>): nonequality comparison. Overloadable (<code>PartialEq</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder. Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder &amp; assignment. Overloadable (<code>RemAssign</code>).</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise and. Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>, <code>&amp;mut expr</code>): borrow. See <a href = "#chapter-16">References and Borrowing</a>.</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;’a type</code>, <code>&amp;’a mut type</code>): borrowed pointer type. See <a href = "#chapter-16">References and Borrowing</a>.</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise and &amp; assignment. Overloadable (<code>BitAndAssign</code>).</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical and.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication. Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer. See <a href = "#chapter-42">Raw Pointers</a>.</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication &amp; assignment. Overloadable (<code>MulAssign</code>).</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition. Overloadable (<code>Add</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>’a + trait</code>): compound type constraint. See <a href = "#chapter-26">Traits (Multiple Trait Bounds)</a>.</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition &amp; assignment. Overloadable (<code>AddAssign</code>).</li>
<li><code>,</code>: argument and element separator. See <a href = "#chapter-34">Attributes</a>, <a href = "#chapter-9">Functions</a>, <a href = "#chapter-19">Structs</a>, <a href = "#chapter-25">Generics</a>, <a href = "#chapter-21">Match</a>, <a href = "#chapter-30">Closures</a>, <a href = "#chapter-32">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction. Overloadable (<code>Sub</code>).</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation. Overloadable (<code>Neg</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction &amp; assignment. Overloadable (<code>SubAssign</code>).</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type. See <a href = "#chapter-9">Functions</a>, <a href = "#chapter-30">Closures</a>.</li>
<li><code>.</code> (<code>expr.ident</code>): member access. See <a href = "#chapter-19">Structs</a>, <a href = "#chapter-23">Method Syntax</a>.</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax. See <a href = "#chapter-19">Structs (Update syntax)</a>.</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): “and the rest” pattern binding. See <a href = "#chapter-22">Patterns (Ignoring bindings)</a>.</li>
<li><code>...</code> (<code>...expr</code>, <code>expr...expr</code>) <em>in an expression</em>: inclusive range expression. See <a href = "#chapter-50">Iterators</a>.</li>
<li><code>...</code> (<code>expr...expr</code>) <em>in a pattern</em>: inclusive range pattern. See <a href = "#chapter-22">Patterns (Ranges)</a>.</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division. Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division &amp; assignment. Overloadable (<code>DivAssign</code>).</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints. See <a href = "#chapter-8">Variable Bindings</a>, <a href = "#chapter-9">Functions</a>, <a href = "#chapter-19">Structs</a>, <a href = "#chapter-26">Traits</a>.</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer. See <a href = "#chapter-19">Structs</a>.</li>
<li><code>:</code> (<code>’a: loop {…}</code>): loop label. See <a href = "#chapter-13">Loops (Loops Labels)</a>.</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax. See <a href = "#chapter-10">Primitive Types (Arrays)</a>.</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift. Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift &amp; assignment. Overloadable (<code>ShlAssign</code>).</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): less-than or equal-to comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence. See <a href = "#chapter-8">Variable Bindings</a>, <a href = "#chapter-35"><code>type</code> Aliases</a>, generic parameter defaults.</li>
<li><code>==</code> (<code>var == expr</code>): equality comparison. Overloadable (<code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax. See <a href = "#chapter-21">Match</a>.</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): greater-than or equal-to comparison. Overloadable (<code>PartialOrd</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift. Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift &amp; assignment. Overloadable (<code>ShrAssign</code>).</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding. See <a href = "#chapter-22">Patterns (Bindings)</a>.</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive or. Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive or &amp; assignment. Overloadable (<code>BitXorAssign</code>).</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise or. Overloadable (<code>BitOr</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives. See <a href = "#chapter-22">Patterns (Multiple patterns)</a>.</li>
<li><code>|</code> (<code>|…| expr</code>): closures. See <a href = "#chapter-30">Closures</a>.</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise or &amp; assignment. Overloadable (<code>BitOrAssign</code>).</li>
<li><code>||</code> (<code>expr || expr</code>): logical or.</li>
<li><code>_</code>: “ignored” pattern binding (see <a href = "#chapter-22">Patterns (Ignoring bindings)</a>). Also used to make integer-literals readable (see <a href = "src/../../reference/tokens.html#integer-literals">Reference (Integer literals)</a>).</li>
<li><code>?</code> (<code>expr?</code>): Error propagation. Returns early when <code>Err(_)</code> is encountered, unwraps otherwise. Similar to the <a href = "#chapter-52"><code>try!</code> macro</a>.</li>
</ul>
<h2 id = "link-381">Other Syntax</h2>
<ul>
<li><code>’ident</code>: named lifetime or loop label. See <a href = "#chapter-17">Lifetimes</a>, <a href = "#chapter-13">Loops (Loops Labels)</a>.</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: numeric literal of specific type.</li>
<li><code>“…”</code>: string literal. See <a href = "#chapter-24">Strings</a>.</li>
<li><code>r"…"</code>, <code>r#"…"#</code>, <code>r##"…"##</code>, …: raw string literal, escape characters are not processed. See <a href = "src/../../reference/tokens.html#raw-string-literals">Reference (Raw String Literals)</a>.</li>
<li><code>b"…"</code>: byte string literal, constructs a <code>[u8]</code> instead of a string. See <a href = "src/../../reference/tokens.html#byte-and-byte-string-literals">Reference (Byte String Literals)</a>.</li>
<li><code>br"…"</code>, <code>br#"…"#</code>, <code>br##"…"##</code>, …: raw byte string literal, combination of raw and byte string literal. See <a href = "src/../../reference/tokens.html#raw-byte-string-literals">Reference (Raw Byte String Literals)</a>.</li>
<li><code>‘…’</code>: character literal. See <a href = "#chapter-10">Primitive Types (<code>char</code>)</a>.</li>
<li><code>b’…’</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure. See <a href = "#chapter-30">Closures</a>.</li>
</ul>
<ul>
<li><code>ident::ident</code>: path. See <a href = "#chapter-32">Crates and Modules (Defining Modules)</a>.</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path). See <a href = "#chapter-32">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path). See <a href = "#chapter-32">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>super::path</code>: path relative to the parent of the current module. See <a href = "#chapter-32">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code>: associated constants, functions, and types. See <a href = "#chapter-37">Associated Types</a>.</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>). See <a href = "#chapter-37">Associated Types</a>.</li>
<li><code>trait::method(…)</code>: disambiguating a method call by naming the trait which defines it. See <a href = "#chapter-31">Universal Function Call Syntax</a>.</li>
<li><code>type::method(…)</code>: disambiguating a method call by naming the type for which it’s defined. See <a href = "#chapter-31">Universal Function Call Syntax</a>.</li>
<li><code>&lt;type as trait&gt;::method(…)</code>: disambiguating a method call by naming the trait <em>and</em> type. See <a href = "#chapter-31">Universal Function Call Syntax (Angle-bracket Form)</a>.</li>
</ul>
<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>. See <a href = "#chapter-25">Generics</a>.</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>“42”.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>. See <a href = "#chapter-25">Generics § Resolving ambiguities</a>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function. See <a href = "#chapter-25">Generics</a>.</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure. See <a href = "#chapter-25">Generics</a>.</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration. See <a href = "#chapter-25">Generics</a>.</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments. See <a href = "#chapter-37">Associated Types</a>.</li>
</ul>
<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>. See <a href = "#chapter-26">Traits</a>.</li>
<li><code>T: ’a</code>: generic type <code>T</code> must outlive lifetime <code>’a</code>. When we say that a type ‘outlives’ the lifetime, we mean that it cannot transitively contain any references with lifetimes shorter than <code>’a</code>.</li>
<li><code>T : ’static</code>: The generic type <code>T</code> contains no borrowed references other than <code>’static</code> ones.</li>
<li><code>’b: ’a</code>: generic lifetime <code>’b</code> must outlive lifetime <code>’a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type. See <a href = "#chapter-38">Unsized Types (<code>?Sized</code>)</a>.</li>
<li><code>’a + trait</code>, <code>trait + trait</code>: compound type constraint. See <a href = "#chapter-26">Traits (Multiple Trait Bounds)</a>.</li>
</ul>
<ul>
<li><code>#[meta]</code>: outer attribute. See <a href = "#chapter-34">Attributes</a>.</li>
<li><code>#![meta]</code>: inner attribute. See <a href = "#chapter-34">Attributes</a>.</li>
<li><code>$ident</code>: macro substitution. See <a href = "#chapter-41">Macros</a>.</li>
<li><code>$ident:kind</code>: macro capture. See <a href = "#chapter-41">Macros</a>.</li>
<li><code>$(…)…</code>: macro repetition. See <a href = "#chapter-41">Macros</a>.</li>
</ul>
<ul>
<li><code>//</code>: line comment. See <a href = "#chapter-11">Comments</a>.</li>
<li><code>//!</code>: inner line doc comment. See <a href = "#chapter-11">Comments</a>.</li>
<li><code>///</code>: outer line doc comment. See <a href = "#chapter-11">Comments</a>.</li>
<li><code>/*…*/</code>: block comment. See <a href = "#chapter-11">Comments</a>.</li>
<li><code>/*!…*/</code>: inner block doc comment. See <a href = "#chapter-11">Comments</a>.</li>
<li><code>/**…*/</code>: outer block doc comment. See <a href = "#chapter-11">Comments</a>.</li>
</ul>
<ul>
<li><code>!</code>: always empty Never type. See <a href = "#chapter-9">Diverging Functions</a>.</li>
</ul>
<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression. See <a href = "#chapter-10">Primitive Types (Tuples)</a>.</li>
<li><code>(type,)</code>: single-element tuple type. See <a href = "#chapter-10">Primitive Types (Tuples)</a>.</li>
<li><code>(expr, …)</code>: tuple expression. See <a href = "#chapter-10">Primitive Types (Tuples)</a>.</li>
<li><code>(type, …)</code>: tuple type. See <a href = "#chapter-10">Primitive Types (Tuples)</a>.</li>
<li><code>expr(expr, …)</code>: function call expression. Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants. See <a href = "#chapter-9">Functions</a>.</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation. See <a href = "#chapter-41">Macros</a>.</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing. See <a href = "#chapter-10">Primitive Types (Tuple Indexing)</a>.</li>
</ul>
<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal. See <a href = "#chapter-19">Structs</a>.</li>
</ul>
<ul>
<li><code>[…]</code>: array literal. See <a href = "#chapter-10">Primitive Types (Arrays)</a>.</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>. See <a href = "#chapter-10">Primitive Types (Arrays)</a>.</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>. See <a href = "#chapter-10">Primitive Types (Arrays)</a>.</li>
<li><code>expr[expr]</code>: collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the “index”.</li>
</ul>

</div><div id = "chapter-62" class = "chapter">
  <h1 id = 'link-382'><span class = 'chapter-header'>Chapter 3</span><br />Bibliography</h1><p id = "para-1794">This is a reading list of material relevant to Rust. It includes prior research that has - at one time or another - influenced the design of Rust, as well as publications about Rust.</p>
<h3 id = "link-383">Type system</h3>
<ul>
<li><a href = "http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href = "http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href = "http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
<li><a href = "https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href = "http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href = "http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href = "http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href = "https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href = "http://www.cs.ucla.edu/~palsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h3 id = "link-384">Concurrency</h3>
<ul>
<li><a href = "https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href = "https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href = "http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href = "http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href = "http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href = "http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href = "http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href = "http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java’s fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href = "http://www.stanford.edu/~ouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href = "http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href = "http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href = "http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href = "http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href = "http://www.mpi-sws.org/~turon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href = "https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
<li><a href = "https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
</ul>
<h3 id = "link-385">Others</h3>
<ul>
<li><a href = "https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href = "http://people.cs.umass.edu/~emery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href = "http://people.cs.umass.edu/~emery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h3 id = "link-386">Papers <em>about</em> Rust</h3>
<ul>
<li><a href = "http://www.cs.indiana.edu/~eholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a Systems Level Language</a>. Early GPU work by Eric Holk.</li>
<li><a href = "https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old idea</a><ul>
<li>not exactly about Rust, but by nmatsakis</li>
</ul>
</li>
<li><a href = "ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming Language</a>. Early formalization of a subset of the type system, by Eric Reed.</li>
<li><a href = "http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using Rust</a>. By Lars Bergstrom.</li>
<li><a href = "https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in Rust</a>. Undergrad paper by Michael Sproul.</li>
<li><a href = "http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in Rust</a>. Undergrad paper by Alex Light.</li>
<li><a href = "http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf">Evaluation of performance and productivity metrics of potential programming languages in the HPC environment</a>. Bachelor’s thesis by Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href = "http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library in Rust</a>. By Geoffroy Couprie, research for VLC.</li>
<li><a href = "http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate Representation</a>. An experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href = "http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil Codes</a>. Another paper using Impala.</li>
<li><a href = "http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and friends</a>. Linus Farnstrand’s master’s thesis.</li>
<li><a href = "http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for Rust</a>. Philip Munksgaard’s master’s thesis. Research for Servo.</li>
<li><a href = "http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
<li><a href = "https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">You can’t spell trust without Rust</a>. Alexis Beingessner’s master’s thesis.</li>
<li><a href = "http://users.cecs.anu.edu.au/~steveb/downloads/pdf/rust-ismm-2016.pdf">Rust as a Language for High Performance GC Implementation</a></li>
</ul>

</div><div class = "notes">
 <h2 class = "notes">Notes</h2>
<table class = "notes">
<tr class = "notes">
 <td class = "note-number">
  <p class = "note-number">
  <a href = "#note-source-1">[1]</a>
</p>

 </td>
 <td class = "note">
  <aside id = "note-dest-1"><p id = "para-980">The actual definition of <code>vec!</code> in libcollections differs from the one presented here, for reasons of efficiency and reusability.</p>
</aside>
  </td>
</tr>
<tr class = "notes">
 <td class = "note-number">
  <p class = "note-number">
  <a href = "#note-source-2">[2]</a>
</p>

 </td>
 <td class = "note">
  <aside id = "note-dest-2"><p id = "para-1101">‘Gigabyte’ can mean two things: 109, or 230. The IEC standard resolved this by stating that ‘gigabyte’ is 109, and ‘gibibyte’ is 230. However, very few people use this terminology, and rely on context to differentiate. We follow in that tradition here.</p>
</aside>
  </td>
</tr>
<tr class = "notes">
 <td class = "note-number">
  <p class = "note-number">
  <a href = "#note-source-3">[3]</a>
</p>

 </td>
 <td class = "note">
  <aside id = "note-dest-3"><p id = "para-1127">We can make the memory live longer by transferring ownership, sometimes called ‘moving out of the box’. More complex examples will be covered later.</p>
</aside>
  </td>
</tr>
<tr class = "notes">
 <td class = "note-number">
  <p class = "note-number">
  <a href = "#note-source-4">[4]</a>
</p>

 </td>
 <td class = "note">
  <aside id = "note-dest-4"><p id = "para-1640"><code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> actually won’t compile since <code>UnsafeCell&lt;T&gt;</code> isn’t <code>Send</code> or <code>Sync</code>, but we can wrap it in a type and implement <code>Send</code>/<code>Sync</code> for it manually to get <code>Arc&lt;Wrapper&lt;T&gt;&gt;</code> where <code>Wrapper</code> is <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.</p>
</aside>
  </td>
</tr>
<tr class = "notes">
 <td class = "note-number">
  <p class = "note-number">
  <a href = "#note-source-5">[5]</a>
</p>

 </td>
 <td class = "note">
  <aside id = "note-dest-5"><p id = "para-1653"><code>&amp;[T]</code> and <code>&amp;mut [T]</code> are <em>slices</em>; they consist of a pointer and a length and can refer to a portion of a vector or array. <code>&amp;mut [T]</code> can have its elements mutated, however its length cannot be touched.</p>
</aside>
  </td>
</tr>
</table>
</div>


      </div>
      
    </div>
  </body>
</html>
